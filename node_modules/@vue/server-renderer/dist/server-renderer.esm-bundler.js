/**
  * @vue/server-renderer v3.6.0-beta.5
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
import { Comment, Fragment, Static, Text, createApp, createVNode, initDirectivesForSSR, mergeProps, ssrContextKey, ssrUtils, warn } from "vue";
import { EMPTY_OBJ, NOOP, escapeHtml, escapeHtmlComment, extend, getGlobalThis, includeBooleanAttr, includeBooleanAttr as ssrIncludeBooleanAttr, isArray, isBooleanAttr, isFunction, isObject, isOn, isPromise, isRenderableAttrValue, isSSRSafeAttrName, isSVGTag, isString, isVoidTag, looseEqual, looseIndexOf, makeMap, normalizeClass, normalizeCssVarValue, normalizeStyle, propsToAttrMap, stringifyStyle, toDisplayString } from "@vue/shared";

//#region packages/server-renderer/src/helpers/ssrRenderAttrs.ts
const shouldIgnoreProp = /* @__PURE__ */ makeMap(`,key,ref,innerHTML,textContent,ref_key,ref_for`);
function ssrRenderAttrs(props, tag) {
	let ret = "";
	for (let key in props) {
		if (shouldIgnoreProp(key) || isOn(key) || tag === "textarea" && key === "value" || key.startsWith(".")) continue;
		const value = props[key];
		if (key.startsWith("^")) key = key.slice(1);
		if (key === "class" || key === "className") ret += ` class="${ssrRenderClass(value)}"`;
		else if (key === "style") ret += ` style="${ssrRenderStyle(value)}"`;
		else ret += ssrRenderDynamicAttr(key, value, tag);
	}
	return ret;
}
function ssrRenderDynamicAttr(key, value, tag) {
	if (!isRenderableAttrValue(value)) return ``;
	const attrKey = tag && (tag.indexOf("-") > 0 || isSVGTag(tag)) ? key : propsToAttrMap[key] || key.toLowerCase();
	if (isBooleanAttr(attrKey)) return includeBooleanAttr(value) ? ` ${attrKey}` : ``;
	else if (isSSRSafeAttrName(attrKey)) return value === "" ? ` ${attrKey}` : ` ${attrKey}="${escapeHtml(value)}"`;
	else {
		console.warn(`[@vue/server-renderer] Skipped rendering unsafe attribute name: ${attrKey}`);
		return ``;
	}
}
function ssrRenderAttr(key, value) {
	if (!isRenderableAttrValue(value)) return ``;
	return ` ${key}="${escapeHtml(value)}"`;
}
function ssrRenderClass(raw) {
	return escapeHtml(normalizeClass(raw));
}
function ssrRenderStyle(raw) {
	if (!raw) return "";
	if (isString(raw)) return escapeHtml(raw);
	return escapeHtml(stringifyStyle(normalizeStyle(ssrResetCssVars(raw))));
}
function ssrResetCssVars(raw) {
	if (!isArray(raw) && isObject(raw)) {
		const res = {};
		for (const key in raw) if (key.startsWith(":--")) res[key.slice(1)] = normalizeCssVarValue(raw[key]);
		else res[key] = raw[key];
		return res;
	}
	return raw;
}

//#endregion
//#region packages/server-renderer/src/helpers/ssrRenderComponent.ts
function ssrRenderComponent(comp, props = null, children = null, parentComponent = null, slotScopeId) {
	return renderComponentVNode(createVNode(comp, props, children), parentComponent, slotScopeId);
}

//#endregion
//#region packages/server-renderer/src/helpers/ssrRenderSlot.ts
const { ensureValidVNode } = ssrUtils;
function ssrRenderSlot(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId) {
	push(`<!--[-->`);
	ssrRenderSlotInner(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId);
	push(`<!--]-->`);
}
function ssrRenderSlotInner(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId, transition) {
	const slotFn = slots[slotName];
	if (slotFn) {
		const slotBuffer = [];
		const bufferedPush = (item) => {
			slotBuffer.push(item);
		};
		const ret = slotFn(slotProps, bufferedPush, parentComponent, slotScopeId ? " " + slotScopeId : "");
		if (isArray(ret)) {
			const validSlotContent = ensureValidVNode(ret);
			if (validSlotContent) renderVNodeChildren(push, validSlotContent, parentComponent, slotScopeId);
			else if (fallbackRenderFn) fallbackRenderFn();
			else if (transition) push(`<!---->`);
		} else {
			let isEmptySlot = true;
			if (transition) isEmptySlot = false;
			else for (let i = 0; i < slotBuffer.length; i++) if (!isComment(slotBuffer[i])) {
				isEmptySlot = false;
				break;
			}
			if (isEmptySlot) {
				if (fallbackRenderFn) fallbackRenderFn();
			} else {
				let start = 0;
				let end = slotBuffer.length;
				if (transition && slotBuffer[0] === "<!--[-->" && slotBuffer[end - 1] === "<!--]-->") {
					start++;
					end--;
				}
				if (start < end) for (let i = start; i < end; i++) push(slotBuffer[i]);
				else if (transition) push(`<!---->`);
			}
		}
	} else if (fallbackRenderFn) fallbackRenderFn();
	else if (transition) push(`<!---->`);
}
const commentTestRE = /^<!--[\s\S]*-->$/;
const commentRE = /<!--[^]*?-->/gm;
function isComment(item) {
	if (typeof item !== "string" || !commentTestRE.test(item)) return false;
	if (item.length <= 8) return true;
	return !item.replace(commentRE, "").trim();
}

//#endregion
//#region packages/server-renderer/src/helpers/ssrRenderTeleport.ts
function ssrRenderTeleport(parentPush, contentRenderFn, target, disabled, parentComponent) {
	parentPush("<!--teleport start-->");
	const context = parentComponent.appContext.provides[ssrContextKey];
	const teleportBuffers = context.__teleportBuffers || (context.__teleportBuffers = {});
	const targetBuffer = teleportBuffers[target] || (teleportBuffers[target] = []);
	const bufferIndex = targetBuffer.length;
	let teleportContent;
	if (disabled) {
		contentRenderFn(parentPush);
		teleportContent = `<!--teleport start anchor--><!--teleport anchor-->`;
	} else {
		const { getBuffer, push } = createBuffer();
		push(`<!--teleport start anchor-->`);
		contentRenderFn(push);
		push(`<!--teleport anchor-->`);
		teleportContent = getBuffer();
	}
	targetBuffer.splice(bufferIndex, 0, teleportContent);
	parentPush("<!--teleport end-->");
}

//#endregion
//#region packages/server-renderer/src/helpers/ssrInterpolate.ts
function ssrInterpolate(value) {
	return escapeHtml(toDisplayString(value));
}

//#endregion
//#region packages/reactivity/src/debug.ts
function onTrack(sub, debugInfo) {
	if (!!!(process.env.NODE_ENV !== "production")) throw new Error(`Internal error: onTrack should be called only in development.`);
	if (sub.onTrack) sub.onTrack(extend({ effect: sub }, debugInfo));
}

//#endregion
//#region packages/reactivity/src/system.ts
let activeSub = void 0;
let globalVersion = 0;
function setActiveSub(sub) {
	try {
		return activeSub;
	} finally {
		activeSub = sub;
	}
}
function link(dep, sub) {
	const prevDep = sub.depsTail;
	if (prevDep !== void 0 && prevDep.dep === dep) return;
	const nextDep = prevDep !== void 0 ? prevDep.nextDep : sub.deps;
	if (nextDep !== void 0 && nextDep.dep === dep) {
		nextDep.version = globalVersion;
		sub.depsTail = nextDep;
		return;
	}
	const prevSub = dep.subsTail;
	if (prevSub !== void 0 && prevSub.version === globalVersion && prevSub.sub === sub) return;
	const newLink = sub.depsTail = dep.subsTail = {
		version: globalVersion,
		dep,
		sub,
		prevDep,
		nextDep,
		prevSub,
		nextSub: void 0
	};
	if (nextDep !== void 0) nextDep.prevDep = newLink;
	if (prevDep !== void 0) prevDep.nextDep = newLink;
	else sub.deps = newLink;
	if (prevSub !== void 0) prevSub.nextSub = newLink;
	else dep.subs = newLink;
}

//#endregion
//#region packages/reactivity/src/dep.ts
var Dep = class {
	constructor(map, key) {
		this.map = map;
		this.key = key;
		this._subs = void 0;
		this.subsTail = void 0;
		this.flags = 0;
	}
	get subs() {
		return this._subs;
	}
	set subs(value) {
		this._subs = value;
		if (value === void 0) this.map.delete(this.key);
	}
};
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== "production") ? "Object iterate" : "");
const MAP_KEY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== "production") ? "Map keys iterate" : "");
const ARRAY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== "production") ? "Array iterate" : "");
/**
* Tracks access to a reactive property.
*
* This will check which effect is running at the moment and record it as dep
* which records all effects that depend on the reactive property.
*
* @param target - Object holding the reactive property.
* @param type - Defines the type of access to the reactive property.
* @param key - Identifier of the reactive property to track.
*/
function track(target, type, key) {
	if (activeSub !== void 0) {
		let depsMap = targetMap.get(target);
		if (!depsMap) targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
		let dep = depsMap.get(key);
		if (!dep) depsMap.set(key, dep = new Dep(depsMap, key));
		if (!!(process.env.NODE_ENV !== "production")) onTrack(activeSub, {
			target,
			type,
			key
		});
		link(dep, activeSub);
	}
}

//#endregion
//#region packages/reactivity/src/reactive.ts
/**
* Checks if an object is a proxy created by {@link reactive},
* {@link readonly}, {@link shallowReactive} or {@link shallowReadonly}.
*
* @param value - The value to check.
* @see {@link https://vuejs.org/api/reactivity-utilities.html#isproxy}
*/
/* @__NO_SIDE_EFFECTS__ */
function isProxy(value) {
	return value ? !!value["__v_raw"] : false;
}
/**
* Returns the raw, original object of a Vue-created proxy.
*
* `toRaw()` can return the original object from proxies created by
* {@link reactive}, {@link readonly}, {@link shallowReactive} or
* {@link shallowReadonly}.
*
* This is an escape hatch that can be used to temporarily read without
* incurring proxy access / tracking overhead or write without triggering
* changes. It is **not** recommended to hold a persistent reference to the
* original object. Use with caution.
*
* @example
* ```js
* const foo = {}
* const reactiveFoo = reactive(foo)
*
* console.log(toRaw(reactiveFoo) === foo) // true
* ```
*
* @param observed - The object for which the "raw" value is requested.
* @see {@link https://vuejs.org/api/reactivity-advanced.html#toraw}
*/
/* @__NO_SIDE_EFFECTS__ */
function toRaw(observed) {
	const raw = observed && observed["__v_raw"];
	return raw ? /* @__PURE__ */ toRaw(raw) : observed;
}

//#endregion
//#region packages/reactivity/src/ref.ts
/* @__NO_SIDE_EFFECTS__ */
function isRef(r) {
	return r ? r["__v_isRef"] === true : false;
}

//#endregion
//#region packages/runtime-core/src/warning.ts
const stack = [];
/**
* @internal
*/
function pushWarningContext$1(ctx) {
	stack.push(ctx);
}
/**
* @internal
*/
function popWarningContext$1() {
	stack.pop();
}
let isWarning = false;
function warn$2(msg, ...args) {
	if (isWarning) return;
	isWarning = true;
	const prevSub = setActiveSub();
	const entry = stack.length ? stack[stack.length - 1] : null;
	const instance = isVNode$2(entry) ? entry.component : entry;
	const appWarnHandler = instance && instance.appContext.config.warnHandler;
	const trace = getComponentTrace();
	if (appWarnHandler) callWithErrorHandling(appWarnHandler, instance, 11, [
		msg + args.map((a) => {
			var _a$toString, _a$toString2;
			return (_a$toString = (_a$toString2 = a.toString) === null || _a$toString2 === void 0 ? void 0 : _a$toString2.call(a)) !== null && _a$toString !== void 0 ? _a$toString : JSON.stringify(a);
		}).join(""),
		instance && instance.proxy || instance,
		trace.map(({ ctx }) => `at <${formatComponentName(instance, ctx.type)}>`).join("\n"),
		trace
	]);
	else {
		const warnArgs = [`[Vue warn]: ${msg}`, ...args];
		if (trace.length && true)
 /* v8 ignore next 2 */
		warnArgs.push(`\n`, ...formatTrace(trace));
		console.warn(...warnArgs);
	}
	setActiveSub(prevSub);
	isWarning = false;
}
function getComponentTrace() {
	let currentCtx = stack[stack.length - 1];
	if (!currentCtx) return [];
	const normalizedStack = [];
	while (currentCtx) {
		const last = normalizedStack[0];
		if (last && last.ctx === currentCtx) last.recurseCount++;
		else normalizedStack.push({
			ctx: currentCtx,
			recurseCount: 0
		});
		if (isVNode$2(currentCtx)) {
			const parent = currentCtx.component && currentCtx.component.parent;
			currentCtx = parent && parent.vnode || parent;
		} else currentCtx = currentCtx.parent;
	}
	return normalizedStack;
}
/* v8 ignore start */
function formatTrace(trace) {
	const logs = [];
	trace.forEach((entry, i) => {
		logs.push(...i === 0 ? [] : [`\n`], ...formatTraceEntry(entry));
	});
	return logs;
}
function formatTraceEntry({ ctx, recurseCount }) {
	const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
	const instance = isVNode$2(ctx) ? ctx.component : ctx;
	const isRoot = instance ? instance.parent == null : false;
	const open = ` at <${formatComponentName(instance, ctx.type, isRoot)}`;
	const close = `>` + postfix;
	return ctx.props ? [
		open,
		...formatProps(ctx.props),
		close
	] : [open + close];
}
function formatProps(props) {
	const res = [];
	const keys = Object.keys(props);
	keys.slice(0, 3).forEach((key) => {
		res.push(...formatProp(key, props[key]));
	});
	if (keys.length > 3) res.push(` ...`);
	return res;
}
function formatProp(key, value, raw) {
	if (isString(value)) {
		value = JSON.stringify(value);
		return raw ? value : [`${key}=${value}`];
	} else if (typeof value === "number" || typeof value === "boolean" || value == null) return raw ? value : [`${key}=${value}`];
	else if (/* @__PURE__ */ isRef(value)) {
		value = formatProp(key, /* @__PURE__ */ toRaw(value.value), true);
		return raw ? value : [
			`${key}=Ref<`,
			value,
			`>`
		];
	} else if (isFunction(value)) return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
	else {
		value = /* @__PURE__ */ toRaw(value);
		return raw ? value : [`${key}=`, value];
	}
}
/* v8 ignore stop */

//#endregion
//#region packages/runtime-core/src/errorHandling.ts
const ErrorTypeStrings = {
	["sp"]: "serverPrefetch hook",
	["bc"]: "beforeCreate hook",
	["c"]: "created hook",
	["bm"]: "beforeMount hook",
	["m"]: "mounted hook",
	["bu"]: "beforeUpdate hook",
	["u"]: "updated",
	["bum"]: "beforeUnmount hook",
	["um"]: "unmounted hook",
	["a"]: "activated hook",
	["da"]: "deactivated hook",
	["ec"]: "errorCaptured hook",
	["rtc"]: "renderTracked hook",
	["rtg"]: "renderTriggered hook",
	[0]: "setup function",
	[1]: "render function",
	[2]: "watcher getter",
	[3]: "watcher callback",
	[4]: "watcher cleanup function",
	[5]: "native event handler",
	[6]: "component event handler",
	[7]: "vnode hook",
	[8]: "directive hook",
	[9]: "transition hook",
	[10]: "app errorHandler",
	[11]: "app warnHandler",
	[12]: "ref function",
	[13]: "async component loader",
	[14]: "scheduler flush",
	[15]: "component update",
	[16]: "app unmount cleanup function"
};
function callWithErrorHandling(fn, instance, type, args) {
	try {
		return args ? fn(...args) : fn();
	} catch (err) {
		handleError(err, instance, type);
	}
}
function handleError(err, instance, type, throwInDev = true) {
	const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
	if (instance) {
		let cur = instance.parent;
		const exposedInstance = instance.proxy || instance;
		const errorInfo = !!(process.env.NODE_ENV !== "production") ? ErrorTypeStrings[type] : `https://vuejs.org/error-reference/#runtime-${type}`;
		while (cur) {
			const errorCapturedHooks = cur.ec;
			if (errorCapturedHooks) {
				for (let i = 0; i < errorCapturedHooks.length; i++) if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) return;
			}
			cur = cur.parent;
		}
		if (errorHandler) {
			const prevSub = setActiveSub();
			callWithErrorHandling(errorHandler, null, 10, [
				err,
				exposedInstance,
				errorInfo
			]);
			setActiveSub(prevSub);
			return;
		}
	}
	logError(err, type, instance, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, instance, throwInDev = true, throwInProd = false) {
	if (!!(process.env.NODE_ENV !== "production")) {
		const info = ErrorTypeStrings[type];
		if (instance) pushWarningContext$1(instance);
		warn$2(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
		if (instance) popWarningContext$1();
		if (throwInDev) throw err;
		else console.error(err);
	} else if (throwInProd) throw err;
	else console.error(err);
}

//#endregion
//#region packages/runtime-core/src/scheduler.ts
const jobs = [];
let postJobs = [];
let activePostJobs = null;
let currentFlushPromise = null;
let jobsLength = 0;
let flushIndex = 0;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
const RECURSION_LIMIT = 100;
function nextTick(fn) {
	const p = currentFlushPromise || resolvedPromise;
	return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(order, queue, start, end) {
	while (start < end) {
		const middle = start + end >>> 1;
		if (queue[middle].order <= order) start = middle + 1;
		else end = middle;
	}
	return start;
}
/**
* @internal for runtime-vapor only
*/
function queueJob(job, id, isPre = false) {
	if (queueJobWorker(job, id === void 0 ? isPre ? -2 : Infinity : isPre ? id * 2 : id * 2 + 1, jobs, jobsLength, flushIndex)) {
		jobsLength++;
		queueFlush();
	}
}
function queueJobWorker(job, order, queue, length, flushIndex) {
	const flags = job.flags;
	if (!(flags & 1)) {
		job.flags = flags | 1;
		job.order = order;
		if (flushIndex === length || order >= queue[length - 1].order) queue[length] = job;
		else queue.splice(findInsertionIndex(order, queue, flushIndex, length), 0, job);
		return true;
	}
	return false;
}
const doFlushJobs = () => {
	try {
		flushJobs();
	} catch (e) {
		currentFlushPromise = null;
		throw e;
	}
};
function queueFlush() {
	if (!currentFlushPromise) currentFlushPromise = resolvedPromise.then(doFlushJobs);
}
function queuePostFlushCb(jobs, id = Infinity) {
	if (!isArray(jobs)) if (activePostJobs && id === -1) activePostJobs.splice(postFlushIndex, 0, jobs);
	else queueJobWorker(jobs, id, postJobs, postJobs.length, 0);
	else for (const job of jobs) queueJobWorker(job, id, postJobs, postJobs.length, 0);
	queueFlush();
}
function flushPostFlushCbs(seen) {
	if (postJobs.length) {
		if (activePostJobs) {
			activePostJobs.push(...postJobs);
			postJobs.length = 0;
			return;
		}
		activePostJobs = postJobs;
		postJobs = [];
		if (!!(process.env.NODE_ENV !== "production")) seen = seen || /* @__PURE__ */ new Map();
		while (postFlushIndex < activePostJobs.length) {
			const cb = activePostJobs[postFlushIndex++];
			if (!!(process.env.NODE_ENV !== "production") && checkRecursiveUpdates(seen, cb)) continue;
			if (cb.flags & 2) cb.flags &= -2;
			if (!(cb.flags & 4)) try {
				cb();
			} finally {
				cb.flags &= -2;
			}
		}
		activePostJobs = null;
		postFlushIndex = 0;
	}
}
function flushJobs(seen) {
	if (!!(process.env.NODE_ENV !== "production")) seen || (seen = /* @__PURE__ */ new Map());
	try {
		while (flushIndex < jobsLength) {
			const job = jobs[flushIndex];
			jobs[flushIndex++] = void 0;
			if (!(job.flags & 4)) {
				if (!!(process.env.NODE_ENV !== "production") && checkRecursiveUpdates(seen, job)) continue;
				if (job.flags & 2) job.flags &= -2;
				try {
					job();
				} catch (err) {
					handleError(err, job.i, job.i ? 15 : 14);
				} finally {
					if (!(job.flags & 2)) job.flags &= -2;
				}
			}
		}
	} finally {
		while (flushIndex < jobsLength) {
			jobs[flushIndex].flags &= -2;
			jobs[flushIndex++] = void 0;
		}
		flushIndex = 0;
		jobsLength = 0;
		flushPostFlushCbs(seen);
		currentFlushPromise = null;
		if (jobsLength || postJobs.length) flushJobs(seen);
	}
}
function checkRecursiveUpdates(seen, fn) {
	const count = seen.get(fn) || 0;
	if (count > RECURSION_LIMIT) {
		const instance = fn.i;
		const componentName = instance && getComponentName(instance.type);
		handleError(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`, null, 10);
		return true;
	}
	seen.set(fn, count + 1);
	return false;
}

//#endregion
//#region packages/runtime-core/src/hmr.ts
let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Map();
const hmrDirtyComponentsMode = /* @__PURE__ */ new Map();
if (!!(process.env.NODE_ENV !== "production")) getGlobalThis().__VUE_HMR_RUNTIME__ = {
	createRecord: tryWrap(createRecord),
	rerender: tryWrap(rerender),
	reload: tryWrap(reload)
};
const map = /* @__PURE__ */ new Map();
function createRecord(id, initialDef) {
	if (map.has(id)) return false;
	map.set(id, {
		initialDef: normalizeClassComponent(initialDef),
		instances: /* @__PURE__ */ new Set()
	});
	return true;
}
function normalizeClassComponent(component) {
	return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
	const record = map.get(id);
	if (!record) return;
	record.initialDef.render = newRender;
	[...record.instances].forEach((instance) => {
		if (newRender) {
			instance.render = newRender;
			normalizeClassComponent(instance.type).render = newRender;
		}
		isHmrUpdating = true;
		if (instance.vapor) {
			if (!instance.isUnmounted) instance.hmrRerender();
		} else {
			const i = instance;
			if (!(i.effect.flags & 1024)) {
				i.renderCache = [];
				i.effect.run();
			}
		}
		nextTick(() => {
			isHmrUpdating = false;
		});
	});
}
function reload(id, newComp) {
	const record = map.get(id);
	if (!record) return;
	newComp = normalizeClassComponent(newComp);
	const isVapor = record.initialDef.__vapor;
	updateComponentDef(record.initialDef, newComp);
	const instances = [...record.instances];
	if (isVapor && newComp.__vapor && !instances.some((i) => i.ceReload)) {
		for (const instance of instances) if (instance.root && instance.root.ce && instance !== instance.root) instance.root.ce._removeChildStyle(instance.type);
		for (const instance of instances) instance.hmrReload(newComp);
	} else for (const instance of instances) {
		const oldComp = normalizeClassComponent(instance.type);
		let dirtyInstances = hmrDirtyComponents.get(oldComp);
		if (!dirtyInstances) {
			if (oldComp !== record.initialDef) updateComponentDef(oldComp, newComp);
			hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */ new Set());
		}
		dirtyInstances.add(instance);
		hmrDirtyComponentsMode.set(oldComp, !!isVapor);
		instance.appContext.propsCache.delete(instance.type);
		instance.appContext.emitsCache.delete(instance.type);
		instance.appContext.optionsCache.delete(instance.type);
		if (instance.ceReload) {
			dirtyInstances.add(instance);
			instance.ceReload(newComp.styles);
			dirtyInstances.delete(instance);
		} else if (instance.parent) queueJob(() => {
			isHmrUpdating = true;
			const parent = instance.parent;
			if (parent.vapor) parent.hmrRerender();
			else if (!(parent.effect.flags & 1024)) {
				parent.renderCache = [];
				parent.effect.run();
			}
			nextTick(() => {
				isHmrUpdating = false;
			});
			dirtyInstances.delete(instance);
		});
		else if (instance.appContext.reload) instance.appContext.reload();
		else if (typeof window !== "undefined") window.location.reload();
		else console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
		if (instance.root.ce && instance !== instance.root) instance.root.ce._removeChildStyle(oldComp);
	}
	queuePostFlushCb(() => {
		hmrDirtyComponents.clear();
		hmrDirtyComponentsMode.clear();
	});
}
function updateComponentDef(oldComp, newComp) {
	extend(oldComp, newComp);
	for (const key in oldComp) if (key !== "__file" && !(key in newComp)) delete oldComp[key];
}
function tryWrap(fn) {
	return (id, arg) => {
		try {
			return fn(id, arg);
		} catch (e) {
			console.error(e);
			console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.");
		}
	};
}

//#endregion
//#region packages/runtime-core/src/devtools.ts
let devtools$1;
let buffer = [];
let devtoolsNotInstalled = false;
function setDevtoolsHook$1(hook, target) {
	var _window$navigator;
	devtools$1 = hook;
	if (devtools$1) {
		devtools$1.enabled = true;
		buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
		buffer = [];
	} else if (typeof window !== "undefined" && window.HTMLElement && !((_window$navigator = window.navigator) === null || _window$navigator === void 0 || (_window$navigator = _window$navigator.userAgent) === null || _window$navigator === void 0 ? void 0 : _window$navigator.includes("jsdom"))) {
		(target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((newHook) => {
			setDevtoolsHook$1(newHook, target);
		});
		setTimeout(() => {
			if (!devtools$1) {
				target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
				devtoolsNotInstalled = true;
				buffer = [];
			}
		}, 3e3);
	} else {
		devtoolsNotInstalled = true;
		buffer = [];
	}
}

//#endregion
//#region packages/runtime-core/src/componentRenderContext.ts
/**
* mark the current rendering instance for asset resolution (e.g.
* resolveComponent, resolveDirective) during render
*/
let currentRenderingInstance = null;
let currentScopeId = null;

//#endregion
//#region packages/runtime-core/src/components/Teleport.ts
const isTeleport = (type) => type.__isTeleport;

//#endregion
//#region packages/runtime-core/src/components/BaseTransition.ts
function setTransitionHooks(vnode, hooks) {
	if (vnode.shapeFlag & 6 && vnode.component) if (isVaporComponent(vnode.type)) getVaporInterface(vnode.component, vnode).setTransitionHooks(vnode.component, hooks);
	else {
		vnode.transition = hooks;
		setTransitionHooks(vnode.component.subTree, hooks);
	}
	else if (vnode.shapeFlag & 128) {
		vnode.ssContent.transition = hooks.clone(vnode.ssContent);
		vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
	} else vnode.transition = hooks;
}

//#endregion
//#region packages/runtime-core/src/helpers/resolveAssets.ts
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");

//#endregion
//#region packages/runtime-core/src/componentRenderUtils.ts
/**
* dev only flag to track whether $attrs was used during render.
* If $attrs was used during render then the warning for failed attrs
* fallthrough can be suppressed.
*/
let accessedAttrs = false;
function markAttrsAccessed() {
	accessedAttrs = true;
}

//#endregion
//#region packages/runtime-core/src/internalObject.ts
/**
* Used during vnode props/slots normalization to check if the vnode props/slots
* are the internal attrs / slots object of a component via
* `Object.getPrototypeOf`. This is more performant than defining a
* non-enumerable property. (one of the optimizations done for ssr-benchmark)
*/
const internalObjectProto = {};
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;

//#endregion
//#region packages/runtime-core/src/renderer.ts
function getVaporInterface(instance, vnode) {
	const ctx = instance ? instance.appContext : vnode.appContext;
	const res = ctx && ctx.vapor;
	if (!!(process.env.NODE_ENV !== "production") && !res) warn$2("Vapor component found in vdom tree but vapor-in-vdom interop was not installed. Make sure to install it:\n```\nimport { vaporInteropPlugin } from 'vue'\napp.use(vaporInteropPlugin)\n```");
	return res;
}
function isVaporComponent(type) {
	if (!!(process.env.NODE_ENV !== "production") && isHmrUpdating && hmrDirtyComponentsMode.has(type)) return hmrDirtyComponentsMode.get(type);
	return type.__vapor;
}

//#endregion
//#region packages/runtime-core/src/components/Suspense.ts
const isSuspense = (type) => type.__isSuspense;

//#endregion
//#region packages/runtime-core/src/vnode.ts
const Fragment$1 = Symbol.for("v-fgt");
const Text$1 = Symbol.for("v-txt");
const Comment$1 = Symbol.for("v-cmt");
const Static$1 = Symbol.for("v-stc");
const VaporSlot = Symbol.for("v-vps");
let currentBlock = null;
let isBlockTreeEnabled = 1;
function isVNode$2(value) {
	return value ? value.__v_isVNode === true : false;
}
let vnodeArgsTransformer;
const createVNodeWithArgsTransform = (...args) => {
	return _createVNode(...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args);
};
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref, ref_key, ref_for }, i = currentRenderingInstance) => {
	if (typeof ref === "number") ref = "" + ref;
	return ref != null ? isString(ref) || /* @__PURE__ */ isRef(ref) || isFunction(ref) ? {
		i,
		r: ref,
		k: ref_key,
		f: !!ref_for
	} : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment$1 ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
	const vnode = {
		__v_isVNode: true,
		__v_skip: true,
		type,
		props,
		key: props && normalizeKey(props),
		ref: props && normalizeRef(props),
		scopeId: currentScopeId,
		slotScopeIds: null,
		children,
		component: null,
		suspense: null,
		ssContent: null,
		ssFallback: null,
		dirs: null,
		transition: null,
		el: null,
		anchor: null,
		target: null,
		targetStart: null,
		targetAnchor: null,
		staticCount: 0,
		shapeFlag,
		patchFlag,
		dynamicProps,
		dynamicChildren: null,
		appContext: null,
		ctx: currentRenderingInstance
	};
	if (needFullChildrenNormalization) {
		normalizeChildren(vnode, children);
		if (shapeFlag & 128) type.normalize(vnode);
	} else if (children) vnode.shapeFlag |= isString(children) ? 8 : 16;
	if (!!(process.env.NODE_ENV !== "production") && vnode.key !== vnode.key) warn$2(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
	if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) currentBlock.push(vnode);
	return vnode;
}
const createVNode$1 = !!(process.env.NODE_ENV !== "production") ? createVNodeWithArgsTransform : _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
	if (!type || type === NULL_DYNAMIC_COMPONENT) {
		if (!!(process.env.NODE_ENV !== "production") && !type) warn$2(`Invalid vnode type when creating vnode: ${type}.`);
		type = Comment$1;
	}
	if (isVNode$2(type)) {
		const cloned = cloneVNode(type, props, true);
		if (children) normalizeChildren(cloned, children);
		if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) if (cloned.shapeFlag & 6) currentBlock[currentBlock.indexOf(type)] = cloned;
		else currentBlock.push(cloned);
		cloned.patchFlag = -2;
		return cloned;
	}
	if (isClassComponent(type)) type = type.__vccOpts;
	if (props) {
		props = guardReactiveProps(props);
		let { class: klass, style } = props;
		if (klass && !isString(klass)) props.class = normalizeClass(klass);
		if (isObject(style)) {
			if (/* @__PURE__ */ isProxy(style) && !isArray(style)) style = extend({}, style);
			props.style = normalizeStyle(style);
		}
	}
	const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
	if (!!(process.env.NODE_ENV !== "production") && shapeFlag & 4 && /* @__PURE__ */ isProxy(type)) {
		type = /* @__PURE__ */ toRaw(type);
		warn$2("Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.", `\nComponent that was made reactive: `, type);
	}
	return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
	if (!props) return null;
	return /* @__PURE__ */ isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
	const { props, ref, patchFlag, children, transition } = vnode;
	const mergedProps = extraProps ? mergeProps$1(props || {}, extraProps) : props;
	const cloned = {
		__v_isVNode: true,
		__v_skip: true,
		type: vnode.type,
		props: mergedProps,
		key: mergedProps && normalizeKey(mergedProps),
		ref: extraProps && extraProps.ref ? mergeRef && ref ? isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref,
		scopeId: vnode.scopeId,
		slotScopeIds: vnode.slotScopeIds,
		children: !!(process.env.NODE_ENV !== "production") && patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,
		target: vnode.target,
		targetStart: vnode.targetStart,
		targetAnchor: vnode.targetAnchor,
		staticCount: vnode.staticCount,
		shapeFlag: vnode.shapeFlag,
		patchFlag: extraProps && vnode.type !== Fragment$1 ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
		dynamicProps: vnode.dynamicProps,
		dynamicChildren: vnode.dynamicChildren,
		appContext: vnode.appContext,
		dirs: vnode.dirs,
		transition,
		component: vnode.component,
		suspense: vnode.suspense,
		ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
		ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
		placeholder: vnode.placeholder,
		el: vnode.el,
		anchor: vnode.anchor,
		ctx: vnode.ctx,
		ce: vnode.ce
	};
	if (transition && cloneTransition) setTransitionHooks(cloned, transition.clone(cloned));
	return cloned;
}
/**
* Dev only, for HMR of hoisted vnodes reused in v-for
* https://github.com/vitejs/vite/issues/2022
*/
function deepCloneVNode(vnode) {
	const cloned = cloneVNode(vnode);
	if (isArray(vnode.children)) cloned.children = vnode.children.map(deepCloneVNode);
	return cloned;
}
/**
* @private
*/
function createTextVNode(text = " ", flag = 0) {
	return createVNode$1(Text$1, null, text, flag);
}
function normalizeChildren(vnode, children) {
	let type = 0;
	const { shapeFlag } = vnode;
	if (children == null) children = null;
	else if (isArray(children)) type = 16;
	else if (typeof children === "object") if (shapeFlag & 65) {
		const slot = children.default;
		if (slot) {
			slot._c && (slot._d = false);
			normalizeChildren(vnode, slot());
			slot._c && (slot._d = true);
		}
		return;
	} else {
		type = 32;
		const slotFlag = children._;
		if (!slotFlag && !isInternalObject(children)) children._ctx = currentRenderingInstance;
		else if (slotFlag === 3 && currentRenderingInstance) if (currentRenderingInstance.slots._ === 1) children._ = 1;
		else {
			children._ = 2;
			vnode.patchFlag |= 1024;
		}
	}
	else if (isFunction(children)) {
		children = {
			default: children,
			_ctx: currentRenderingInstance
		};
		type = 32;
	} else {
		children = String(children);
		if (shapeFlag & 64) {
			type = 16;
			children = [createTextVNode(children)];
		} else type = 8;
	}
	vnode.children = children;
	vnode.shapeFlag |= type;
}
function mergeProps$1(...args) {
	const ret = {};
	for (let i = 0; i < args.length; i++) {
		const toMerge = args[i];
		for (const key in toMerge) if (key === "class") {
			if (ret.class !== toMerge.class) ret.class = normalizeClass([ret.class, toMerge.class]);
		} else if (key === "style") ret.style = normalizeStyle([ret.style, toMerge.style]);
		else if (isOn(key)) {
			const existing = ret[key];
			const incoming = toMerge[key];
			if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) ret[key] = existing ? [].concat(existing, incoming) : incoming;
		} else if (key !== "") ret[key] = toMerge[key];
	}
	return ret;
}

//#endregion
//#region packages/runtime-core/src/component.ts
const attrsProxyHandlers = !!(process.env.NODE_ENV !== "production") ? {
	get(target, key) {
		markAttrsAccessed();
		track(target, "get", "");
		return target[key];
	},
	set() {
		warn$2(`setupContext.attrs is readonly.`);
		return false;
	},
	deleteProperty() {
		warn$2(`setupContext.attrs is readonly.`);
		return false;
	}
} : { get(target, key) {
	track(target, "get", "");
	return target[key];
} };
const classifyRE = /(?:^|[-_])\w/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
	return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
	let name = getComponentName(Component);
	if (!name && Component.__file) {
		const match = Component.__file.match(/([^/\\]+)\.\w+$/);
		if (match) name = match[1];
	}
	if (!name && instance) {
		const inferFromRegistry = (registry) => {
			for (const key in registry) if (registry[key] === Component) return key;
		};
		name = inferFromRegistry(instance.components) || instance.parent && inferFromRegistry(instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
	}
	return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
	return isFunction(value) && "__vccOpts" in value;
}

//#endregion
//#region packages/runtime-core/src/index.ts
const warn$1 = !!(process.env.NODE_ENV !== "production") ? warn$2 : NOOP;
const devtools = (process.env.NODE_ENV, devtools$1);
const setDevtoolsHook = (process.env.NODE_ENV, setDevtoolsHook$1);

//#endregion
//#region packages/server-renderer/src/helpers/ssrRenderList.ts
function ssrRenderList(source, renderItem) {
	if (isArray(source) || isString(source)) for (let i = 0, l = source.length; i < l; i++) renderItem(source[i], i);
	else if (typeof source === "number") {
		if (!!(process.env.NODE_ENV !== "production") && !Number.isInteger(source)) {
			warn$1(`The v-for range expect an integer value but got ${source}.`);
			return;
		}
		for (let i = 0; i < source; i++) renderItem(i + 1, i);
	} else if (isObject(source)) if (source[Symbol.iterator]) {
		const arr = Array.from(source);
		for (let i = 0, l = arr.length; i < l; i++) renderItem(arr[i], i);
	} else {
		const keys = Object.keys(source);
		for (let i = 0, l = keys.length; i < l; i++) {
			const key = keys[i];
			renderItem(source[key], key, i);
		}
	}
}

//#endregion
//#region packages/server-renderer/src/helpers/ssrRenderSuspense.ts
async function ssrRenderSuspense(push, { default: renderContent }) {
	if (renderContent) renderContent();
	else push(`<!---->`);
}

//#endregion
//#region packages/server-renderer/src/helpers/ssrGetDirectiveProps.ts
function ssrGetDirectiveProps(instance, dir, value, arg, modifiers = {}) {
	if (typeof dir !== "function" && dir.getSSRProps) return dir.getSSRProps({
		dir,
		instance: ssrUtils.getComponentPublicInstance(instance.$),
		value,
		oldValue: void 0,
		arg,
		modifiers
	}, null) || {};
	return {};
}

//#endregion
//#region packages/server-renderer/src/helpers/ssrVModelHelpers.ts
const ssrLooseEqual = looseEqual;
function ssrLooseContain(arr, value) {
	return looseIndexOf(arr, value) > -1;
}
function ssrRenderDynamicModel(type, model, value) {
	switch (type) {
		case "radio": return looseEqual(model, value) ? " checked" : "";
		case "checkbox": return (isArray(model) ? ssrLooseContain(model, value) : model) ? " checked" : "";
		default: return ssrRenderAttr("value", model);
	}
}
function ssrGetDynamicModelProps(existingProps = {}, model) {
	const { type, value } = existingProps;
	switch (type) {
		case "radio": return looseEqual(model, value) ? { checked: true } : null;
		case "checkbox": return (isArray(model) ? ssrLooseContain(model, value) : model) ? { checked: true } : null;
		default: return { value: model };
	}
}

//#endregion
//#region packages/server-renderer/src/helpers/ssrCompile.ts
function ssrCompile(template, instance) {
	throw new Error("On-the-fly template compilation is not supported in the ESM build of @vue/server-renderer. All templates must be pre-compiled into render functions.");
}

//#endregion
//#region packages/server-renderer/src/render.ts
const { createComponentInstance, setCurrentRenderingInstance, setupComponent, renderComponentRoot, normalizeVNode, pushWarningContext, popWarningContext } = ssrUtils;
function createBuffer() {
	let appendable = false;
	const buffer = [];
	return {
		getBuffer() {
			return buffer;
		},
		push(item) {
			const isStringItem = isString(item);
			if (appendable && isStringItem) {
				buffer[buffer.length - 1] += item;
				return;
			}
			buffer.push(item);
			appendable = isStringItem;
			if (isPromise(item) || isArray(item) && item.hasAsync) buffer.hasAsync = true;
		}
	};
}
function renderComponentVNode(vnode, parentComponent = null, slotScopeId) {
	const instance = vnode.component = createComponentInstance(vnode, parentComponent, null);
	if (!!(process.env.NODE_ENV !== "production")) pushWarningContext(vnode);
	const res = setupComponent(instance, true);
	if (!!(process.env.NODE_ENV !== "production")) popWarningContext();
	const hasAsyncSetup = isPromise(res);
	let prefetches = instance.sp;
	if (hasAsyncSetup || prefetches) return Promise.resolve(res).then(() => {
		if (hasAsyncSetup) prefetches = instance.sp;
		if (prefetches) return Promise.all(prefetches.map((prefetch) => prefetch.call(instance.proxy)));
	}).catch(NOOP).then(() => renderComponentSubTree(instance, slotScopeId));
	else return renderComponentSubTree(instance, slotScopeId);
}
function renderComponentSubTree(instance, slotScopeId) {
	if (!!(process.env.NODE_ENV !== "production")) pushWarningContext(instance.vnode);
	const comp = instance.type;
	const { getBuffer, push } = createBuffer();
	if (isFunction(comp)) {
		let root = renderComponentRoot(instance);
		if (!comp.props) {
			for (const key in instance.attrs) if (key.startsWith(`data-v-`)) (root.props || (root.props = {}))[key] = ``;
		}
		renderVNode(push, instance.subTree = root, instance, slotScopeId);
	} else {
		if ((!instance.render || instance.render === NOOP) && !instance.ssrRender && !comp.ssrRender && isString(comp.template)) comp.ssrRender = ssrCompile(comp.template, instance);
		const ssrRender = instance.ssrRender || comp.ssrRender;
		if (ssrRender) {
			let attrs = instance.inheritAttrs !== false ? instance.attrs : void 0;
			let hasCloned = false;
			let cur = instance;
			while (true) {
				const scopeId = cur.vnode.scopeId;
				if (scopeId) {
					if (!hasCloned) {
						attrs = { ...attrs };
						hasCloned = true;
					}
					attrs[scopeId] = "";
				}
				const parent = cur.parent;
				if (parent && parent.subTree && parent.subTree === cur.vnode) cur = parent;
				else break;
			}
			if (slotScopeId) {
				if (!hasCloned) attrs = { ...attrs };
				const slotScopeIdList = slotScopeId.trim().split(" ");
				for (let i = 0; i < slotScopeIdList.length; i++) attrs[slotScopeIdList[i]] = "";
			}
			const prev = setCurrentRenderingInstance(instance);
			try {
				ssrRender(instance.proxy, push, instance, attrs, instance.props, instance.setupState, instance.data, instance.ctx);
			} finally {
				setCurrentRenderingInstance(prev);
			}
		} else if (instance.render && instance.render !== NOOP) renderVNode(push, instance.subTree = renderComponentRoot(instance), instance, slotScopeId);
		else {
			warn(`Component ${comp.name || comp.__file || `<Anonymous>`} is missing template or render function.`);
			push(`<!---->`);
		}
	}
	if (!!(process.env.NODE_ENV !== "production")) popWarningContext();
	return getBuffer();
}
function renderVNode(push, vnode, parentComponent, slotScopeId) {
	const { type, shapeFlag, children, dirs, props } = vnode;
	if (dirs) vnode.props = applySSRDirectives(vnode, props, dirs);
	switch (type) {
		case Text:
			push(escapeHtml(children));
			break;
		case Comment:
			push(children ? `<!--${escapeHtmlComment(children)}-->` : `<!---->`);
			break;
		case Static:
			push(children);
			break;
		case Fragment:
			if (vnode.slotScopeIds) slotScopeId = (slotScopeId ? slotScopeId + " " : "") + vnode.slotScopeIds.join(" ");
			push(`<!--[-->`);
			renderVNodeChildren(push, children, parentComponent, slotScopeId);
			push(`<!--]-->`);
			break;
		default: if (shapeFlag & 1) renderElementVNode(push, vnode, parentComponent, slotScopeId);
		else if (shapeFlag & 6) push(renderComponentVNode(vnode, parentComponent, slotScopeId));
		else if (shapeFlag & 64) renderTeleportVNode(push, vnode, parentComponent, slotScopeId);
		else if (shapeFlag & 128) renderVNode(push, vnode.ssContent, parentComponent, slotScopeId);
		else warn("[@vue/server-renderer] Invalid VNode type:", type, `(${typeof type})`);
	}
}
function renderVNodeChildren(push, children, parentComponent, slotScopeId) {
	for (let i = 0; i < children.length; i++) renderVNode(push, normalizeVNode(children[i]), parentComponent, slotScopeId);
}
function renderElementVNode(push, vnode, parentComponent, slotScopeId) {
	const tag = vnode.type;
	let { props, children, shapeFlag, scopeId } = vnode;
	let openTag = `<${tag}`;
	if (props) openTag += ssrRenderAttrs(props, tag);
	if (scopeId) openTag += ` ${scopeId}`;
	let curParent = parentComponent;
	let curVnode = vnode;
	while (curParent && curVnode === curParent.subTree) {
		curVnode = curParent.vnode;
		if (curVnode.scopeId) openTag += ` ${curVnode.scopeId}`;
		curParent = curParent.parent;
	}
	if (slotScopeId) openTag += ` ${slotScopeId}`;
	push(openTag + `>`);
	if (!isVoidTag(tag)) {
		let hasChildrenOverride = false;
		if (props) {
			if (props.innerHTML) {
				hasChildrenOverride = true;
				push(props.innerHTML);
			} else if (props.textContent) {
				hasChildrenOverride = true;
				push(escapeHtml(props.textContent));
			} else if (tag === "textarea" && props.value) {
				hasChildrenOverride = true;
				push(escapeHtml(props.value));
			}
		}
		if (!hasChildrenOverride) {
			if (shapeFlag & 8) push(escapeHtml(children));
			else if (shapeFlag & 16) renderVNodeChildren(push, children, parentComponent, slotScopeId);
		}
		push(`</${tag}>`);
	}
}
function applySSRDirectives(vnode, rawProps, dirs) {
	const toMerge = [];
	for (let i = 0; i < dirs.length; i++) {
		const binding = dirs[i];
		const { dir: { getSSRProps } } = binding;
		if (getSSRProps) {
			const props = getSSRProps(binding, vnode);
			if (props) toMerge.push(props);
		}
	}
	return mergeProps(rawProps || {}, ...toMerge);
}
function renderTeleportVNode(push, vnode, parentComponent, slotScopeId) {
	const target = vnode.props && vnode.props.to;
	const disabled = vnode.props && vnode.props.disabled;
	if (!target) {
		if (!disabled) warn(`[@vue/server-renderer] Teleport is missing target prop.`);
		return [];
	}
	if (!isString(target)) {
		warn(`[@vue/server-renderer] Teleport target must be a query selector string.`);
		return [];
	}
	ssrRenderTeleport(push, (push) => {
		renderVNodeChildren(push, vnode.children, parentComponent, slotScopeId);
	}, target, disabled || disabled === "", parentComponent);
}

//#endregion
//#region packages/server-renderer/src/renderToString.ts
const { isVNode: isVNode$1 } = ssrUtils;
function nestedUnrollBuffer(buffer, parentRet, startIndex) {
	if (!buffer.hasAsync) return parentRet + unrollBufferSync$1(buffer);
	let ret = parentRet;
	for (let i = startIndex; i < buffer.length; i += 1) {
		const item = buffer[i];
		if (isString(item)) {
			ret += item;
			continue;
		}
		if (isPromise(item)) return item.then((nestedItem) => {
			buffer[i] = nestedItem;
			return nestedUnrollBuffer(buffer, ret, i);
		});
		const result = nestedUnrollBuffer(item, ret, 0);
		if (isPromise(result)) return result.then((nestedItem) => {
			buffer[i] = nestedItem;
			return nestedUnrollBuffer(buffer, "", i);
		});
		ret = result;
	}
	return ret;
}
function unrollBuffer$1(buffer) {
	return nestedUnrollBuffer(buffer, "", 0);
}
function unrollBufferSync$1(buffer) {
	let ret = "";
	for (let i = 0; i < buffer.length; i++) {
		let item = buffer[i];
		if (isString(item)) ret += item;
		else ret += unrollBufferSync$1(item);
	}
	return ret;
}
async function renderToString(input, context = {}) {
	if (isVNode$1(input)) return renderToString(createApp({ render: () => input }), context);
	const vnode = createVNode(input._component, input._props);
	vnode.appContext = input._context;
	input.provide(ssrContextKey, context);
	const result = await unrollBuffer$1(await renderComponentVNode(vnode));
	await resolveTeleports(context);
	if (context.__watcherHandles) for (const unwatch of context.__watcherHandles) unwatch();
	return result;
}
async function resolveTeleports(context) {
	if (context.__teleportBuffers) {
		context.teleports = context.teleports || {};
		for (const key in context.__teleportBuffers) context.teleports[key] = await unrollBuffer$1(await Promise.all([context.__teleportBuffers[key]]));
	}
}

//#endregion
//#region packages/server-renderer/src/renderToStream.ts
const { isVNode } = ssrUtils;
async function unrollBuffer(buffer, stream) {
	if (buffer.hasAsync) for (let i = 0; i < buffer.length; i++) {
		let item = buffer[i];
		if (isPromise(item)) item = await item;
		if (isString(item)) stream.push(item);
		else await unrollBuffer(item, stream);
	}
	else unrollBufferSync(buffer, stream);
}
function unrollBufferSync(buffer, stream) {
	for (let i = 0; i < buffer.length; i++) {
		let item = buffer[i];
		if (isString(item)) stream.push(item);
		else unrollBufferSync(item, stream);
	}
}
function renderToSimpleStream(input, context, stream) {
	if (isVNode(input)) return renderToSimpleStream(createApp({ render: () => input }), context, stream);
	const vnode = createVNode(input._component, input._props);
	vnode.appContext = input._context;
	input.provide(ssrContextKey, context);
	Promise.resolve(renderComponentVNode(vnode)).then((buffer) => unrollBuffer(buffer, stream)).then(() => resolveTeleports(context)).then(() => {
		if (context.__watcherHandles) for (const unwatch of context.__watcherHandles) unwatch();
	}).then(() => stream.push(null)).catch((error) => {
		stream.destroy(error);
	});
	return stream;
}
/**
* @deprecated
*/
function renderToStream(input, context = {}) {
	console.warn(`[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead.`);
	return renderToNodeStream(input, context);
}
function renderToNodeStream(input, context = {}) {
	throw new Error("ESM build of renderToStream() does not support renderToNodeStream(). Use pipeToNodeWritable() with an existing Node.js Writable stream instance instead.");
}
function pipeToNodeWritable(input, context = {}, writable) {
	renderToSimpleStream(input, context, {
		push(content) {
			if (content != null) writable.write(content);
			else writable.end();
		},
		destroy(err) {
			writable.destroy(err);
		}
	});
}
function renderToWebStream(input, context = {}) {
	if (typeof ReadableStream !== "function") throw new Error("ReadableStream constructor is not available in the global scope. If the target environment does support web streams, consider using pipeToWebWritable() with an existing WritableStream instance instead.");
	const encoder = new TextEncoder();
	let cancelled = false;
	return new ReadableStream({
		start(controller) {
			renderToSimpleStream(input, context, {
				push(content) {
					if (cancelled) return;
					if (content != null) controller.enqueue(encoder.encode(content));
					else controller.close();
				},
				destroy(err) {
					controller.error(err);
				}
			});
		},
		cancel() {
			cancelled = true;
		}
	});
}
function pipeToWebWritable(input, context = {}, writable) {
	const writer = writable.getWriter();
	const encoder = new TextEncoder();
	let hasReady = false;
	try {
		hasReady = isPromise(writer.ready);
	} catch (e) {}
	renderToSimpleStream(input, context, {
		async push(content) {
			if (hasReady) await writer.ready;
			if (content != null) return writer.write(encoder.encode(content));
			else return writer.close();
		},
		destroy(err) {
			console.log(err);
			writer.close();
		}
	});
}

//#endregion
//#region packages/server-renderer/src/index.ts
initDirectivesForSSR();

//#endregion
export { pipeToNodeWritable, pipeToWebWritable, renderToNodeStream, renderToSimpleStream, renderToStream, renderToString, renderToWebStream, ssrGetDirectiveProps, ssrGetDynamicModelProps, ssrIncludeBooleanAttr, ssrInterpolate, ssrLooseContain, ssrLooseEqual, ssrRenderAttr, ssrRenderAttrs, ssrRenderClass, ssrRenderComponent, ssrRenderDynamicAttr, ssrRenderDynamicModel, ssrRenderList, ssrRenderSlot, ssrRenderSlotInner, ssrRenderStyle, ssrRenderSuspense, ssrRenderTeleport, renderVNode as ssrRenderVNode };