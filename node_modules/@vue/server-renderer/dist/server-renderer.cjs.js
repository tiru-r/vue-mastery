/**
  * @vue/server-renderer v3.6.0-beta.5
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: 'Module' } });
//#region \0rolldown/runtime.js
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __exportAll = (all, no_symbols) => {
	let target = {};
	for (var name in all) {
		__defProp(target, name, {
			get: all[name],
			enumerable: true
		});
	}
	if (!no_symbols) {
		__defProp(target, Symbol.toStringTag, { value: "Module" });
	}
	return target;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
			key = keys[i];
			if (!__hasOwnProp.call(to, key) && key !== except) {
				__defProp(to, key, {
					get: ((k) => from[k]).bind(null, key),
					enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
				});
			}
		}
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let vue = require("vue");
vue = __toESM(vue);
let _vue_shared = require("@vue/shared");
let _vue_compiler_ssr = require("@vue/compiler-ssr");

//#region packages/server-renderer/src/helpers/ssrRenderAttrs.ts
const shouldIgnoreProp = /* @__PURE__ */ (0, _vue_shared.makeMap)(`,key,ref,innerHTML,textContent,ref_key,ref_for`);
function ssrRenderAttrs(props, tag) {
	let ret = "";
	for (let key in props) {
		if (shouldIgnoreProp(key) || (0, _vue_shared.isOn)(key) || tag === "textarea" && key === "value" || key.startsWith(".")) continue;
		const value = props[key];
		if (key.startsWith("^")) key = key.slice(1);
		if (key === "class" || key === "className") ret += ` class="${ssrRenderClass(value)}"`;
		else if (key === "style") ret += ` style="${ssrRenderStyle(value)}"`;
		else ret += ssrRenderDynamicAttr(key, value, tag);
	}
	return ret;
}
function ssrRenderDynamicAttr(key, value, tag) {
	if (!(0, _vue_shared.isRenderableAttrValue)(value)) return ``;
	const attrKey = tag && (tag.indexOf("-") > 0 || (0, _vue_shared.isSVGTag)(tag)) ? key : _vue_shared.propsToAttrMap[key] || key.toLowerCase();
	if ((0, _vue_shared.isBooleanAttr)(attrKey)) return (0, _vue_shared.includeBooleanAttr)(value) ? ` ${attrKey}` : ``;
	else if ((0, _vue_shared.isSSRSafeAttrName)(attrKey)) return value === "" ? ` ${attrKey}` : ` ${attrKey}="${(0, _vue_shared.escapeHtml)(value)}"`;
	else {
		console.warn(`[@vue/server-renderer] Skipped rendering unsafe attribute name: ${attrKey}`);
		return ``;
	}
}
function ssrRenderAttr(key, value) {
	if (!(0, _vue_shared.isRenderableAttrValue)(value)) return ``;
	return ` ${key}="${(0, _vue_shared.escapeHtml)(value)}"`;
}
function ssrRenderClass(raw) {
	return (0, _vue_shared.escapeHtml)((0, _vue_shared.normalizeClass)(raw));
}
function ssrRenderStyle(raw) {
	if (!raw) return "";
	if ((0, _vue_shared.isString)(raw)) return (0, _vue_shared.escapeHtml)(raw);
	return (0, _vue_shared.escapeHtml)((0, _vue_shared.stringifyStyle)((0, _vue_shared.normalizeStyle)(ssrResetCssVars(raw))));
}
function ssrResetCssVars(raw) {
	if (!(0, _vue_shared.isArray)(raw) && (0, _vue_shared.isObject)(raw)) {
		const res = {};
		for (const key in raw) if (key.startsWith(":--")) res[key.slice(1)] = (0, _vue_shared.normalizeCssVarValue)(raw[key]);
		else res[key] = raw[key];
		return res;
	}
	return raw;
}

//#endregion
//#region packages/server-renderer/src/helpers/ssrRenderComponent.ts
function ssrRenderComponent(comp, props = null, children = null, parentComponent = null, slotScopeId) {
	return renderComponentVNode((0, vue.createVNode)(comp, props, children), parentComponent, slotScopeId);
}

//#endregion
//#region packages/server-renderer/src/helpers/ssrRenderSlot.ts
const { ensureValidVNode } = vue.ssrUtils;
function ssrRenderSlot(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId) {
	push(`<!--[-->`);
	ssrRenderSlotInner(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId);
	push(`<!--]-->`);
}
function ssrRenderSlotInner(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId, transition) {
	const slotFn = slots[slotName];
	if (slotFn) {
		const slotBuffer = [];
		const bufferedPush = (item) => {
			slotBuffer.push(item);
		};
		const ret = slotFn(slotProps, bufferedPush, parentComponent, slotScopeId ? " " + slotScopeId : "");
		if ((0, _vue_shared.isArray)(ret)) {
			const validSlotContent = ensureValidVNode(ret);
			if (validSlotContent) renderVNodeChildren(push, validSlotContent, parentComponent, slotScopeId);
			else if (fallbackRenderFn) fallbackRenderFn();
			else if (transition) push(`<!---->`);
		} else {
			let isEmptySlot = true;
			if (transition) isEmptySlot = false;
			else for (let i = 0; i < slotBuffer.length; i++) if (!isComment(slotBuffer[i])) {
				isEmptySlot = false;
				break;
			}
			if (isEmptySlot) {
				if (fallbackRenderFn) fallbackRenderFn();
			} else {
				let start = 0;
				let end = slotBuffer.length;
				if (transition && slotBuffer[0] === "<!--[-->" && slotBuffer[end - 1] === "<!--]-->") {
					start++;
					end--;
				}
				if (start < end) for (let i = start; i < end; i++) push(slotBuffer[i]);
				else if (transition) push(`<!---->`);
			}
		}
	} else if (fallbackRenderFn) fallbackRenderFn();
	else if (transition) push(`<!---->`);
}
const commentTestRE = /^<!--[\s\S]*-->$/;
const commentRE = /<!--[^]*?-->/gm;
function isComment(item) {
	if (typeof item !== "string" || !commentTestRE.test(item)) return false;
	if (item.length <= 8) return true;
	return !item.replace(commentRE, "").trim();
}

//#endregion
//#region packages/server-renderer/src/helpers/ssrRenderTeleport.ts
function ssrRenderTeleport(parentPush, contentRenderFn, target, disabled, parentComponent) {
	parentPush("<!--teleport start-->");
	const context = parentComponent.appContext.provides[vue.ssrContextKey];
	const teleportBuffers = context.__teleportBuffers || (context.__teleportBuffers = {});
	const targetBuffer = teleportBuffers[target] || (teleportBuffers[target] = []);
	const bufferIndex = targetBuffer.length;
	let teleportContent;
	if (disabled) {
		contentRenderFn(parentPush);
		teleportContent = `<!--teleport start anchor--><!--teleport anchor-->`;
	} else {
		const { getBuffer, push } = createBuffer();
		push(`<!--teleport start anchor-->`);
		contentRenderFn(push);
		push(`<!--teleport anchor-->`);
		teleportContent = getBuffer();
	}
	targetBuffer.splice(bufferIndex, 0, teleportContent);
	parentPush("<!--teleport end-->");
}

//#endregion
//#region packages/server-renderer/src/helpers/ssrInterpolate.ts
function ssrInterpolate(value) {
	return (0, _vue_shared.escapeHtml)((0, _vue_shared.toDisplayString)(value));
}

//#endregion
//#region packages/reactivity/src/system.ts
let activeSub = void 0;
function setActiveSub(sub) {
	try {
		return activeSub;
	} finally {
		activeSub = sub;
	}
}

//#endregion
//#region packages/reactivity/src/reactive.ts
/**
* Returns the raw, original object of a Vue-created proxy.
*
* `toRaw()` can return the original object from proxies created by
* {@link reactive}, {@link readonly}, {@link shallowReactive} or
* {@link shallowReadonly}.
*
* This is an escape hatch that can be used to temporarily read without
* incurring proxy access / tracking overhead or write without triggering
* changes. It is **not** recommended to hold a persistent reference to the
* original object. Use with caution.
*
* @example
* ```js
* const foo = {}
* const reactiveFoo = reactive(foo)
*
* console.log(toRaw(reactiveFoo) === foo) // true
* ```
*
* @param observed - The object for which the "raw" value is requested.
* @see {@link https://vuejs.org/api/reactivity-advanced.html#toraw}
*/
/* @__NO_SIDE_EFFECTS__ */
function toRaw(observed) {
	const raw = observed && observed["__v_raw"];
	return raw ? /* @__PURE__ */ toRaw(raw) : observed;
}

//#endregion
//#region packages/reactivity/src/ref.ts
/* @__NO_SIDE_EFFECTS__ */
function isRef(r) {
	return r ? r["__v_isRef"] === true : false;
}

//#endregion
//#region packages/runtime-core/src/warning.ts
const stack = [];
/**
* @internal
*/
function pushWarningContext$1(ctx) {
	stack.push(ctx);
}
/**
* @internal
*/
function popWarningContext$1() {
	stack.pop();
}
let isWarning = false;
function warn$3(msg, ...args) {
	if (isWarning) return;
	isWarning = true;
	const prevSub = setActiveSub();
	const entry = stack.length ? stack[stack.length - 1] : null;
	const instance = isVNode$2(entry) ? entry.component : entry;
	const appWarnHandler = instance && instance.appContext.config.warnHandler;
	const trace = getComponentTrace();
	if (appWarnHandler) callWithErrorHandling(appWarnHandler, instance, 11, [
		msg + args.map((a) => {
			var _a$toString, _a$toString2;
			return (_a$toString = (_a$toString2 = a.toString) === null || _a$toString2 === void 0 ? void 0 : _a$toString2.call(a)) !== null && _a$toString !== void 0 ? _a$toString : JSON.stringify(a);
		}).join(""),
		instance && instance.proxy || instance,
		trace.map(({ ctx }) => `at <${formatComponentName(instance, ctx.type)}>`).join("\n"),
		trace
	]);
	else {
		const warnArgs = [`[Vue warn]: ${msg}`, ...args];
		if (trace.length && true)
 /* v8 ignore next 2 */
		warnArgs.push(`\n`, ...formatTrace(trace));
		console.warn(...warnArgs);
	}
	setActiveSub(prevSub);
	isWarning = false;
}
function getComponentTrace() {
	let currentCtx = stack[stack.length - 1];
	if (!currentCtx) return [];
	const normalizedStack = [];
	while (currentCtx) {
		const last = normalizedStack[0];
		if (last && last.ctx === currentCtx) last.recurseCount++;
		else normalizedStack.push({
			ctx: currentCtx,
			recurseCount: 0
		});
		if (isVNode$2(currentCtx)) {
			const parent = currentCtx.component && currentCtx.component.parent;
			currentCtx = parent && parent.vnode || parent;
		} else currentCtx = currentCtx.parent;
	}
	return normalizedStack;
}
/* v8 ignore start */
function formatTrace(trace) {
	const logs = [];
	trace.forEach((entry, i) => {
		logs.push(...i === 0 ? [] : [`\n`], ...formatTraceEntry(entry));
	});
	return logs;
}
function formatTraceEntry({ ctx, recurseCount }) {
	const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
	const instance = isVNode$2(ctx) ? ctx.component : ctx;
	const isRoot = instance ? instance.parent == null : false;
	const open = ` at <${formatComponentName(instance, ctx.type, isRoot)}`;
	const close = `>` + postfix;
	return ctx.props ? [
		open,
		...formatProps(ctx.props),
		close
	] : [open + close];
}
function formatProps(props) {
	const res = [];
	const keys = Object.keys(props);
	keys.slice(0, 3).forEach((key) => {
		res.push(...formatProp(key, props[key]));
	});
	if (keys.length > 3) res.push(` ...`);
	return res;
}
function formatProp(key, value, raw) {
	if ((0, _vue_shared.isString)(value)) {
		value = JSON.stringify(value);
		return raw ? value : [`${key}=${value}`];
	} else if (typeof value === "number" || typeof value === "boolean" || value == null) return raw ? value : [`${key}=${value}`];
	else if (/* @__PURE__ */ isRef(value)) {
		value = formatProp(key, /* @__PURE__ */ toRaw(value.value), true);
		return raw ? value : [
			`${key}=Ref<`,
			value,
			`>`
		];
	} else if ((0, _vue_shared.isFunction)(value)) return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
	else {
		value = /* @__PURE__ */ toRaw(value);
		return raw ? value : [`${key}=`, value];
	}
}
/* v8 ignore stop */

//#endregion
//#region packages/runtime-core/src/errorHandling.ts
const ErrorTypeStrings = {
	["sp"]: "serverPrefetch hook",
	["bc"]: "beforeCreate hook",
	["c"]: "created hook",
	["bm"]: "beforeMount hook",
	["m"]: "mounted hook",
	["bu"]: "beforeUpdate hook",
	["u"]: "updated",
	["bum"]: "beforeUnmount hook",
	["um"]: "unmounted hook",
	["a"]: "activated hook",
	["da"]: "deactivated hook",
	["ec"]: "errorCaptured hook",
	["rtc"]: "renderTracked hook",
	["rtg"]: "renderTriggered hook",
	[0]: "setup function",
	[1]: "render function",
	[2]: "watcher getter",
	[3]: "watcher callback",
	[4]: "watcher cleanup function",
	[5]: "native event handler",
	[6]: "component event handler",
	[7]: "vnode hook",
	[8]: "directive hook",
	[9]: "transition hook",
	[10]: "app errorHandler",
	[11]: "app warnHandler",
	[12]: "ref function",
	[13]: "async component loader",
	[14]: "scheduler flush",
	[15]: "component update",
	[16]: "app unmount cleanup function"
};
function callWithErrorHandling(fn, instance, type, args) {
	try {
		return args ? fn(...args) : fn();
	} catch (err) {
		handleError(err, instance, type);
	}
}
function handleError(err, instance, type, throwInDev = true) {
	const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || _vue_shared.EMPTY_OBJ;
	if (instance) {
		let cur = instance.parent;
		const exposedInstance = instance.proxy || instance;
		const errorInfo = ErrorTypeStrings[type];
		while (cur) {
			const errorCapturedHooks = cur.ec;
			if (errorCapturedHooks) {
				for (let i = 0; i < errorCapturedHooks.length; i++) if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) return;
			}
			cur = cur.parent;
		}
		if (errorHandler) {
			const prevSub = setActiveSub();
			callWithErrorHandling(errorHandler, null, 10, [
				err,
				exposedInstance,
				errorInfo
			]);
			setActiveSub(prevSub);
			return;
		}
	}
	logError(err, type, instance, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, instance, throwInDev = true, throwInProd = false) {
	{
		const info = ErrorTypeStrings[type];
		if (instance) pushWarningContext$1(instance);
		warn$3(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
		if (instance) popWarningContext$1();
		if (throwInDev) throw err;
		else console.error(err);
	}
}

//#endregion
//#region packages/runtime-core/src/vnode.ts
const Fragment$1 = Symbol.for("v-fgt");
const Text$1 = Symbol.for("v-txt");
const Comment$1 = Symbol.for("v-cmt");
const Static$1 = Symbol.for("v-stc");
const VaporSlot = Symbol.for("v-vps");
function isVNode$2(value) {
	return value ? value.__v_isVNode === true : false;
}

//#endregion
//#region packages/runtime-core/src/component.ts
const classifyRE = /(?:^|[-_])\w/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
	return (0, _vue_shared.isFunction)(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
	let name = getComponentName(Component);
	if (!name && Component.__file) {
		const match = Component.__file.match(/([^/\\]+)\.\w+$/);
		if (match) name = match[1];
	}
	if (!name && instance) {
		const inferFromRegistry = (registry) => {
			for (const key in registry) if (registry[key] === Component) return key;
		};
		name = inferFromRegistry(instance.components) || instance.parent && inferFromRegistry(instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
	}
	return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}

//#endregion
//#region packages/runtime-core/src/index.ts
const warn$2 = warn$3;

//#endregion
//#region packages/server-renderer/src/helpers/ssrRenderList.ts
function ssrRenderList(source, renderItem) {
	if ((0, _vue_shared.isArray)(source) || (0, _vue_shared.isString)(source)) for (let i = 0, l = source.length; i < l; i++) renderItem(source[i], i);
	else if (typeof source === "number") {
		if (!Number.isInteger(source)) {
			warn$2(`The v-for range expect an integer value but got ${source}.`);
			return;
		}
		for (let i = 0; i < source; i++) renderItem(i + 1, i);
	} else if ((0, _vue_shared.isObject)(source)) if (source[Symbol.iterator]) {
		const arr = Array.from(source);
		for (let i = 0, l = arr.length; i < l; i++) renderItem(arr[i], i);
	} else {
		const keys = Object.keys(source);
		for (let i = 0, l = keys.length; i < l; i++) {
			const key = keys[i];
			renderItem(source[key], key, i);
		}
	}
}

//#endregion
//#region packages/server-renderer/src/helpers/ssrRenderSuspense.ts
async function ssrRenderSuspense(push, { default: renderContent }) {
	if (renderContent) renderContent();
	else push(`<!---->`);
}

//#endregion
//#region packages/server-renderer/src/helpers/ssrGetDirectiveProps.ts
function ssrGetDirectiveProps(instance, dir, value, arg, modifiers = {}) {
	if (typeof dir !== "function" && dir.getSSRProps) return dir.getSSRProps({
		dir,
		instance: vue.ssrUtils.getComponentPublicInstance(instance.$),
		value,
		oldValue: void 0,
		arg,
		modifiers
	}, null) || {};
	return {};
}

//#endregion
//#region packages/server-renderer/src/helpers/ssrVModelHelpers.ts
const ssrLooseEqual = _vue_shared.looseEqual;
function ssrLooseContain(arr, value) {
	return (0, _vue_shared.looseIndexOf)(arr, value) > -1;
}
function ssrRenderDynamicModel(type, model, value) {
	switch (type) {
		case "radio": return (0, _vue_shared.looseEqual)(model, value) ? " checked" : "";
		case "checkbox": return ((0, _vue_shared.isArray)(model) ? ssrLooseContain(model, value) : model) ? " checked" : "";
		default: return ssrRenderAttr("value", model);
	}
}
function ssrGetDynamicModelProps(existingProps = {}, model) {
	const { type, value } = existingProps;
	switch (type) {
		case "radio": return (0, _vue_shared.looseEqual)(model, value) ? { checked: true } : null;
		case "checkbox": return ((0, _vue_shared.isArray)(model) ? ssrLooseContain(model, value) : model) ? { checked: true } : null;
		default: return { value: model };
	}
}

//#endregion
//#region packages/server-renderer/src/internal.ts
var internal_exports = /* @__PURE__ */ __exportAll({
	ssrGetDirectiveProps: () => ssrGetDirectiveProps,
	ssrGetDynamicModelProps: () => ssrGetDynamicModelProps,
	ssrIncludeBooleanAttr: () => _vue_shared.includeBooleanAttr,
	ssrInterpolate: () => ssrInterpolate,
	ssrLooseContain: () => ssrLooseContain,
	ssrLooseEqual: () => ssrLooseEqual,
	ssrRenderAttr: () => ssrRenderAttr,
	ssrRenderAttrs: () => ssrRenderAttrs,
	ssrRenderClass: () => ssrRenderClass,
	ssrRenderComponent: () => ssrRenderComponent,
	ssrRenderDynamicAttr: () => ssrRenderDynamicAttr,
	ssrRenderDynamicModel: () => ssrRenderDynamicModel,
	ssrRenderList: () => ssrRenderList,
	ssrRenderSlot: () => ssrRenderSlot,
	ssrRenderSlotInner: () => ssrRenderSlotInner,
	ssrRenderStyle: () => ssrRenderStyle,
	ssrRenderSuspense: () => ssrRenderSuspense,
	ssrRenderTeleport: () => ssrRenderTeleport,
	ssrRenderVNode: () => renderVNode
});

//#endregion
//#region packages/server-renderer/src/helpers/ssrCompile.ts
const compileCache = Object.create(null);
function ssrCompile(template, instance) {
	const Component = instance.type;
	const { isCustomElement, compilerOptions } = instance.appContext.config;
	const { delimiters, compilerOptions: componentCompilerOptions } = Component;
	const finalCompilerOptions = (0, _vue_shared.extend)((0, _vue_shared.extend)({
		isCustomElement,
		delimiters
	}, compilerOptions), componentCompilerOptions);
	finalCompilerOptions.isCustomElement = finalCompilerOptions.isCustomElement || _vue_shared.NO;
	finalCompilerOptions.isNativeTag = finalCompilerOptions.isNativeTag || _vue_shared.NO;
	const cacheKey = JSON.stringify({
		template,
		compilerOptions: finalCompilerOptions
	}, (key, value) => {
		return (0, _vue_shared.isFunction)(value) ? value.toString() : value;
	});
	const cached = compileCache[cacheKey];
	if (cached) return cached;
	finalCompilerOptions.onError = (err) => {
		{
			const message = `[@vue/server-renderer] Template compilation error: ${err.message}`;
			const codeFrame = err.loc && (0, _vue_shared.generateCodeFrame)(template, err.loc.start.offset, err.loc.end.offset);
			(0, vue.warn)(codeFrame ? `${message}\n${codeFrame}` : message);
		}
	};
	const { code } = (0, _vue_compiler_ssr.compile)(template, finalCompilerOptions);
	const requireMap = {
		vue,
		"vue/server-renderer": internal_exports
	};
	const fakeRequire = (id) => requireMap[id];
	return compileCache[cacheKey] = Function("require", code)(fakeRequire);
}

//#endregion
//#region packages/server-renderer/src/render.ts
const { createComponentInstance, setCurrentRenderingInstance, setupComponent, renderComponentRoot, normalizeVNode, pushWarningContext, popWarningContext } = vue.ssrUtils;
function createBuffer() {
	let appendable = false;
	const buffer = [];
	return {
		getBuffer() {
			return buffer;
		},
		push(item) {
			const isStringItem = (0, _vue_shared.isString)(item);
			if (appendable && isStringItem) {
				buffer[buffer.length - 1] += item;
				return;
			}
			buffer.push(item);
			appendable = isStringItem;
			if ((0, _vue_shared.isPromise)(item) || (0, _vue_shared.isArray)(item) && item.hasAsync) buffer.hasAsync = true;
		}
	};
}
function renderComponentVNode(vnode, parentComponent = null, slotScopeId) {
	const instance = vnode.component = createComponentInstance(vnode, parentComponent, null);
	pushWarningContext(vnode);
	const res = setupComponent(instance, true);
	popWarningContext();
	const hasAsyncSetup = (0, _vue_shared.isPromise)(res);
	let prefetches = instance.sp;
	if (hasAsyncSetup || prefetches) return Promise.resolve(res).then(() => {
		if (hasAsyncSetup) prefetches = instance.sp;
		if (prefetches) return Promise.all(prefetches.map((prefetch) => prefetch.call(instance.proxy)));
	}).catch(_vue_shared.NOOP).then(() => renderComponentSubTree(instance, slotScopeId));
	else return renderComponentSubTree(instance, slotScopeId);
}
function renderComponentSubTree(instance, slotScopeId) {
	pushWarningContext(instance.vnode);
	const comp = instance.type;
	const { getBuffer, push } = createBuffer();
	if ((0, _vue_shared.isFunction)(comp)) {
		let root = renderComponentRoot(instance);
		if (!comp.props) {
			for (const key in instance.attrs) if (key.startsWith(`data-v-`)) (root.props || (root.props = {}))[key] = ``;
		}
		renderVNode(push, instance.subTree = root, instance, slotScopeId);
	} else {
		if ((!instance.render || instance.render === _vue_shared.NOOP) && !instance.ssrRender && !comp.ssrRender && (0, _vue_shared.isString)(comp.template)) comp.ssrRender = ssrCompile(comp.template, instance);
		const ssrRender = instance.ssrRender || comp.ssrRender;
		if (ssrRender) {
			let attrs = instance.inheritAttrs !== false ? instance.attrs : void 0;
			let hasCloned = false;
			let cur = instance;
			while (true) {
				const scopeId = cur.vnode.scopeId;
				if (scopeId) {
					if (!hasCloned) {
						attrs = { ...attrs };
						hasCloned = true;
					}
					attrs[scopeId] = "";
				}
				const parent = cur.parent;
				if (parent && parent.subTree && parent.subTree === cur.vnode) cur = parent;
				else break;
			}
			if (slotScopeId) {
				if (!hasCloned) attrs = { ...attrs };
				const slotScopeIdList = slotScopeId.trim().split(" ");
				for (let i = 0; i < slotScopeIdList.length; i++) attrs[slotScopeIdList[i]] = "";
			}
			const prev = setCurrentRenderingInstance(instance);
			try {
				ssrRender(instance.proxy, push, instance, attrs, instance.props, instance.setupState, instance.data, instance.ctx);
			} finally {
				setCurrentRenderingInstance(prev);
			}
		} else if (instance.render && instance.render !== _vue_shared.NOOP) renderVNode(push, instance.subTree = renderComponentRoot(instance), instance, slotScopeId);
		else {
			(0, vue.warn)(`Component ${comp.name || comp.__file || `<Anonymous>`} is missing template or render function.`);
			push(`<!---->`);
		}
	}
	popWarningContext();
	return getBuffer();
}
function renderVNode(push, vnode, parentComponent, slotScopeId) {
	const { type, shapeFlag, children, dirs, props } = vnode;
	if (dirs) vnode.props = applySSRDirectives(vnode, props, dirs);
	switch (type) {
		case vue.Text:
			push((0, _vue_shared.escapeHtml)(children));
			break;
		case vue.Comment:
			push(children ? `<!--${(0, _vue_shared.escapeHtmlComment)(children)}-->` : `<!---->`);
			break;
		case vue.Static:
			push(children);
			break;
		case vue.Fragment:
			if (vnode.slotScopeIds) slotScopeId = (slotScopeId ? slotScopeId + " " : "") + vnode.slotScopeIds.join(" ");
			push(`<!--[-->`);
			renderVNodeChildren(push, children, parentComponent, slotScopeId);
			push(`<!--]-->`);
			break;
		default: if (shapeFlag & 1) renderElementVNode(push, vnode, parentComponent, slotScopeId);
		else if (shapeFlag & 6) push(renderComponentVNode(vnode, parentComponent, slotScopeId));
		else if (shapeFlag & 64) renderTeleportVNode(push, vnode, parentComponent, slotScopeId);
		else if (shapeFlag & 128) renderVNode(push, vnode.ssContent, parentComponent, slotScopeId);
		else (0, vue.warn)("[@vue/server-renderer] Invalid VNode type:", type, `(${typeof type})`);
	}
}
function renderVNodeChildren(push, children, parentComponent, slotScopeId) {
	for (let i = 0; i < children.length; i++) renderVNode(push, normalizeVNode(children[i]), parentComponent, slotScopeId);
}
function renderElementVNode(push, vnode, parentComponent, slotScopeId) {
	const tag = vnode.type;
	let { props, children, shapeFlag, scopeId } = vnode;
	let openTag = `<${tag}`;
	if (props) openTag += ssrRenderAttrs(props, tag);
	if (scopeId) openTag += ` ${scopeId}`;
	let curParent = parentComponent;
	let curVnode = vnode;
	while (curParent && curVnode === curParent.subTree) {
		curVnode = curParent.vnode;
		if (curVnode.scopeId) openTag += ` ${curVnode.scopeId}`;
		curParent = curParent.parent;
	}
	if (slotScopeId) openTag += ` ${slotScopeId}`;
	push(openTag + `>`);
	if (!(0, _vue_shared.isVoidTag)(tag)) {
		let hasChildrenOverride = false;
		if (props) {
			if (props.innerHTML) {
				hasChildrenOverride = true;
				push(props.innerHTML);
			} else if (props.textContent) {
				hasChildrenOverride = true;
				push((0, _vue_shared.escapeHtml)(props.textContent));
			} else if (tag === "textarea" && props.value) {
				hasChildrenOverride = true;
				push((0, _vue_shared.escapeHtml)(props.value));
			}
		}
		if (!hasChildrenOverride) {
			if (shapeFlag & 8) push((0, _vue_shared.escapeHtml)(children));
			else if (shapeFlag & 16) renderVNodeChildren(push, children, parentComponent, slotScopeId);
		}
		push(`</${tag}>`);
	}
}
function applySSRDirectives(vnode, rawProps, dirs) {
	const toMerge = [];
	for (let i = 0; i < dirs.length; i++) {
		const binding = dirs[i];
		const { dir: { getSSRProps } } = binding;
		if (getSSRProps) {
			const props = getSSRProps(binding, vnode);
			if (props) toMerge.push(props);
		}
	}
	return (0, vue.mergeProps)(rawProps || {}, ...toMerge);
}
function renderTeleportVNode(push, vnode, parentComponent, slotScopeId) {
	const target = vnode.props && vnode.props.to;
	const disabled = vnode.props && vnode.props.disabled;
	if (!target) {
		if (!disabled) (0, vue.warn)(`[@vue/server-renderer] Teleport is missing target prop.`);
		return [];
	}
	if (!(0, _vue_shared.isString)(target)) {
		(0, vue.warn)(`[@vue/server-renderer] Teleport target must be a query selector string.`);
		return [];
	}
	ssrRenderTeleport(push, (push) => {
		renderVNodeChildren(push, vnode.children, parentComponent, slotScopeId);
	}, target, disabled || disabled === "", parentComponent);
}

//#endregion
//#region packages/server-renderer/src/renderToString.ts
const { isVNode: isVNode$1 } = vue.ssrUtils;
function nestedUnrollBuffer(buffer, parentRet, startIndex) {
	if (!buffer.hasAsync) return parentRet + unrollBufferSync$1(buffer);
	let ret = parentRet;
	for (let i = startIndex; i < buffer.length; i += 1) {
		const item = buffer[i];
		if ((0, _vue_shared.isString)(item)) {
			ret += item;
			continue;
		}
		if ((0, _vue_shared.isPromise)(item)) return item.then((nestedItem) => {
			buffer[i] = nestedItem;
			return nestedUnrollBuffer(buffer, ret, i);
		});
		const result = nestedUnrollBuffer(item, ret, 0);
		if ((0, _vue_shared.isPromise)(result)) return result.then((nestedItem) => {
			buffer[i] = nestedItem;
			return nestedUnrollBuffer(buffer, "", i);
		});
		ret = result;
	}
	return ret;
}
function unrollBuffer$1(buffer) {
	return nestedUnrollBuffer(buffer, "", 0);
}
function unrollBufferSync$1(buffer) {
	let ret = "";
	for (let i = 0; i < buffer.length; i++) {
		let item = buffer[i];
		if ((0, _vue_shared.isString)(item)) ret += item;
		else ret += unrollBufferSync$1(item);
	}
	return ret;
}
async function renderToString(input, context = {}) {
	if (isVNode$1(input)) return renderToString((0, vue.createApp)({ render: () => input }), context);
	const vnode = (0, vue.createVNode)(input._component, input._props);
	vnode.appContext = input._context;
	input.provide(vue.ssrContextKey, context);
	const result = await unrollBuffer$1(await renderComponentVNode(vnode));
	await resolveTeleports(context);
	if (context.__watcherHandles) for (const unwatch of context.__watcherHandles) unwatch();
	return result;
}
async function resolveTeleports(context) {
	if (context.__teleportBuffers) {
		context.teleports = context.teleports || {};
		for (const key in context.__teleportBuffers) context.teleports[key] = await unrollBuffer$1(await Promise.all([context.__teleportBuffers[key]]));
	}
}

//#endregion
//#region packages/server-renderer/src/renderToStream.ts
const { isVNode } = vue.ssrUtils;
async function unrollBuffer(buffer, stream) {
	if (buffer.hasAsync) for (let i = 0; i < buffer.length; i++) {
		let item = buffer[i];
		if ((0, _vue_shared.isPromise)(item)) item = await item;
		if ((0, _vue_shared.isString)(item)) stream.push(item);
		else await unrollBuffer(item, stream);
	}
	else unrollBufferSync(buffer, stream);
}
function unrollBufferSync(buffer, stream) {
	for (let i = 0; i < buffer.length; i++) {
		let item = buffer[i];
		if ((0, _vue_shared.isString)(item)) stream.push(item);
		else unrollBufferSync(item, stream);
	}
}
function renderToSimpleStream(input, context, stream) {
	if (isVNode(input)) return renderToSimpleStream((0, vue.createApp)({ render: () => input }), context, stream);
	const vnode = (0, vue.createVNode)(input._component, input._props);
	vnode.appContext = input._context;
	input.provide(vue.ssrContextKey, context);
	Promise.resolve(renderComponentVNode(vnode)).then((buffer) => unrollBuffer(buffer, stream)).then(() => resolveTeleports(context)).then(() => {
		if (context.__watcherHandles) for (const unwatch of context.__watcherHandles) unwatch();
	}).then(() => stream.push(null)).catch((error) => {
		stream.destroy(error);
	});
	return stream;
}
/**
* @deprecated
*/
function renderToStream(input, context = {}) {
	console.warn(`[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead.`);
	return renderToNodeStream(input, context);
}
function renderToNodeStream(input, context = {}) {
	const stream = new (require("node:stream")).Readable({ read() {} });
	if (!stream) throw new Error("ESM build of renderToStream() does not support renderToNodeStream(). Use pipeToNodeWritable() with an existing Node.js Writable stream instance instead.");
	return renderToSimpleStream(input, context, stream);
}
function pipeToNodeWritable(input, context = {}, writable) {
	renderToSimpleStream(input, context, {
		push(content) {
			if (content != null) writable.write(content);
			else writable.end();
		},
		destroy(err) {
			writable.destroy(err);
		}
	});
}
function renderToWebStream(input, context = {}) {
	if (typeof ReadableStream !== "function") throw new Error("ReadableStream constructor is not available in the global scope. If the target environment does support web streams, consider using pipeToWebWritable() with an existing WritableStream instance instead.");
	const encoder = new TextEncoder();
	let cancelled = false;
	return new ReadableStream({
		start(controller) {
			renderToSimpleStream(input, context, {
				push(content) {
					if (cancelled) return;
					if (content != null) controller.enqueue(encoder.encode(content));
					else controller.close();
				},
				destroy(err) {
					controller.error(err);
				}
			});
		},
		cancel() {
			cancelled = true;
		}
	});
}
function pipeToWebWritable(input, context = {}, writable) {
	const writer = writable.getWriter();
	const encoder = new TextEncoder();
	let hasReady = false;
	try {
		hasReady = (0, _vue_shared.isPromise)(writer.ready);
	} catch (e) {}
	renderToSimpleStream(input, context, {
		async push(content) {
			if (hasReady) await writer.ready;
			if (content != null) return writer.write(encoder.encode(content));
			else return writer.close();
		},
		destroy(err) {
			console.log(err);
			writer.close();
		}
	});
}

//#endregion
//#region packages/server-renderer/src/index.ts
(0, vue.initDirectivesForSSR)();

//#endregion
exports.pipeToNodeWritable = pipeToNodeWritable;
exports.pipeToWebWritable = pipeToWebWritable;
exports.renderToNodeStream = renderToNodeStream;
exports.renderToSimpleStream = renderToSimpleStream;
exports.renderToStream = renderToStream;
exports.renderToString = renderToString;
exports.renderToWebStream = renderToWebStream;
exports.ssrGetDirectiveProps = ssrGetDirectiveProps;
exports.ssrGetDynamicModelProps = ssrGetDynamicModelProps;
exports.ssrIncludeBooleanAttr = _vue_shared.includeBooleanAttr;
exports.ssrInterpolate = ssrInterpolate;
exports.ssrLooseContain = ssrLooseContain;
exports.ssrLooseEqual = ssrLooseEqual;
exports.ssrRenderAttr = ssrRenderAttr;
exports.ssrRenderAttrs = ssrRenderAttrs;
exports.ssrRenderClass = ssrRenderClass;
exports.ssrRenderComponent = ssrRenderComponent;
exports.ssrRenderDynamicAttr = ssrRenderDynamicAttr;
exports.ssrRenderDynamicModel = ssrRenderDynamicModel;
exports.ssrRenderList = ssrRenderList;
exports.ssrRenderSlot = ssrRenderSlot;
exports.ssrRenderSlotInner = ssrRenderSlotInner;
exports.ssrRenderStyle = ssrRenderStyle;
exports.ssrRenderSuspense = ssrRenderSuspense;
exports.ssrRenderTeleport = ssrRenderTeleport;
exports.ssrRenderVNode = renderVNode;