/**
  * @vue/runtime-vapor v3.6.0-beta.5
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
import { EffectScope, NULL_DYNAMIC_COMPONENT, TransitionPropsValidators, VueElementBase, activate, baseApplyTranslation, baseEmit, baseNormalizePropsOptions, baseResolveTransitionHooks, baseUseCssVars, callPendingCbs, callWithAsyncErrorHandling, callWithErrorHandling, checkTransitionMode, createAppAPI, createAsyncComponentContext, createCanSetSetupRefChecker, createInternalObject, createVNode, currentInstance, currentInstance as currentInstance$1, deactivate, devtoolsComponentAdded, endMeasure, ensureHydrationRenderer, ensureRenderer, ensureVaporSlotFallback, expose, flushOnAppMount, forceReflow, getAttributeMismatch, getComponentName, getFunctionalFallthrough, getInheritedScopeIds, handleError, handleMovedChildren, hasCSSTransform, initFeatureFlags, isAsyncWrapper, isEmitListener, isHydrating, isKeepAlive, isMapEqual, isMismatchAllowed, isRef, isSetEqual, isTeleportDeferred, isTeleportDisabled, isTemplateNode, isVNode, isValidHtmlOrSvgAttribute, leaveCbKey, markAsyncBoundary, matches, mergeProps, nextUid, normalizeContainer, normalizeRef, onBeforeUnmount, onBeforeUpdate, onMounted, onScopeDispose, onUpdated, patchStyle, performAsyncHydrate, performTransitionEnter, performTransitionLeave, popWarningContext, pushWarningContext, queueJob, queuePostFlushCb, registerHMR, renderSlot, resetShapeFlag, resolveDynamicComponent, resolvePropValue, resolveTeleportTarget, resolveTransitionProps, setCurrentInstance, setDevtoolsHook, setRef, setTransitionHooks, setVarsOnNode, shallowReactive, shallowRef, shouldSetAsProp, simpleSetCurrentInstance, startMeasure, toClassSet, toStyleMap, unregisterHMR, unsafeToTrustedHTML, useAsyncComponentState, useTransitionState, vModelCheckboxInit, vModelCheckboxUpdate, vModelGetValue, vModelSelectInit, vModelSetSelected, vModelTextInit, vModelTextUpdate, vShowHidden, vShowOriginalDisplay, validateProps, warn, warnExtraneousAttributes, warnPropMismatch, watch, xlinkNS } from "@vue/runtime-dom";
import { EMPTY_ARR, EMPTY_OBJ, NO, NOOP, YES, camelize, canSetValueDirectly, extend, getEscapedCssVarName, getGlobalThis, hasOwn, includeBooleanAttr, invokeArrayFns, isArray, isFunction, isObject, isOn, isPlainObject, isPromise, isReservedProp, isString, looseEqual, normalizeClass, normalizeCssVarValue, normalizeStyle, parseStringStyle, remove as remove$1, stringifyStyle, toDisplayString } from "@vue/shared";
import { EffectScope as EffectScope$1, ReactiveEffect, computed, isReactive, isReadonly, isRef as isRef$1, isShallow, markRaw, onEffectCleanup, onScopeDispose as onScopeDispose$1, pauseTracking, proxyRefs, resetTracking, setActiveSub, shallowReadArray, shallowRef as shallowRef$1, toRaw, toReactive, toReadonly, traverse, unref, watch as watch$1 } from "@vue/reactivity";

//#region packages/runtime-vapor/src/insertionState.ts
let insertionParent;
let insertionAnchor;
let insertionIndex;
let isLastInsertion;
/**
* This function is called before a block type that requires insertion
* (component, slot outlet, if, for) is created. The state is used for actual
* insertion on client-side render, and used for node adoption during hydration.
*/
function setInsertionState(parent, anchor, logicalIndex, last) {
	insertionParent = parent;
	isLastInsertion = last;
	insertionIndex = logicalIndex;
	if (anchor !== void 0) if (isHydrating$1) insertionAnchor = void 0;
	else {
		insertionAnchor = anchor;
		if (anchor === 0 && !parent.$fc) parent.$fc = parent.firstChild;
	}
	else insertionAnchor = void 0;
}
function resetInsertionState() {
	insertionParent = insertionAnchor = insertionIndex = isLastInsertion = void 0;
}

//#endregion
//#region packages/runtime-vapor/src/dom/hydration.ts
let isHydratingEnabled = false;
function setIsHydratingEnabled(value) {
	isHydratingEnabled = value;
}
let currentHydrationNode = null;
let isHydrating$1 = false;
function setIsHydrating(value) {
	if (!isHydratingEnabled) return false;
	try {
		return isHydrating$1;
	} finally {
		isHydrating$1 = value;
	}
}
function runWithoutHydration(fn) {
	const prev = setIsHydrating(false);
	try {
		return fn();
	} finally {
		setIsHydrating(prev);
	}
}
let isOptimized$1 = false;
function performHydration(fn, setup, cleanup) {
	if (!isOptimized$1) {
		adoptTemplate = adoptTemplateImpl;
		locateHydrationNode = locateHydrationNodeImpl;
		Comment.prototype.$fe = void 0;
		Node.prototype.$pns = void 0;
		Node.prototype.$idx = void 0;
		Node.prototype.$llc = void 0;
		isOptimized$1 = true;
	}
	enableHydrationNodeLookup();
	const prev = setIsHydrating(true);
	setup();
	const res = fn();
	cleanup();
	currentHydrationNode = null;
	setIsHydrating(prev);
	if (!isHydrating$1) disableHydrationNodeLookup();
	return res;
}
function withHydration(container, fn) {
	const setup = () => setInsertionState(container);
	const cleanup = () => resetInsertionState();
	return performHydration(fn, setup, cleanup);
}
function hydrateNode(node, fn) {
	const setup = () => currentHydrationNode = node;
	const cleanup = () => {};
	return performHydration(fn, setup, cleanup);
}
let adoptTemplate;
let locateHydrationNode;
const isComment = (node, data) => node.nodeType === 8 && node.data === data;
function setCurrentHydrationNode(node) {
	currentHydrationNode = node;
}
/* @__NO_SIDE_EFFECTS__ */
function locateNextSiblingOfParent(n) {
	if (!n.parentNode) return null;
	return n.parentNode.nextSibling || /* @__PURE__ */ locateNextSiblingOfParent(n.parentNode);
}
function advanceHydrationNode(node) {
	const ret = node.nextSibling || node.$pns || (node.$pns = /* @__PURE__ */ locateNextSiblingOfParent(node));
	if (ret) setCurrentHydrationNode(ret);
}
/**
* Locate the first non-fragment-comment node and locate the next node
* while handling potential fragments.
*/
function adoptTemplateImpl(node, template) {
	if (!(template[0] === "<" && template[1] === "!")) while (node.nodeType === 8) {
		node = node.nextSibling;
		if (template.trim() === "" && isComment(node, "]") && isComment(node.previousSibling, "[")) {
			node.before(node = /* @__PURE__ */ createTextNode());
			break;
		}
	}
	const type = node.nodeType;
	if (type === 8 && !template.startsWith("<!") || type === 1 && !template.startsWith(`<` + node.tagName.toLowerCase())) node = handleMismatch(node, template);
	currentHydrationNode = node.nextSibling;
	return node;
}
function locateNextNode(node) {
	return isComment(node, "[") ? /* @__PURE__ */ _next(locateEndAnchor(node)) : isComment(node, "teleport start") ? /* @__PURE__ */ _next(locateEndAnchor(node, "teleport start", "teleport end")) : /* @__PURE__ */ _next(node);
}
function locateHydrationNodeImpl() {
	let node;
	if (insertionIndex !== void 0) node = locateChildByLogicalIndex(insertionParent, insertionIndex);
	else if (insertionParent) node = insertionParent.firstChild;
	else node = currentHydrationNode;
	if (!!(process.env.NODE_ENV !== "production") && !node) throw new Error("No current hydration node was found.\nthis is likely a Vue internal bug.");
	resetInsertionState();
	currentHydrationNode = node;
}
function locateEndAnchor(node, open = "[", close = "]") {
	if (node.$fe) return node.$fe;
	const stack = [node];
	while ((node = node.nextSibling) && stack.length > 0) if (node.nodeType === 8) {
		if (node.data === open) stack.push(node);
		else if (node.data === close) {
			const matchingOpen = stack.pop();
			matchingOpen.$fe = node;
			if (stack.length === 0) return node;
		}
	}
	return null;
}
function locateFragmentEndAnchor(label = "]") {
	let node = currentHydrationNode;
	while (node) {
		if (isComment(node, label)) return node;
		node = node.nextSibling;
	}
	return null;
}
function handleMismatch(node, template) {
	if (!isMismatchAllowed(node.parentElement, 1)) {
		(process.env.NODE_ENV !== "production" || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn(`Hydration node mismatch:\n- rendered on server:`, node, node.nodeType === 3 ? `(text)` : isComment(node, "[[") ? `(start of block node)` : ``, `\n- expected on client:`, template);
		logMismatchError();
	}
	if (isComment(node, "[")) removeFragmentNodes(node);
	const next = /* @__PURE__ */ _next(node);
	const container = /* @__PURE__ */ parentNode(node);
	remove(node, container);
	if (template[0] !== "<") return container.insertBefore(/* @__PURE__ */ createTextNode(template), next);
	const t = /* @__PURE__ */ createElement("template");
	t.innerHTML = template;
	const newNode = (/* @__PURE__ */ _child(t.content)).cloneNode(true);
	newNode.innerHTML = node.innerHTML;
	Array.from(node.attributes).forEach((attr) => {
		newNode.setAttribute(attr.name, attr.value);
	});
	container.insertBefore(newNode, next);
	return newNode;
}
let hasLoggedMismatchError = false;
const logMismatchError = () => {
	if (hasLoggedMismatchError) return;
	console.error("Hydration completed but contains mismatches.");
	hasLoggedMismatchError = true;
};
function removeFragmentNodes(node, endAnchor) {
	const end = endAnchor || locateEndAnchor(node);
	while (true) {
		const next = /* @__PURE__ */ _next(node);
		if (next && next !== end) remove(next, /* @__PURE__ */ parentNode(node));
		else break;
	}
}

//#endregion
//#region packages/runtime-vapor/src/dom/node.ts
/* @__NO_SIDE_EFFECTS__ */
function createElement(tagName) {
	return document.createElement(tagName);
}
/* @__NO_SIDE_EFFECTS__ */
function createTextNode(value = "") {
	return document.createTextNode(value);
}
/* @__NO_SIDE_EFFECTS__ */
function createComment(data) {
	return document.createComment(data);
}
/* @__NO_SIDE_EFFECTS__ */
function querySelector(selectors) {
	return document.querySelector(selectors);
}
/* @__NO_SIDE_EFFECTS__ */
function parentNode(node) {
	return node.parentNode;
}
const _txt = _child;
/**
* Hydration-specific version of `txt`.
*/
const __txt = /* @__NO_SIDE_EFFECTS__ */ (node) => {
	let n = node.firstChild;
	if (!n) return node.appendChild(/* @__PURE__ */ createTextNode());
	return n;
};
/* @__NO_SIDE_EFFECTS__ */
function _child(node) {
	return node.firstChild;
}
/**
* Hydration-specific version of `child`.
*/
/* @__NO_SIDE_EFFECTS__ */
function __child(node, logicalIndex = 0) {
	return locateChildByLogicalIndex(node, logicalIndex);
}
/* @__NO_SIDE_EFFECTS__ */
function _nthChild(node, i) {
	return node.childNodes[i];
}
/**
* Hydration-specific version of `nthChild`.
*/
/* @__NO_SIDE_EFFECTS__ */
function __nthChild(node, logicalIndex) {
	return locateChildByLogicalIndex(node, logicalIndex);
}
/* @__NO_SIDE_EFFECTS__ */
function _next(node) {
	return node.nextSibling;
}
/**
* Hydration-specific version of `next`.
*/
/* @__NO_SIDE_EFFECTS__ */
function __next(node, logicalIndex) {
	return locateChildByLogicalIndex(node.parentNode, logicalIndex);
}
const txt = /* @__NO_SIDE_EFFECTS__ */ (...args) => {
	return txt.impl(...args);
};
txt.impl = _txt;
const child = /* @__NO_SIDE_EFFECTS__ */ (...args) => {
	return child.impl(...args);
};
child.impl = _child;
const next = /* @__NO_SIDE_EFFECTS__ */ (...args) => {
	return next.impl(...args);
};
next.impl = _next;
const nthChild = /* @__NO_SIDE_EFFECTS__ */ (...args) => {
	return nthChild.impl(...args);
};
nthChild.impl = _nthChild;
/**
* Enables hydration-specific node lookup behavior.
*
* Temporarily switches the implementations of the exported
* `txt`, `child`, `next`, and `nthChild` functions to their hydration-specific
* versions (`__txt`, `__child`, `__next`, `__nthChild`). This allows traversal
* logic to correctly handle SSR comment anchors during hydration.
*/
function enableHydrationNodeLookup() {
	txt.impl = __txt;
	child.impl = __child;
	next.impl = __next;
	nthChild.impl = __nthChild;
}
function disableHydrationNodeLookup() {
	txt.impl = _txt;
	child.impl = _child;
	next.impl = _next;
	nthChild.impl = _nthChild;
}
function locateChildByLogicalIndex(parent, logicalIndex) {
	let child = parent.$llc || parent.firstChild;
	let fromIndex = child.$idx || 0;
	if (logicalIndex < fromIndex) {
		child = parent.firstChild;
		fromIndex = 0;
	}
	while (child) {
		if (fromIndex === logicalIndex) {
			child.$idx = logicalIndex;
			return parent.$llc = child;
		}
		child = isComment(child, "[") ? locateEndAnchor(child).nextSibling : child.nextSibling;
		fromIndex++;
	}
	return null;
}

//#endregion
//#region packages/runtime-vapor/src/dom/event.ts
function addEventListener(el, event, handler, options) {
	el.addEventListener(event, handler, options);
	return () => el.removeEventListener(event, handler, options);
}
function on(el, event, handler, options = {}) {
	if (isArray(handler)) handler.forEach((fn) => on(el, event, fn, options));
	else {
		if (!handler) return;
		addEventListener(el, event, handler, options);
		if (options.effect) onEffectCleanup(() => {
			el.removeEventListener(event, handler, options);
		});
	}
}
function delegate(el, event, handler) {
	const key = `$evt${event}`;
	const existing = el[key];
	if (existing) if (isArray(existing)) existing.push(handler);
	else el[key] = [existing, handler];
	else el[key] = handler;
}
/**
* Event delegation borrowed from solid
*/
const delegatedEvents = /* @__PURE__ */ Object.create(null);
const delegateEvents = (...names) => {
	for (const name of names) if (!delegatedEvents[name]) {
		delegatedEvents[name] = true;
		document.addEventListener(name, delegatedEventHandler);
	}
};
const delegatedEventHandler = (e) => {
	let node = e.composedPath && e.composedPath()[0] || e.target;
	if (e.target !== node) Object.defineProperty(e, "target", {
		configurable: true,
		value: node
	});
	Object.defineProperty(e, "currentTarget", {
		configurable: true,
		get() {
			return node || document;
		}
	});
	while (node !== null) {
		const handlers = node[`$evt${e.type}`];
		if (handlers) if (isArray(handlers)) {
			for (const handler of handlers) if (!node.disabled) {
				handler(e);
				if (e.cancelBubble) return;
			}
		} else {
			handlers(e);
			if (e.cancelBubble) return;
		}
		node = node.host && node.host !== node && node.host instanceof Node ? node.host : node.parentNode;
	}
};
function setDynamicEvents(el, events) {
	for (const name in events) on(el, name, events[name], { effect: true });
}
function createInvoker(handler) {
	const i = currentInstance;
	return (...args) => callWithAsyncErrorHandling(handler, i, 5, args);
}

//#endregion
//#region packages/runtime-vapor/src/dom/prop.ts
const hasFallthroughKey = (key) => currentInstance.hasFallthrough && key in currentInstance.attrs;
function setProp(el, key, value) {
	if (key in el) setDOMProp(el, key, value);
	else setAttr(el, key, value);
}
function setAttr(el, key, value, isSVG = false) {
	if (!isApplyingFallthroughProps && el.$root && hasFallthroughKey(key)) return;
	if (key === "true-value") el._trueValue = value;
	else if (key === "false-value") el._falseValue = value;
	if ((!!(process.env.NODE_ENV !== "production") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && isHydrating$1 && !attributeHasMismatch(el, key, value)) {
		el[`$${key}`] = value;
		return;
	}
	if (value !== el[`$${key}`]) {
		el[`$${key}`] = value;
		if (isSVG && key.startsWith("xlink:")) if (value != null) el.setAttributeNS(xlinkNS, key, value);
		else el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
		else if (value != null) el.setAttribute(key, value);
		else el.removeAttribute(key);
	}
}
function setDOMProp(el, key, value, forceHydrate = false, attrName) {
	if (!isApplyingFallthroughProps && el.$root && hasFallthroughKey(key)) return;
	if ((!!(process.env.NODE_ENV !== "production") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && isHydrating$1 && !attributeHasMismatch(el, key, value) && !shouldForceHydrate(el, key) && !forceHydrate) return;
	const prev = el[key];
	if (value === prev) return;
	let needRemove = false;
	if (value === "" || value == null) {
		const type = typeof prev;
		if (type === "boolean") value = includeBooleanAttr(value);
		else if (value == null && type === "string") {
			value = "";
			needRemove = true;
		} else if (type === "number") {
			value = 0;
			needRemove = true;
		}
	}
	try {
		el[key] = value;
	} catch (e) {
		if (!!(process.env.NODE_ENV !== "production") && !needRemove) warn(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: value ${value} is invalid.`, e);
	}
	needRemove && el.removeAttribute(attrName || key);
}
function setClass(el, value, isSVG = false) {
	if (el.$root) setClassIncremental(el, value);
	else {
		value = normalizeClass(value);
		if ((!!(process.env.NODE_ENV !== "production") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && isHydrating$1 && !classHasMismatch(el, value, false)) {
			el.$cls = value;
			return;
		}
		if (value !== el.$cls) if (isSVG) el.setAttribute("class", el.$cls = value);
		else el.className = el.$cls = value;
	}
}
function setClassIncremental(el, value) {
	const cacheKey = `$clsi${isApplyingFallthroughProps ? "$" : ""}`;
	const normalizedValue = normalizeClass(value);
	if ((!!(process.env.NODE_ENV !== "production") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && isHydrating$1 && !classHasMismatch(el, normalizedValue, true)) {
		el[cacheKey] = normalizedValue;
		return;
	}
	const prev = el[cacheKey];
	if ((value = el[cacheKey] = normalizedValue) !== prev) {
		const nextList = value.split(/\s+/);
		if (value) el.classList.add(...nextList);
		if (prev) {
			for (const cls of prev.split(/\s+/)) if (!nextList.includes(cls)) el.classList.remove(cls);
		}
	}
}
/**
* dev only
* defer style matching checks until hydration completes (instance.block is set) if
* the component uses style v-bind or the element contains CSS variables, to correctly
* verify if the element is the component root.
*/
function shouldDeferCheckStyleMismatch(el) {
	return !!(process.env.NODE_ENV !== "production") && (!!currentInstance.getCssVars || Object.values(el.style).some((v) => v.startsWith("--")));
}
function setStyle(el, value) {
	if (el.$root) setStyleIncremental(el, value);
	else {
		const normalizedValue = normalizeStyle(value);
		if ((!!(process.env.NODE_ENV !== "production") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && isHydrating$1) {
			if (shouldDeferCheckStyleMismatch(el)) {
				const instance = currentInstance;
				queuePostFlushCb(() => {
					if (!styleHasMismatch(el, value, normalizedValue, false, instance)) {
						el.$sty = normalizedValue;
						return;
					}
					patchStyle(el, el.$sty, el.$sty = normalizedValue);
				});
				return;
			} else if (!styleHasMismatch(el, value, normalizedValue, false)) {
				el.$sty = normalizedValue;
				return;
			}
		}
		patchStyle(el, el.$sty, el.$sty = normalizedValue);
	}
}
function setStyleIncremental(el, value) {
	const cacheKey = `$styi${isApplyingFallthroughProps ? "$" : ""}`;
	const normalizedValue = isString(value) ? parseStringStyle(value) : normalizeStyle(value);
	if ((!!(process.env.NODE_ENV !== "production") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && isHydrating$1) {
		if (shouldDeferCheckStyleMismatch(el)) {
			const instance = currentInstance;
			queuePostFlushCb(() => {
				if (!styleHasMismatch(el, value, normalizedValue, true, instance)) {
					el[cacheKey] = normalizedValue;
					return;
				}
				patchStyle(el, el[cacheKey], el[cacheKey] = normalizedValue);
			});
			return;
		} else if (!styleHasMismatch(el, value, normalizedValue, true)) {
			el[cacheKey] = normalizedValue;
			return;
		}
	}
	patchStyle(el, el[cacheKey], el[cacheKey] = normalizedValue);
}
function setValue(el, value, forceHydrate = false) {
	if (!isApplyingFallthroughProps && el.$root && hasFallthroughKey("value")) return;
	el._value = value;
	if ((!!(process.env.NODE_ENV !== "production") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && isHydrating$1 && !attributeHasMismatch(el, "value", getClientText(el, value)) && !shouldForceHydrate(el, "value") && !forceHydrate) return;
	const oldValue = el.tagName === "OPTION" ? el.getAttribute("value") : el.value;
	const newValue = value == null ? "" : value;
	if (oldValue !== newValue) el.value = newValue;
	if (value == null) el.removeAttribute("value");
}
/**
* Only called on text nodes!
* Compiler should also ensure value passed here is already converted by
* `toDisplayString`
*/
function setText(el, value) {
	if (isHydrating$1) {
		const clientText = getClientText(el.parentNode, value);
		if (el.nodeValue == clientText) {
			el.$txt = clientText;
			return;
		}
		(process.env.NODE_ENV !== "production" || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn(`Hydration text mismatch in`, el.parentNode, `\n  - rendered on server: ${JSON.stringify(el.data)}\n  - expected on client: ${JSON.stringify(value)}`);
		logMismatchError();
	}
	if (el.$txt !== value) el.nodeValue = el.$txt = value;
}
/**
* Used by setDynamicProps only, so need to guard with `toDisplayString`
*/
function setElementText(el, value) {
	value = toDisplayString(value);
	if (isHydrating$1) {
		let clientText = getClientText(el, value);
		if (el.textContent === clientText) {
			el.$txt = clientText;
			return;
		}
		if (!isMismatchAllowed(el, 0)) {
			(process.env.NODE_ENV !== "production" || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn(`Hydration text content mismatch on`, el, `\n  - rendered on server: ${el.textContent}\n  - expected on client: ${clientText}`);
			logMismatchError();
		}
	}
	if (el.$txt !== value) el.textContent = el.$txt = value;
}
function setBlockText(block, value) {
	value = value == null ? "" : value;
	if (block.$txt !== value) setTextToBlock(block, block.$txt = value);
}
/**
* dev only
*/
function warnCannotSetProp(prop) {
	warn(`Extraneous non-props attributes (${prop}) were passed to component but could not be automatically inherited because component renders text or multiple root nodes.`);
}
function setTextToBlock(block, value) {
	if (block instanceof Node) {
		if (block instanceof Element) block.textContent = value;
		else if (!!(process.env.NODE_ENV !== "production")) warnCannotSetProp("textContent");
	} else if (isVaporComponent(block)) setTextToBlock(block.block, value);
	else if (isArray(block)) {
		if (!!(process.env.NODE_ENV !== "production")) warnCannotSetProp("textContent");
	} else setTextToBlock(block.nodes, value);
}
function setHtml(el, value) {
	value = value == null ? "" : unsafeToTrustedHTML(value);
	if (el.$html !== value) el.innerHTML = el.$html = value;
}
function setBlockHtml(block, value) {
	value = value == null ? "" : unsafeToTrustedHTML(value);
	if (block.$html !== value) setHtmlToBlock(block, block.$html = value);
}
function setHtmlToBlock(block, value) {
	if (block instanceof Node) {
		if (block instanceof Element) block.innerHTML = value;
		else if (!!(process.env.NODE_ENV !== "production")) warnCannotSetProp("innerHTML");
	} else if (isVaporComponent(block)) setHtmlToBlock(block.block, value);
	else if (isArray(block)) {
		if (!!(process.env.NODE_ENV !== "production")) warnCannotSetProp("innerHTML");
	} else setHtmlToBlock(block.nodes, value);
}
function setDynamicProps(el, args, isSVG) {
	const props = args.length > 1 ? mergeProps(...args) : args[0];
	const cacheKey = `$dprops${isApplyingFallthroughProps ? "$" : ""}`;
	const prevKeys = el[cacheKey];
	if (prevKeys) {
		for (const key of prevKeys) if (!(key in props)) setDynamicProp(el, key, null, isSVG);
	}
	for (const key of el[cacheKey] = Object.keys(props)) setDynamicProp(el, key, props[key], isSVG);
}
/**
* @internal
*/
function setDynamicProp(el, key, value, isSVG = false) {
	let forceHydrate = false;
	if (key === "class") setClass(el, value, isSVG);
	else if (key === "style") setStyle(el, value);
	else if (isOn(key)) on(el, key[2].toLowerCase() + key.slice(3), value, { effect: true });
	else if ((forceHydrate = key[0] === ".") ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, value, isSVG)) if (key === "innerHTML") setHtml(el, value);
	else if (key === "textContent") setElementText(el, value);
	else if (key === "value" && canSetValueDirectly(el.tagName)) setValue(el, value, forceHydrate);
	else setDOMProp(el, key, value, forceHydrate);
	else if (el._isVueCE && (/[A-Z]/.test(key) || !isString(value))) setDOMProp(el, camelize(key), value, forceHydrate, key);
	else setAttr(el, key, value, isSVG);
	return value;
}
let isOptimized = false;
/**
* Optimize property lookup for cache properties on Element and Text nodes
*/
function optimizePropertyLookup() {
	if (isOptimized) return;
	isOptimized = true;
	const proto = Element.prototype;
	proto.$transition = void 0;
	proto.$key = void 0;
	proto.$fc = proto.$evtclick = void 0;
	proto.$root = false;
	proto.$html = proto.$cls = proto.$sty = "";
	Text.prototype.$txt = void 0;
}
function classHasMismatch(el, expected, isIncremental) {
	const actual = el.getAttribute("class");
	const actualClassSet = toClassSet(actual || "");
	const expectedClassSet = toClassSet(expected);
	let hasMismatch = false;
	if (isIncremental) {
		if (expected) hasMismatch = Array.from(expectedClassSet).some((cls) => !actualClassSet.has(cls));
	} else hasMismatch = !isSetEqual(actualClassSet, expectedClassSet);
	if (hasMismatch) {
		warnPropMismatch(el, "class", 2, actual, expected);
		logMismatchError();
		return true;
	}
	return false;
}
function styleHasMismatch(el, value, normalizedValue, isIncremental, instance = currentInstance) {
	const actual = el.getAttribute("style");
	const actualStyleMap = toStyleMap(actual || "");
	const expected = isString(value) ? value : stringifyStyle(normalizedValue);
	const expectedStyleMap = toStyleMap(expected);
	if (el[vShowHidden]) expectedStyleMap.set("display", "none");
	if (instance) resolveCssVars(instance, el, expectedStyleMap);
	let hasMismatch = false;
	if (isIncremental) {
		if (expected) hasMismatch = Array.from(expectedStyleMap.entries()).some(([key, val]) => actualStyleMap.get(key) !== val);
	} else hasMismatch = !isMapEqual(actualStyleMap, expectedStyleMap);
	if (hasMismatch) {
		warnPropMismatch(el, "style", 3, actual, expected);
		logMismatchError();
		return true;
	}
	return false;
}
/**
* dev only
*/
function resolveCssVars(instance, block, expectedMap) {
	if (!instance.isMounted) return;
	const rootBlocks = normalizeBlock(instance);
	if (instance.getCssVars && normalizeBlock(block).every((b) => rootBlocks.includes(b))) {
		const cssVars = instance.getCssVars();
		for (const key in cssVars) {
			const value = normalizeCssVarValue(cssVars[key]);
			expectedMap.set(`--${getEscapedCssVarName(key, false)}`, value);
		}
	}
	if (normalizeBlock(block).every((b) => rootBlocks.includes(b)) && instance.parent) resolveCssVars(instance.parent, instance.block, expectedMap);
}
function attributeHasMismatch(el, key, value) {
	if (isValidHtmlOrSvgAttribute(el, key)) {
		const { actual, expected } = getAttributeMismatch(el, key, value);
		if (actual !== expected) {
			warnPropMismatch(el, key, 4, actual, expected);
			logMismatchError();
			return true;
		}
	}
	return false;
}
function getClientText(el, value) {
	if (value[0] === "\n" && (el.tagName === "PRE" || el.tagName === "TEXTAREA")) value = value.slice(1);
	return value;
}
function shouldForceHydrate(el, key) {
	const { tagName } = el;
	return (tagName === "INPUT" || tagName === "OPTION") && (key.endsWith("value") || key === "indeterminate") || tagName.includes("-");
}

//#endregion
//#region packages/runtime-vapor/src/components/Transition.ts
const displayName = "VaporTransition";
let registered = false;
const ensureTransitionHooksRegistered = () => {
	if (!registered) {
		registered = true;
		registerTransitionHooks(applyTransitionHooksImpl, applyTransitionLeaveHooksImpl);
	}
};
const hydrateTransitionImpl = () => {
	if (!currentHydrationNode || !isTemplateNode(currentHydrationNode)) return;
	const { content: { firstChild }, parentNode } = currentHydrationNode;
	if (firstChild) {
		parentNode.replaceChild(firstChild, currentHydrationNode);
		setCurrentHydrationNode(firstChild);
		if (firstChild instanceof HTMLElement || firstChild instanceof SVGElement) {
			const originalDisplay = firstChild.style.display;
			firstChild.style.display = "none";
			return (hooks) => {
				hooks.beforeEnter(firstChild);
				firstChild.style.display = originalDisplay;
				queuePostFlushCb(() => hooks.enter(firstChild));
			};
		}
	}
};
const decorate$1 = (t) => {
	t.displayName = displayName;
	t.props = TransitionPropsValidators;
	t.__vapor = true;
	return t;
};
const VaporTransition = /* @__PURE__ */ decorate$1((props, { slots }) => {
	ensureTransitionHooksRegistered();
	const performAppear = isHydrating$1 ? hydrateTransitionImpl() : void 0;
	const children = slots.default && slots.default();
	if (!children) return [];
	const instance = currentInstance;
	const { mode } = props;
	checkTransitionMode(mode);
	let resolvedProps;
	renderEffect(() => resolvedProps = resolveTransitionProps(props));
	const hooks = applyTransitionHooksImpl(children, {
		state: useTransitionState(),
		props: new Proxy({}, { get(_, key) {
			return resolvedProps[key];
		} }),
		instance
	});
	if (resolvedProps.appear && performAppear) performAppear(hooks);
	return children;
});
const getTransitionHooksContext = (key, props, state, instance, postClone) => {
	const { leavingNodes } = state;
	return {
		setLeavingNodeCache: (el) => {
			leavingNodes.set(key, el);
		},
		unsetLeavingNodeCache: (el) => {
			if (leavingNodes.get(key) === el) leavingNodes.delete(key);
		},
		earlyRemove: () => {
			const leavingNode = leavingNodes.get(key);
			if (leavingNode && leavingNode[leaveCbKey]) leavingNode[leaveCbKey]();
		},
		cloneHooks: (block) => {
			const hooks = resolveTransitionHooks(block, props, state, instance, postClone);
			if (postClone) postClone(hooks);
			return hooks;
		}
	};
};
function resolveTransitionHooks(block, props, state, instance, postClone) {
	const hooks = baseResolveTransitionHooks(getTransitionHooksContext(String(block.$key), props, state, instance, postClone), props, state, instance);
	hooks.state = state;
	hooks.props = props;
	hooks.instance = instance;
	return hooks;
}
function applyTransitionHooksImpl(block, hooks) {
	if (isArray(block)) {
		block = block.filter((b) => !(b instanceof Comment));
		if (block.length === 1) block = block[0];
		else if (block.length === 0) return hooks;
	}
	const fragments = [];
	const child = findTransitionBlock(block, (frag) => fragments.push(frag));
	if (!child) {
		fragments.forEach((f) => f.$transition = hooks);
		if (!!(process.env.NODE_ENV !== "production") && fragments.length === 0) warn("Transition component has no valid child element");
		return hooks;
	}
	const { props, instance, state, delayedLeave } = hooks;
	let resolvedHooks = resolveTransitionHooks(child, props, state, instance, (hooks) => resolvedHooks = hooks);
	resolvedHooks.delayedLeave = delayedLeave;
	child.$transition = resolvedHooks;
	fragments.forEach((f) => f.$transition = resolvedHooks);
	return resolvedHooks;
}
function applyTransitionLeaveHooksImpl(block, enterHooks, afterLeaveCb) {
	const leavingBlock = findTransitionBlock(block);
	if (!leavingBlock) return void 0;
	const { props, state, instance } = enterHooks;
	const leavingHooks = resolveTransitionHooks(leavingBlock, props, state, instance);
	leavingBlock.$transition = leavingHooks;
	const { mode } = props;
	if (mode === "out-in") {
		state.isLeaving = true;
		leavingHooks.afterLeave = () => {
			state.isLeaving = false;
			afterLeaveCb();
			leavingBlock.$transition = void 0;
			delete leavingHooks.afterLeave;
		};
	} else if (mode === "in-out") leavingHooks.delayLeave = (block, earlyRemove, delayedLeave) => {
		state.leavingNodes.set(String(leavingBlock.$key), leavingBlock);
		block[leaveCbKey] = () => {
			earlyRemove();
			block[leaveCbKey] = void 0;
			leavingBlock.$transition = void 0;
			delete enterHooks.delayedLeave;
		};
		enterHooks.delayedLeave = () => {
			delayedLeave();
			leavingBlock.$transition = void 0;
			delete enterHooks.delayedLeave;
		};
	};
}
function findTransitionBlock(block, onFragment) {
	let child;
	if (block instanceof Node) {
		if (block instanceof Element) child = block;
	} else if (isVaporComponent(block)) if (isAsyncWrapper(block)) if (!block.type.__asyncResolved) onFragment && onFragment(block.block);
	else child = findTransitionBlock(block.block.nodes, onFragment);
	else {
		if (getComponentName(block.type) === displayName) return void 0;
		child = findTransitionBlock(block.block, onFragment);
		if (child && child.$key === void 0) child.$key = block.uid;
	}
	else if (isArray(block)) {
		let hasFound = false;
		for (const c of block) {
			if (c instanceof Comment) continue;
			const item = findTransitionBlock(c, onFragment);
			if (!!(process.env.NODE_ENV !== "production") && hasFound) {
				warn("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
				break;
			}
			child = item;
			hasFound = true;
			if (!!!(process.env.NODE_ENV !== "production")) break;
		}
	} else if (isFragment(block)) if (block.insert) child = block;
	else {
		if (onFragment) onFragment(block);
		child = findTransitionBlock(block.nodes, onFragment);
	}
	return child;
}
function setTransitionHooksOnFragment(block, hooks) {
	if (isFragment(block)) {
		block.$transition = hooks;
		if (block.nodes && isFragment(block.nodes)) setTransitionHooksOnFragment(block.nodes, hooks);
	} else if (isArray(block)) for (let i = 0; i < block.length; i++) setTransitionHooksOnFragment(block[i], hooks);
}
function setTransitionHooks$1(block, hooks) {
	if (isVaporComponent(block)) {
		block = findTransitionBlock(block.block);
		if (!block) return;
	}
	block.$transition = hooks;
}

//#endregion
//#region packages/runtime-vapor/src/apiDefineComponent.ts
/* @__NO_SIDE_EFFECTS__ */
function defineVaporComponent(comp, extraOptions) {
	if (isFunction(comp)) return extend({ name: comp.name }, extraOptions, {
		setup: comp,
		__vapor: true
	});
	comp.__vapor = true;
	return comp;
}

//#endregion
//#region packages/runtime-vapor/src/components/KeepAlive.ts
let currentKeepAliveCtx = null;
function setCurrentKeepAliveCtx(ctx) {
	try {
		return currentKeepAliveCtx;
	} finally {
		currentKeepAliveCtx = ctx;
	}
}
const KeepAliveImpl = /* @__PURE__ */ defineVaporComponent({
	name: "VaporKeepAlive",
	__isKeepAlive: true,
	props: {
		include: [
			String,
			RegExp,
			Array
		],
		exclude: [
			String,
			RegExp,
			Array
		],
		max: [String, Number]
	},
	setup(props, { slots }) {
		if (!slots.default) return;
		const keepAliveInstance = currentInstance;
		const cache = /* @__PURE__ */ new Map();
		const keys = /* @__PURE__ */ new Set();
		const storageContainer = /* @__PURE__ */ createElement("div");
		const keptAliveScopes = /* @__PURE__ */ new Map();
		let current;
		if (!!(process.env.NODE_ENV !== "production") || __VUE_PROD_DEVTOOLS__) keepAliveInstance.__v_cache = cache;
		if (!!(process.env.NODE_ENV !== "production")) {
			const rerender = keepAliveInstance.hmrRerender;
			keepAliveInstance.hmrRerender = () => {
				cache.forEach((cached) => resetCachedShapeFlag(cached));
				cache.clear();
				keys.clear();
				keptAliveScopes.forEach((scope) => scope.stop());
				keptAliveScopes.clear();
				storageContainer.innerHTML = "";
				current = void 0;
				rerender();
			};
		}
		keepAliveInstance.ctx = {
			getStorageContainer: () => storageContainer,
			getCachedComponent: (comp) => cache.get(comp),
			activate: (instance, parentNode, anchor) => {
				current = instance;
				activate$1(instance, parentNode, anchor);
			},
			deactivate: (instance) => {
				current = void 0;
				deactivate$1(instance, storageContainer);
			}
		};
		const innerCacheBlock = (key, block) => {
			const { max } = props;
			if (cache.has(key)) {
				keys.delete(key);
				keys.add(key);
			} else {
				keys.add(key);
				if (max && keys.size > parseInt(max, 10)) pruneCacheEntry(keys.values().next().value);
			}
			cache.set(key, block);
			current = block;
		};
		const cacheBlock = () => {
			const block = keepAliveInstance.block;
			if (isDynamicFragment(block)) {
				const transition = block.$transition;
				if (transition && transition.mode === "out-in" && transition.state.isLeaving) return;
			}
			const [innerBlock, interop] = getInnerBlock(block);
			if (!innerBlock || !shouldCache(innerBlock, props, interop)) return;
			innerCacheBlock(interop ? innerBlock.vnode.type : innerBlock.type, innerBlock);
		};
		const processShapeFlag = (block) => {
			const [innerBlock, interop] = getInnerBlock(block);
			if (!innerBlock || !shouldCache(innerBlock, props, interop)) return false;
			if (interop) {
				if (cache.has(innerBlock.vnode.type)) innerBlock.vnode.shapeFlag |= 512;
				innerBlock.vnode.shapeFlag |= 256;
			} else {
				if (cache.has(innerBlock.type)) innerBlock.shapeFlag |= 512;
				innerBlock.shapeFlag |= 256;
			}
			return true;
		};
		const pruneCache = (filter) => {
			cache.forEach((cached, key) => {
				const instance = getInstanceFromCache(cached);
				if (!instance) return;
				const name = getComponentName(instance.type);
				if (name && !filter(name)) pruneCacheEntry(key);
			});
		};
		const pruneCacheEntry = (key) => {
			const cached = cache.get(key);
			if (cached && (!current || cached !== current)) {
				resetCachedShapeFlag(cached);
				remove(cached);
			} else if (current) resetCachedShapeFlag(current);
			cache.delete(key);
			keys.delete(key);
		};
		watch(() => [props.include, props.exclude], ([include, exclude]) => {
			include && pruneCache((name) => matches(include, name));
			exclude && pruneCache((name) => !matches(exclude, name));
		}, {
			flush: "post",
			deep: true
		});
		onMounted(cacheBlock);
		onUpdated(cacheBlock);
		onBeforeUnmount(() => {
			cache.forEach((cached, key) => {
				const instance = getInstanceFromCache(cached);
				if (!instance) return;
				resetCachedShapeFlag(cached);
				cache.delete(key);
				if (current) {
					if ((isVaporComponent(current) ? current.type : current.vnode.type) === key) {
						const da = instance.da;
						da && queuePostFlushCb(da);
						return;
					}
				}
				remove(cached, storageContainer);
			});
			keptAliveScopes.forEach((scope) => scope.stop());
			keptAliveScopes.clear();
		});
		const prevCtx = setCurrentKeepAliveCtx({
			processShapeFlag,
			cacheBlock,
			cacheScope(key, scope) {
				keptAliveScopes.set(key, scope);
			},
			getScope(key) {
				const scope = keptAliveScopes.get(key);
				if (scope) {
					keptAliveScopes.delete(key);
					return scope;
				}
			}
		});
		let children = slots.default();
		setCurrentKeepAliveCtx(prevCtx);
		if (isArray(children)) {
			children = children.filter((child) => !(child instanceof Comment));
			if (children.length > 1) {
				if (!!(process.env.NODE_ENV !== "production")) warn(`KeepAlive should contain exactly one component child.`);
				return children;
			}
		}
		return children;
	}
});
const VaporKeepAliveImpl = KeepAliveImpl;
const shouldCache = (block, props, interop = false) => {
	const isAsync = !interop && isAsyncWrapper(block);
	const type = interop ? block.vnode.type : block.type;
	if (isAsync && !type.__asyncResolved) return false;
	const { include, exclude } = props;
	const name = getComponentName(isAsync ? type.__asyncResolved : type);
	return !(include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name));
};
const resetCachedShapeFlag = (cached) => {
	if (isVaporComponent(cached)) resetShapeFlag(cached);
	else resetShapeFlag(cached.vnode);
};
function getInnerBlock(block) {
	if (isVaporComponent(block)) return [block, false];
	else if (isInteropFragment(block)) return [block, true];
	else if (isFragment(block)) return getInnerBlock(block.nodes);
	return [void 0, false];
}
function isInteropFragment(block) {
	return !!(isFragment(block) && block.vnode);
}
function getInstanceFromCache(cached) {
	if (isVaporComponent(cached)) return cached;
	return cached.vnode.component;
}
function activate$1(instance, parentNode, anchor) {
	move(instance.block, parentNode, anchor, 0, instance);
	queuePostFlushCb(() => {
		instance.isDeactivated = false;
		if (instance.a) invokeArrayFns(instance.a);
	});
	if (!!(process.env.NODE_ENV !== "production") || __VUE_PROD_DEVTOOLS__) devtoolsComponentAdded(instance);
}
function deactivate$1(instance, container) {
	move(instance.block, container, null, 1, instance);
	queuePostFlushCb(() => {
		if (instance.da) invokeArrayFns(instance.da);
		instance.isDeactivated = true;
	});
	if (!!(process.env.NODE_ENV !== "production") || __VUE_PROD_DEVTOOLS__) devtoolsComponentAdded(instance);
}

//#endregion
//#region packages/runtime-vapor/src/components/Suspense.ts
let parentSuspense = null;
function setParentSuspense(suspense) {
	try {
		return parentSuspense;
	} finally {
		parentSuspense = suspense;
	}
}

//#endregion
//#region packages/runtime-vapor/src/vdomInterop.ts
const interopKey = Symbol(`interop`);
const vaporInteropImpl = {
	mount(vnode, container, anchor, parentComponent, parentSuspense, onBeforeMount) {
		let selfAnchor = vnode.anchor = /* @__PURE__ */ createTextNode();
		if (isHydrating$1) queuePostFlushCb(() => container.insertBefore(selfAnchor, anchor));
		else {
			vnode.el = selfAnchor;
			container.insertBefore(selfAnchor, anchor);
		}
		const prev = currentInstance;
		simpleSetCurrentInstance(parentComponent);
		const props = {};
		for (const key in vnode.props) if (!isReservedProp(key)) props[key] = vnode.props[key];
		const propsRef = shallowRef(props);
		const slotsRef = shallowRef(vnode.children);
		let prevSuspense = null;
		if (parentSuspense) prevSuspense = setParentSuspense(parentSuspense);
		const dynamicPropSource = [() => propsRef.value];
		dynamicPropSource[interopKey] = true;
		const instance = vnode.component = createComponent(vnode.type, { $: dynamicPropSource }, { _: slotsRef }, void 0, void 0, parentComponent ? parentComponent.appContext : vnode.appContext);
		instance.rawPropsRef = propsRef;
		instance.rawSlotsRef = slotsRef;
		if (isKeepAlive(parentComponent)) instance.shapeFlag = vnode.shapeFlag;
		if (vnode.transition) setTransitionHooks$1(instance, vnode.transition);
		if (parentSuspense) setParentSuspense(prevSuspense);
		const rootEl = getRootElement(instance);
		if (rootEl) vnode.el = rootEl;
		if (vnode.dirs) if (rootEl) onBeforeMount && onBeforeMount();
		else {
			if (!!(process.env.NODE_ENV !== "production")) warn("Runtime directive used on component with non-element root node. The directives will not function as intended.");
			vnode.dirs = null;
		}
		mountComponent(instance, container, selfAnchor);
		simpleSetCurrentInstance(prev);
		return instance;
	},
	update(n1, n2, shouldUpdate, onBeforeUpdate) {
		n2.component = n1.component;
		n2.el = n2.anchor = n1.anchor;
		const instance = n2.component;
		const rootEl = getRootElement(instance);
		if (rootEl) n2.el = rootEl;
		if (n2.dirs) if (rootEl) onBeforeUpdate && onBeforeUpdate();
		else n2.dirs = null;
		if (shouldUpdate) {
			instance.rawPropsRef.value = n2.props;
			instance.rawSlotsRef.value = n2.children;
		}
	},
	unmount(vnode, doRemove) {
		const container = doRemove ? vnode.anchor.parentNode : void 0;
		const instance = vnode.component;
		if (instance) {
			if (instance.block) unmountComponent(instance, container);
		} else if (vnode.vb) remove(vnode.vb, container);
		remove(vnode.anchor, container);
	},
	slot(n1, n2, container, anchor, parentComponent) {
		if (!n1) {
			const prev = currentInstance;
			simpleSetCurrentInstance(parentComponent);
			let selfAnchor;
			const { slot, fallback } = n2.vs;
			const propsRef = n2.vs.ref = shallowRef(n2.props);
			const slotBlock = slot(new Proxy(propsRef, vaporSlotPropsProxyHandler));
			if (fallback && isFragment(slotBlock)) {
				setFragmentFallback(slotBlock, createFallback(fallback));
				selfAnchor = slotBlock.anchor;
			}
			simpleSetCurrentInstance(prev);
			if (!selfAnchor) selfAnchor = /* @__PURE__ */ createTextNode();
			insert(n2.el = n2.anchor = selfAnchor, container, anchor);
			insert(n2.vb = slotBlock, container, selfAnchor);
		} else {
			n2.el = n2.anchor = n1.anchor;
			n2.vb = n1.vb;
			(n2.vs.ref = n1.vs.ref).value = n2.props;
		}
	},
	move(vnode, container, anchor, moveType) {
		move(vnode.vb || vnode.component, container, anchor, moveType);
		move(vnode.anchor, container, anchor, moveType);
	},
	hydrate(vnode, node, container, anchor, parentComponent, parentSuspense) {
		if (!isHydrating$1 && !isHydrating) return node;
		hydrateNode(node, () => this.mount(vnode, container, anchor, parentComponent, parentSuspense));
		return /* @__PURE__ */ _next(node);
	},
	hydrateSlot(vnode, node) {
		if (!isHydrating$1 && !isHydrating) return node;
		const { slot } = vnode.vs;
		const propsRef = vnode.vs.ref = shallowRef(vnode.props);
		hydrateNode(node, () => {
			vnode.vb = slot(new Proxy(propsRef, vaporSlotPropsProxyHandler));
			vnode.anchor = vnode.el = currentHydrationNode;
			if (!!(process.env.NODE_ENV !== "production") && !vnode.anchor) throw new Error(`Failed to locate slot anchor. this is likely a Vue internal bug.`);
		});
		return vnode.anchor;
	},
	setTransitionHooks(component, hooks) {
		setTransitionHooks$1(component, hooks);
	},
	activate(vnode, container, anchor, parentComponent) {
		const cached = parentComponent.ctx.getCachedComponent(vnode);
		vnode.el = cached.el;
		vnode.component = cached.component;
		vnode.anchor = cached.anchor;
		activate$1(vnode.component, container, anchor);
		insert(vnode.anchor, container, anchor);
	},
	deactivate(vnode, container) {
		deactivate$1(vnode.component, container);
		insert(vnode.anchor, container);
	}
};
const vaporSlotPropsProxyHandler = {
	get(target, key) {
		return target.value[key];
	},
	has(target, key) {
		return target.value[key];
	},
	ownKeys(target) {
		return Object.keys(target.value);
	}
};
const vaporSlotsProxyHandler = { get(target, key) {
	const slot = target[key];
	if (isFunction(slot)) {
		slot.__vapor = true;
		const wrapped = (props) => [renderSlot({ [key]: slot }, key, props)];
		wrapped.__vs = slot;
		return wrapped;
	}
	return slot;
} };
let vdomHydrateNode;
/**
* Mount VNode in vapor
*/
function mountVNode(internals, vnode, parentComponent) {
	const frag = new VaporFragment([]);
	frag.vnode = vnode;
	let isMounted = false;
	const unmount = (parentNode, transition) => {
		if (transition) setTransitionHooks(vnode, transition);
		if (vnode.shapeFlag & 256) if (vnode.type.__vapor) deactivate$1(vnode.component, parentComponent.ctx.getStorageContainer());
		else deactivate(vnode, parentComponent.ctx.getStorageContainer(), internals, parentComponent, null);
		else internals.um(vnode, parentComponent, null, !!parentNode);
	};
	frag.hydrate = () => {
		if (!isHydrating$1) return;
		hydrateVNode(vnode, parentComponent);
		onScopeDispose(unmount, true);
		isMounted = true;
		frag.nodes = vnode.el;
	};
	frag.insert = (parentNode, anchor, transition) => {
		if (isHydrating$1) return;
		if (vnode.shapeFlag & 512) {
			if (vnode.type.__vapor) activate$1(vnode.component, parentNode, anchor);
			else activate(vnode, parentNode, anchor, internals, parentComponent, null, void 0, false);
			return;
		} else {
			const prev = currentInstance;
			simpleSetCurrentInstance(parentComponent);
			if (!isMounted) {
				if (transition) setTransitionHooks(vnode, transition);
				internals.p(null, vnode, parentNode, anchor, parentComponent, null, void 0, vnode.slotScopeIds);
				onScopeDispose(unmount, true);
				isMounted = true;
			} else internals.m(vnode, parentNode, anchor, 2, parentComponent);
			simpleSetCurrentInstance(prev);
		}
		frag.nodes = vnode.el;
		if (isMounted && frag.onUpdated) frag.onUpdated.forEach((m) => m());
	};
	frag.remove = unmount;
	return frag;
}
/**
* Mount vdom component in vapor
*/
function createVDOMComponent(internals, component, parentComponent, rawProps, rawSlots, isSingleRoot) {
	const frag = new VaporFragment([]);
	const vnode = frag.vnode = createVNode(component, rawProps && extend({}, new Proxy(rawProps, rawPropsProxyHandlers)));
	if (currentKeepAliveCtx) {
		currentKeepAliveCtx.processShapeFlag(frag);
		setCurrentKeepAliveCtx(null);
	}
	const wrapper = new VaporComponentInstance({ props: component.props }, rawProps, rawSlots, parentComponent ? parentComponent.appContext : void 0, void 0);
	vnode.vi = (instance) => {
		instance.props = shallowReactive(wrapper.props);
		const attrs = instance.attrs = createInternalObject();
		for (const key in wrapper.attrs) if (!isEmitListener(instance.emitsOptions, key)) attrs[key] = wrapper.attrs[key];
		instance.slots = wrapper.slots === EMPTY_OBJ ? EMPTY_OBJ : new Proxy(wrapper.slots, vaporSlotsProxyHandler);
	};
	let rawRef = null;
	let isMounted = false;
	const unmount = (parentNode, transition) => {
		if (rawRef) setRef(rawRef, null, null, vnode, true);
		if (transition) setTransitionHooks(vnode, transition);
		if (vnode.shapeFlag & 256) {
			deactivate(vnode, parentComponent.ctx.getStorageContainer(), internals, parentComponent, null);
			return;
		}
		internals.umt(vnode.component, null, !!parentNode);
	};
	frag.hydrate = () => {
		if (!isHydrating$1) return;
		hydrateVNode(vnode, parentComponent, !isSingleRoot);
		onScopeDispose(unmount, true);
		isMounted = true;
		frag.nodes = vnode.el;
	};
	vnode.scopeId = getCurrentScopeId() || null;
	vnode.slotScopeIds = currentSlotScopeIds;
	frag.insert = (parentNode, anchor, transition) => {
		if (isHydrating$1) return;
		if (vnode.shapeFlag & 512) activate(vnode, parentNode, anchor, internals, parentComponent, null, void 0, false);
		else {
			const prev = currentInstance;
			simpleSetCurrentInstance(parentComponent);
			if (!isMounted) {
				if (transition) setTransitionHooks(vnode, transition);
				internals.mt(vnode, parentNode, anchor, parentComponent, null, void 0, false);
				if (rawRef) setRef(rawRef, null, null, vnode);
				onScopeDispose(unmount, true);
				isMounted = true;
			} else internals.m(vnode, parentNode, anchor, 2, parentComponent);
			simpleSetCurrentInstance(prev);
		}
		frag.nodes = vnode.el;
		if (isMounted && frag.onUpdated) frag.onUpdated.forEach((m) => m());
	};
	frag.remove = unmount;
	frag.setRef = (instance, ref, refFor, refKey) => {
		rawRef = normalizeRef({
			ref,
			ref_for: refFor,
			ref_key: refKey
		}, instance);
		if (isMounted && rawRef) setRef(rawRef, null, null, vnode);
	};
	return frag;
}
/**
* Mount vdom slot in vapor
*/
function renderVDOMSlot(internals, slotsRef, name, props, parentComponent, fallback) {
	const frag = new VaporFragment([]);
	let isMounted = false;
	let fallbackNodes;
	let oldVNode = null;
	frag.fallback = fallback;
	frag.insert = (parentNode, anchor) => {
		if (isHydrating$1) return;
		if (!isMounted) {
			render(parentNode, anchor);
			isMounted = true;
		} else internals.m(oldVNode, parentNode, anchor, 2, parentComponent);
		frag.remove = (parentNode) => {
			if (fallbackNodes) remove(fallbackNodes, parentNode);
			else if (oldVNode) internals.um(oldVNode, parentComponent, null);
		};
		if (isMounted && frag.onUpdated) frag.onUpdated.forEach((m) => m());
	};
	const render = (parentNode, anchor) => {
		renderEffect(() => {
			let vnode;
			let isValidSlot = false;
			if (slotsRef.value) {
				vnode = renderSlot(slotsRef.value, isFunction(name) ? name() : name, props);
				let children = vnode.children;
				ensureVaporSlotFallback(children, fallback);
				isValidSlot = children.length > 0;
			}
			if (isValidSlot) if (isHydrating$1) {
				if (isVNode(vnode)) {
					hydrateVNode(vnode, parentComponent);
					oldVNode = vnode;
					frag.nodes = vnode.el;
				}
			} else {
				if (fallbackNodes) {
					remove(fallbackNodes, parentNode);
					fallbackNodes = void 0;
				}
				internals.p(oldVNode, vnode, parentNode, anchor, parentComponent, null, void 0, vnode.slotScopeIds);
				oldVNode = vnode;
				frag.nodes = vnode.el;
			}
			else {
				fallback = frag.fallback;
				if (fallback && !fallbackNodes) {
					fallbackNodes = fallback(internals, parentComponent);
					if (isHydrating$1) {
						if (isVNode(fallbackNodes)) {
							hydrateVNode(fallbackNodes, parentComponent);
							frag.nodes = fallbackNodes.el;
						}
					} else {
						if (oldVNode) internals.um(oldVNode, parentComponent, null, true);
						insert(fallbackNodes, parentNode, anchor);
						frag.nodes = fallbackNodes;
					}
				}
				oldVNode = null;
			}
		});
	};
	frag.hydrate = () => {
		if (!isHydrating$1) return;
		render();
		isMounted = true;
	};
	return frag;
}
const vaporInteropPlugin = (app) => {
	const internals = ensureRenderer().internals;
	app._context.vapor = extend(vaporInteropImpl, {
		vdomMount: createVDOMComponent.bind(null, internals),
		vdomUnmount: internals.umt,
		vdomSlot: renderVDOMSlot.bind(null, internals),
		vdomMountVNode: mountVNode.bind(null, internals)
	});
	const mount = app.mount;
	app.mount = ((...args) => {
		optimizePropertyLookup();
		return mount(...args);
	});
};
function hydrateVNode(vnode, parentComponent, skipFragmentAnchor = false) {
	locateHydrationNode();
	let node = currentHydrationNode;
	if (skipFragmentAnchor && isComment(node, "[")) setCurrentHydrationNode(node = node.nextSibling);
	if (!vdomHydrateNode) vdomHydrateNode = ensureHydrationRenderer().hydrateNode;
	const nextNode = vdomHydrateNode(node, vnode, parentComponent, null, null, false);
	if (nextNode) setCurrentHydrationNode(nextNode);
	else advanceHydrationNode(node);
}
const createFallback = (fallback) => (internals, parentComponent) => {
	const fallbackNodes = fallback();
	if (isArray(fallbackNodes) && fallbackNodes.every(isVNode)) {
		const frag = new VaporFragment([]);
		frag.insert = (parentNode, anchor) => {
			fallbackNodes.forEach((vnode) => {
				internals.p(null, vnode, parentNode, anchor, parentComponent);
			});
		};
		frag.remove = (parentNode) => {
			fallbackNodes.forEach((vnode) => {
				internals.um(vnode, parentComponent, null, true);
			});
		};
		return frag;
	}
	return fallbackNodes;
};

//#endregion
//#region packages/runtime-vapor/src/componentEmits.ts
/**
* The logic from core isn't too reusable so it's better to duplicate here
*/
function normalizeEmitsOptions(comp) {
	const cached = comp.__emitsOptions;
	if (cached) return cached;
	const raw = comp.emits;
	if (!raw) return null;
	let normalized;
	if (isArray(raw)) {
		normalized = {};
		for (const key of raw) normalized[key] = null;
	} else normalized = raw;
	return comp.__emitsOptions = normalized;
}
function emit(instance, event, ...rawArgs) {
	baseEmit(instance, instance.rawProps || EMPTY_OBJ, propGetter, event, ...rawArgs);
}
function propGetter(rawProps, key) {
	const dynamicSources = rawProps.$;
	if (dynamicSources) {
		let i = dynamicSources.length;
		while (i--) {
			const source = resolveSource(dynamicSources[i]);
			if (hasOwn(source, key)) return dynamicSources[interopKey] || isOn(key) ? source[key] : resolveSource(source[key]);
		}
	}
	return rawProps[key] && resolveSource(rawProps[key]);
}

//#endregion
//#region packages/runtime-vapor/src/componentProps.ts
function resolveSource(source) {
	return isFunction(source) ? resolveFunctionSource(source) : source;
}
function resolveFunctionSource(source) {
	if (source._cache) return source._cache.value;
	const parent = currentInstance && currentInstance.parent;
	if (parent) {
		source._cache = computed(() => {
			const prev = setCurrentInstance(parent);
			try {
				return source();
			} finally {
				setCurrentInstance(...prev);
			}
		});
		onScopeDispose$1(() => source._cache = void 0);
		return source._cache.value;
	}
	return source();
}
function getPropsProxyHandlers(comp, once) {
	if (comp.__propsHandlers) return comp.__propsHandlers;
	const propsOptions = normalizePropsOptions(comp)[0];
	const emitsOptions = normalizeEmitsOptions(comp);
	const isProp = propsOptions ? (key) => isString(key) && hasOwn(propsOptions, camelize(key)) : NO;
	const isAttr = propsOptions ? (key) => key !== "$" && !isProp(key) && !isEmitListener(emitsOptions, key) : YES;
	const getProp = (instance, key) => {
		if (key === "__v_isReactive") return true;
		if (!isProp(key)) return;
		const rawProps = instance.rawProps;
		const dynamicSources = rawProps.$;
		if (dynamicSources) {
			let i = dynamicSources.length;
			let source, isDynamic, rawKey;
			while (i--) {
				source = dynamicSources[i];
				isDynamic = isFunction(source);
				source = isDynamic ? resolveFunctionSource(source) : source;
				for (rawKey in source) if (camelize(rawKey) === key) return resolvePropValue(propsOptions, key, isDynamic ? source[rawKey] : resolveFunctionSource(source[rawKey]), instance, resolveDefault);
			}
		}
		for (const rawKey in rawProps) if (camelize(rawKey) === key) return resolvePropValue(propsOptions, key, resolveSource(rawProps[rawKey]), instance, resolveDefault);
		return resolvePropValue(propsOptions, key, void 0, instance, resolveDefault, true);
	};
	const withOnceCache = (getter) => {
		return ((instance, key) => {
			const cache = instance.oncePropsCache || (instance.oncePropsCache = {});
			if (!(key in cache)) {
				pauseTracking();
				try {
					cache[key] = getter(instance, key);
				} finally {
					resetTracking();
				}
			}
			return cache[key];
		});
	};
	const getOnceProp = withOnceCache(getProp);
	const propsHandlers = propsOptions ? {
		get: (target, key) => (once ? getOnceProp : getProp)(target, key),
		has: (_, key) => isProp(key),
		ownKeys: () => Object.keys(propsOptions),
		getOwnPropertyDescriptor(target, key) {
			if (isProp(key)) return {
				configurable: true,
				enumerable: true,
				get: () => (once ? getOnceProp : getProp)(target, key)
			};
		}
	} : null;
	if (!!(process.env.NODE_ENV !== "production") && propsOptions) Object.assign(propsHandlers, {
		set: propsSetDevTrap,
		deleteProperty: propsDeleteDevTrap
	});
	const getAttr = (target, key) => {
		if (!isProp(key) && !isEmitListener(emitsOptions, key)) return getAttrFromRawProps(target, key);
	};
	const hasAttr = (target, key) => {
		if (isAttr(key)) return hasAttrFromRawProps(target, key);
		else return false;
	};
	const getOnceAttr = withOnceCache((instance, key) => getAttr(instance.rawProps, key));
	const attrsHandlers = {
		get: (target, key) => once ? getOnceAttr(target, key) : getAttr(target.rawProps, key),
		has: (target, key) => hasAttr(target.rawProps, key),
		ownKeys: (target) => getKeysFromRawProps(target.rawProps).filter(isAttr),
		getOwnPropertyDescriptor(target, key) {
			if (hasAttr(target.rawProps, key)) return {
				configurable: true,
				enumerable: true,
				get: () => once ? getOnceAttr(target, key) : getAttr(target.rawProps, key)
			};
		}
	};
	if (!!(process.env.NODE_ENV !== "production")) Object.assign(attrsHandlers, {
		set: propsSetDevTrap,
		deleteProperty: propsDeleteDevTrap
	});
	return comp.__propsHandlers = [propsHandlers, attrsHandlers];
}
function getAttrFromRawProps(rawProps, key) {
	if (key === "$") return;
	const merged = key === "class" || key === "style" ? [] : void 0;
	const dynamicSources = rawProps.$;
	if (dynamicSources) {
		let i = dynamicSources.length;
		let source, isDynamic;
		while (i--) {
			source = dynamicSources[i];
			isDynamic = isFunction(source);
			source = isDynamic ? resolveFunctionSource(source) : source;
			if (source && hasOwn(source, key)) {
				const value = isDynamic ? source[key] : resolveFunctionSource(source[key]);
				if (merged) merged.push(value);
				else return value;
			}
		}
	}
	if (hasOwn(rawProps, key)) {
		const value = resolveSource(rawProps[key]);
		if (merged) merged.push(value);
		else return value;
	}
	if (merged && merged.length) return merged;
}
function hasAttrFromRawProps(rawProps, key) {
	if (key === "$") return false;
	const dynamicSources = rawProps.$;
	if (dynamicSources) {
		let i = dynamicSources.length;
		while (i--) {
			const source = resolveSource(dynamicSources[i]);
			if (source && hasOwn(source, key)) return true;
		}
	}
	return hasOwn(rawProps, key);
}
function getKeysFromRawProps(rawProps) {
	const keys = [];
	for (const key in rawProps) if (key !== "$") keys.push(key);
	const dynamicSources = rawProps.$;
	if (dynamicSources) {
		let i = dynamicSources.length;
		let source;
		while (i--) {
			source = isFunction(dynamicSources[i]) ? resolveFunctionSource(dynamicSources[i]) : dynamicSources[i];
			for (const key in source) keys.push(key);
		}
	}
	return Array.from(new Set(keys));
}
function normalizePropsOptions(comp) {
	const cached = comp.__propsOptions;
	if (cached) return cached;
	const raw = comp.props;
	if (!raw) return EMPTY_ARR;
	const normalized = {};
	const needCastKeys = [];
	baseNormalizePropsOptions(raw, normalized, needCastKeys);
	return comp.__propsOptions = [normalized, needCastKeys];
}
function resolveDefault(factory, instance) {
	const prev = setCurrentInstance(instance);
	const res = factory.call(null, instance.props);
	setCurrentInstance(...prev);
	return res;
}
function hasFallthroughAttrs(comp, rawProps) {
	if (rawProps) if (rawProps.$ || !comp.props) return true;
	else {
		const propsOptions = normalizePropsOptions(comp)[0];
		for (const key in rawProps) if (!hasOwn(propsOptions, camelize(key))) return true;
	}
	return false;
}
/**
* dev only
*/
function setupPropsValidation(instance) {
	const rawProps = instance.rawProps;
	if (!rawProps) return;
	renderEffect(() => {
		pushWarningContext(instance);
		validateProps(resolveDynamicProps(rawProps), instance.props, normalizePropsOptions(instance.type)[0]);
		popWarningContext();
	}, true);
}
function resolveDynamicProps(props) {
	const mergedRawProps = {};
	for (const key in props) if (key !== "$") mergedRawProps[key] = resolveSource(props[key]);
	if (props.$) for (const source of props.$) {
		const isDynamic = isFunction(source);
		const resolved = isDynamic ? resolveFunctionSource(source) : source;
		for (const key in resolved) {
			const value = isDynamic ? resolved[key] : resolveFunctionSource(source[key]);
			if (key === "class" || key === "style") {
				const existing = mergedRawProps[key];
				if (isArray(existing)) existing.push(value);
				else mergedRawProps[key] = [existing, value];
			} else mergedRawProps[key] = value;
		}
	}
	return mergedRawProps;
}
function propsSetDevTrap(_, key) {
	warn(`Attempt to mutate prop ${JSON.stringify(key)} failed. Props are readonly.`);
	return true;
}
function propsDeleteDevTrap(_, key) {
	warn(`Attempt to delete prop ${JSON.stringify(key)} failed. Props are readonly.`);
	return true;
}
const rawPropsProxyHandlers = {
	get: getAttrFromRawProps,
	has: hasAttrFromRawProps,
	ownKeys: getKeysFromRawProps,
	getOwnPropertyDescriptor(target, key) {
		if (hasAttrFromRawProps(target, key)) return {
			configurable: true,
			enumerable: true,
			get: () => getAttrFromRawProps(target, key)
		};
	}
};

//#endregion
//#region packages/runtime-vapor/src/componentSlots.ts
/**
* Flag to indicate if we are executing a once slot.
* When true, renderEffect should skip creating reactive effect.
*/
let inOnceSlot = false;
/**
* Current slot scopeIds for vdom interop
*/
let currentSlotScopeIds = null;
function setCurrentSlotScopeIds(scopeIds) {
	try {
		return currentSlotScopeIds;
	} finally {
		currentSlotScopeIds = scopeIds;
	}
}
const dynamicSlotsProxyHandlers = {
	get: getSlot,
	has: (target, key) => !!getSlot(target, key),
	getOwnPropertyDescriptor(target, key) {
		const slot = getSlot(target, key);
		if (slot) return {
			configurable: true,
			enumerable: true,
			value: slot
		};
	},
	ownKeys(target) {
		let keys = Object.keys(target);
		const dynamicSources = target.$;
		if (dynamicSources) {
			keys = keys.filter((k) => k !== "$");
			for (const source of dynamicSources) if (isFunction(source)) {
				const slot = resolveFunctionSource(source);
				if (slot) if (isArray(slot)) for (const s of slot) keys.push(String(s.name));
				else keys.push(String(slot.name));
			} else keys.push(...Object.keys(source));
		}
		return keys;
	},
	set: NO,
	deleteProperty: NO
};
function getSlot(target, key) {
	if (key === "$") return;
	const dynamicSources = target.$;
	if (dynamicSources) {
		let i = dynamicSources.length;
		let source;
		while (i--) {
			source = dynamicSources[i];
			if (isFunction(source)) {
				const slot = resolveFunctionSource(source);
				if (slot) {
					if (isArray(slot)) {
						for (const s of slot) if (String(s.name) === key) return s.fn;
					} else if (String(slot.name) === key) return slot.fn;
				}
			} else if (hasOwn(source, key)) return source[key];
		}
	}
	if (hasOwn(target, key)) return target[key];
}
/**
* Tracks the slot owner (the component that defines the slot content).
* This is used for:
* 1. Getting the correct rawSlots in forwarded slots (via createSlot)
* 2. Inheriting the slot owner's scopeId
*/
let currentSlotOwner = null;
function setCurrentSlotOwner(owner) {
	try {
		return currentSlotOwner;
	} finally {
		currentSlotOwner = owner;
	}
}
/**
* Get the effective slot instance for accessing rawSlots and scopeId.
* Prefers currentSlotOwner (if inside a slot), falls back to currentInstance.
*/
function getScopeOwner() {
	return currentSlotOwner || currentInstance;
}
/**
* Wrap a slot function to track the slot owner.
*
* This ensures:
* 1. createSlot gets rawSlots from the correct component (slot owner)
* 2. Elements inherit the slot owner's scopeId
*/
function withVaporCtx(fn) {
	const owner = getScopeOwner();
	return (...args) => {
		const prevOwner = setCurrentSlotOwner(owner);
		try {
			return fn(...args);
		} finally {
			setCurrentSlotOwner(prevOwner);
		}
	};
}
function createSlot(name, rawProps, fallback, noSlotted, once) {
	const _insertionParent = insertionParent;
	const _insertionAnchor = insertionAnchor;
	const _isLastInsertion = isLastInsertion;
	if (!isHydrating$1) resetInsertionState();
	const instance = getScopeOwner();
	const rawSlots = instance.rawSlots;
	const slotProps = rawProps ? new Proxy(rawProps, rawPropsProxyHandlers) : EMPTY_OBJ;
	let fragment;
	if (isRef(rawSlots._)) {
		if (isHydrating$1) locateHydrationNode();
		fragment = instance.appContext.vapor.vdomSlot(rawSlots._, name, slotProps, instance, fallback);
	} else {
		fragment = isHydrating$1 || !!(process.env.NODE_ENV !== "production") ? new DynamicFragment("slot") : new DynamicFragment();
		const isDynamicName = isFunction(name);
		const slotScopeIds = [];
		if (!noSlotted) {
			const scopeId = instance.type.__scopeId;
			if (scopeId) slotScopeIds.push(`${scopeId}-s`);
		}
		const renderSlot = () => {
			const slotName = isFunction(name) ? name() : name;
			if (instance.ce || instance.parent && isAsyncWrapper(instance.parent) && instance.parent.ce) {
				const el = /* @__PURE__ */ createElement("slot");
				renderEffect(() => {
					setDynamicProps(el, [slotProps, slotName !== "default" ? { name: slotName } : {}]);
				});
				if (fallback) insert(fallback(), el);
				fragment.nodes = el;
				return;
			}
			const slot = getSlot(rawSlots, slotName);
			if (slot) {
				fragment.fallback = fallback;
				fragment.update(slot._bound || (slot._bound = () => {
					const prevSlotScopeIds = setCurrentSlotScopeIds(slotScopeIds.length > 0 ? slotScopeIds : null);
					const prev = inOnceSlot;
					try {
						if (once) inOnceSlot = true;
						return slot(slotProps);
					} finally {
						inOnceSlot = prev;
						setCurrentSlotScopeIds(prevSlotScopeIds);
					}
				}));
			} else fragment.update(fallback);
		};
		if (!once && (isDynamicName || rawSlots.$)) renderEffect(renderSlot);
		else renderSlot();
	}
	if (!isHydrating$1) {
		if (!noSlotted) {
			const scopeId = instance.type.__scopeId;
			if (scopeId) setScopeId(fragment, [`${scopeId}-s`]);
		}
		if (_insertionParent) insert(fragment, _insertionParent, _insertionAnchor);
	} else {
		if (fragment.insert) fragment.hydrate();
		if (_isLastInsertion) advanceHydrationNode(_insertionParent);
	}
	return fragment;
}

//#endregion
//#region packages/runtime-vapor/src/renderEffect.ts
var RenderEffect = class extends ReactiveEffect {
	constructor(render) {
		super();
		this.render = render;
		const instance = currentInstance;
		if (!!(process.env.NODE_ENV !== "production") && !this.subs && !isVaporComponent(instance)) warn("renderEffect called without active EffectScope or Vapor instance.");
		const job = () => {
			if (this.dirty) this.run();
		};
		this.updateJob = () => {
			instance.isUpdating = false;
			instance.u && invokeArrayFns(instance.u);
		};
		if (instance) {
			if (!!(process.env.NODE_ENV !== "production")) {
				this.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
				this.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
			}
			if (instance.type.ce) (instance.renderEffects || (instance.renderEffects = [])).push(this);
			job.i = instance;
		}
		this.job = job;
		this.i = instance;
	}
	fn() {
		const instance = this.i;
		const scope = this.subs ? this.subs.sub : void 0;
		const hasUpdateHooks = instance && (instance.bu || instance.u);
		if (!!(process.env.NODE_ENV !== "production") && instance) startMeasure(instance, `renderEffect`);
		const prev = setCurrentInstance(instance, scope);
		if (hasUpdateHooks && instance.isMounted && !instance.isUpdating) {
			instance.isUpdating = true;
			instance.bu && invokeArrayFns(instance.bu);
			this.render();
			queuePostFlushCb(this.updateJob);
		} else this.render();
		setCurrentInstance(...prev);
		if (!!(process.env.NODE_ENV !== "production") && instance) startMeasure(instance, `renderEffect`);
	}
	notify() {
		if (!(this.flags & 256)) queueJob(this.job, this.i ? this.i.uid : void 0);
	}
};
function renderEffect(fn, noLifecycle = false) {
	if (inOnceSlot) return fn();
	const effect = new RenderEffect(fn);
	if (noLifecycle) effect.fn = fn;
	effect.run();
}

//#endregion
//#region packages/runtime-vapor/src/fragment.ts
var VaporFragment = class {
	constructor(nodes) {
		this.vnode = null;
		this.nodes = nodes;
	}
};
var ForFragment = class extends VaporFragment {
	constructor(nodes) {
		super(nodes);
	}
};
var DynamicFragment = class extends VaporFragment {
	constructor(anchorLabel, keyed = false) {
		super([]);
		this.hydrate = (isEmpty = false) => {
			if (!isHydrating$1) return;
			if (this.anchor) return;
			if (this.anchorLabel === "if") {
				if (isEmpty) {
					this.anchor = locateFragmentEndAnchor("");
					if (!!(process.env.NODE_ENV !== "production") && !this.anchor) throw new Error("Failed to locate if anchor. this is likely a Vue internal bug.");
					else {
						if (!!(process.env.NODE_ENV !== "production")) this.anchor.data = this.anchorLabel;
						return;
					}
				}
			} else if (this.anchorLabel === "slot") {
				if (isEmpty && isComment(currentHydrationNode, "")) {
					this.anchor = currentHydrationNode;
					if (!!(process.env.NODE_ENV !== "production")) this.anchor.data = this.anchorLabel;
					return;
				}
				this.anchor = locateFragmentEndAnchor();
				if (!!(process.env.NODE_ENV !== "production") && !this.anchor) throw new Error("Failed to locate slot anchor. this is likely a Vue internal bug.");
				else return;
			}
			const { parentNode: pn, nextNode } = findBlockNode(this.nodes);
			queuePostFlushCb(() => {
				pn.insertBefore(this.anchor = !!(process.env.NODE_ENV !== "production") ? /* @__PURE__ */ createComment(this.anchorLabel) : /* @__PURE__ */ createTextNode(), nextNode);
			});
		};
		this.keyed = keyed;
		this.slotOwner = currentSlotOwner;
		this.keepAliveCtx = currentKeepAliveCtx;
		if (isHydrating$1) {
			this.anchorLabel = anchorLabel;
			locateHydrationNode();
		} else {
			this.anchor = !!(process.env.NODE_ENV !== "production") && anchorLabel ? /* @__PURE__ */ createComment(anchorLabel) : /* @__PURE__ */ createTextNode();
			if (!!(process.env.NODE_ENV !== "production")) this.anchorLabel = anchorLabel;
		}
	}
	update(render, key = render) {
		if (key === this.current) {
			if (isHydrating$1) this.hydrate(true);
			return;
		}
		const transition = this.$transition;
		if (transition && transition.state.isLeaving) {
			this.current = key;
			this.pending = {
				render,
				key
			};
			return;
		}
		const prevKey = this.current;
		this.current = key;
		const instance = currentInstance;
		const prevSub = setActiveSub();
		const parent = isHydrating$1 ? null : this.anchor.parentNode;
		if (this.scope) {
			let retainScope = false;
			const keepAliveCtx = this.keepAliveCtx;
			if (keepAliveCtx && keepAliveCtx.processShapeFlag(this.nodes)) {
				keepAliveCtx.cacheScope(prevKey, this.scope);
				retainScope = true;
			}
			if (!retainScope) this.scope.stop();
			const mode = transition && transition.mode;
			if (mode) {
				applyTransitionLeaveHooks(this.nodes, transition, () => {
					const pending = this.pending;
					if (pending) {
						this.pending = void 0;
						this.current = pending.key;
						this.renderBranch(pending.render, transition, parent, instance);
					} else this.renderBranch(render, transition, parent, instance);
				});
				parent && remove(this.nodes, parent);
				if (mode === "out-in") {
					setActiveSub(prevSub);
					return;
				}
			} else parent && remove(this.nodes, parent);
		}
		this.renderBranch(render, transition, parent, instance);
		if (this.fallback) {
			let invalidFragment = null;
			if (isFragment(this.nodes)) setFragmentFallback(this.nodes, this.fallback, (frag) => {
				if (!isValidBlock(frag.nodes)) invalidFragment = frag;
			});
			if (!invalidFragment && !isValidBlock(this.nodes)) invalidFragment = this;
			if (invalidFragment) {
				parent && remove(this.nodes, parent);
				(this.scope || (this.scope = new EffectScope$1())).run(() => {
					if (invalidFragment !== this) renderFragmentFallback(invalidFragment);
					else this.nodes = this.fallback() || [];
				});
				parent && insert(this.nodes, parent, this.anchor);
			}
		}
		setActiveSub(prevSub);
		if (isHydrating$1) this.hydrate();
	}
	renderBranch(render, transition, parent, instance) {
		if (render) {
			const keepAliveCtx = this.keepAliveCtx;
			const scope = keepAliveCtx && keepAliveCtx.getScope(this.current);
			if (scope) this.scope = scope;
			else this.scope = new EffectScope$1();
			const prevOwner = setCurrentSlotOwner(this.slotOwner);
			const prevCtx = setCurrentKeepAliveCtx(keepAliveCtx);
			const prev = parent && instance ? setCurrentInstance(instance) : void 0;
			this.nodes = this.scope.run(render) || [];
			if (prev !== void 0) setCurrentInstance(...prev);
			setCurrentKeepAliveCtx(prevCtx);
			setCurrentSlotOwner(prevOwner);
			if (this.keyed) setKey(this.nodes, this.current);
			if (transition) this.$transition = applyTransitionHooks(this.nodes, transition);
			if (keepAliveCtx) keepAliveCtx.processShapeFlag(this.nodes);
			if (parent) {
				if (this.attrs) {
					if (this.nodes instanceof Element) this.scope.run(() => {
						renderEffect(() => applyFallthroughProps(this.nodes, this.attrs));
					});
					else if (!!(process.env.NODE_ENV !== "production") && (this.anchorLabel === "slot" || isArray(this.nodes) && this.nodes.length)) warnExtraneousAttributes(this.attrs);
				}
				insert(this.nodes, parent, this.anchor);
				if (keepAliveCtx && transition && transition.mode === "out-in") keepAliveCtx.cacheBlock();
				if (this.onUpdated) this.onUpdated.forEach((hook) => hook(this.nodes));
			}
		} else {
			this.scope = void 0;
			this.nodes = [];
		}
	}
};
function setFragmentFallback(fragment, fallback, onFragment) {
	if (fragment.fallback) {
		const originalFallback = fragment.fallback;
		fragment.fallback = () => {
			const fallbackNodes = originalFallback();
			if (isValidBlock(fallbackNodes)) return fallbackNodes;
			return fallback();
		};
	} else fragment.fallback = fallback;
	if (onFragment) onFragment(fragment);
	if (isFragment(fragment.nodes)) setFragmentFallback(fragment.nodes, fragment.fallback, onFragment);
}
function renderFragmentFallback(fragment) {
	if (fragment instanceof ForFragment) fragment.nodes[0] = [fragment.fallback() || []];
	else if (fragment instanceof DynamicFragment) fragment.update(fragment.fallback);
}
function isFragment(val) {
	return val instanceof VaporFragment;
}
function isDynamicFragment(val) {
	return val instanceof DynamicFragment;
}
function setKey(block, key) {
	if (block instanceof Node) block.$key = key;
	else if (isVaporComponent(block)) setKey(block.block, key);
	else if (isArray(block)) for (const b of block) setKey(b, key);
	else setKey(block.nodes, key);
}

//#endregion
//#region packages/runtime-vapor/src/components/Teleport.ts
const VaporTeleportImpl = {
	name: "VaporTeleport",
	__isTeleport: true,
	__vapor: true,
	process(props, slots) {
		return new TeleportFragment(props, slots);
	}
};
var TeleportFragment = class extends VaporFragment {
	constructor(props, slots) {
		super([]);
		this.__isTeleportFragment = true;
		this.insert = (container, anchor) => {
			if (isHydrating$1) return;
			this.placeholder = !!(process.env.NODE_ENV !== "production") ? /* @__PURE__ */ createComment("teleport start") : /* @__PURE__ */ createTextNode();
			insert(this.placeholder, container, anchor);
			insert(this.anchor, container, anchor);
			this.handlePropsUpdate();
		};
		this.remove = (parent = this.parent) => {
			if (this.nodes) {
				remove(this.nodes, this.mountContainer);
				this.nodes = [];
			}
			if (this.targetStart) {
				remove(this.targetStart, this.target);
				this.targetStart = void 0;
				remove(this.targetAnchor, this.target);
				this.targetAnchor = void 0;
			}
			if (this.anchor) {
				remove(this.anchor, this.anchor.parentNode);
				this.anchor = void 0;
			}
			if (this.placeholder) {
				remove(this.placeholder, parent);
				this.placeholder = void 0;
			}
			this.mountContainer = void 0;
			this.mountAnchor = void 0;
		};
		this.hydrate = () => {
			if (!isHydrating$1) return;
			const target = this.target = resolveTeleportTarget(this.resolvedProps, querySelector);
			const disabled = isTeleportDisabled(this.resolvedProps);
			this.placeholder = currentHydrationNode;
			if (target) {
				const targetNode = target._lpa || target.firstChild;
				if (disabled) this.hydrateDisabledTeleport(targetNode);
				else {
					this.anchor = locateTeleportEndAnchor();
					this.mountContainer = target;
					let targetAnchor = targetNode;
					while (targetAnchor) {
						if (targetAnchor && targetAnchor.nodeType === 8) {
							if (targetAnchor.data === "teleport start anchor") this.targetStart = targetAnchor;
							else if (targetAnchor.data === "teleport anchor") {
								this.mountAnchor = this.targetAnchor = targetAnchor;
								target._lpa = this.targetAnchor && this.targetAnchor.nextSibling;
								break;
							}
						}
						targetAnchor = targetAnchor.nextSibling;
					}
					if (targetNode) setCurrentHydrationNode(targetNode.nextSibling);
					if (!this.targetAnchor) this.mountChildren(target);
					else this.initChildren();
				}
			} else if (disabled) this.hydrateDisabledTeleport(currentHydrationNode);
			updateCssVars(this);
			advanceHydrationNode(this.anchor);
		};
		this.rawProps = props;
		this.rawSlots = slots;
		this.parentComponent = currentInstance;
		this.anchor = isHydrating$1 ? void 0 : !!(process.env.NODE_ENV !== "production") ? /* @__PURE__ */ createComment("teleport end") : /* @__PURE__ */ createTextNode();
		renderEffect(() => {
			this.resolvedProps = extend({}, new Proxy(this.rawProps, rawPropsProxyHandlers));
			this.isDisabled = isTeleportDisabled(this.resolvedProps);
			this.handlePropsUpdate();
		});
		if (!isHydrating$1) this.initChildren();
	}
	get parent() {
		return this.anchor ? this.anchor.parentNode : null;
	}
	initChildren() {
		renderEffect(() => {
			this.handleChildrenUpdate(this.rawSlots.default && this.rawSlots.default());
		});
		const nodes = this.nodes;
		if (this.parentComponent && this.parentComponent.ut) this.registerUpdateCssVars(nodes);
		if (!!(process.env.NODE_ENV !== "production")) {
			if (isVaporComponent(nodes)) nodes.parentTeleport = this;
			else if (isArray(nodes)) nodes.forEach((node) => isVaporComponent(node) && (node.parentTeleport = this));
		}
	}
	registerUpdateCssVars(block) {
		if (isFragment(block)) {
			(block.onUpdated || (block.onUpdated = [])).push(() => updateCssVars(this));
			this.registerUpdateCssVars(block.nodes);
		} else if (isVaporComponent(block)) this.registerUpdateCssVars(block.block);
		else if (isArray(block)) block.forEach((node) => this.registerUpdateCssVars(node));
	}
	handleChildrenUpdate(children) {
		if (!this.parent || isHydrating$1) {
			this.nodes = children;
			return;
		}
		remove(this.nodes, this.mountContainer);
		insert(this.nodes = children, this.mountContainer, this.mountAnchor);
	}
	mount(parent, anchor) {
		if (this.$transition) applyTransitionHooks(this.nodes, this.$transition);
		insert(this.nodes, this.mountContainer = parent, this.mountAnchor = anchor);
	}
	mountToTarget() {
		const target = this.target = resolveTeleportTarget(this.resolvedProps, querySelector);
		if (target) {
			if (!this.targetAnchor || this.targetAnchor.parentNode !== target) {
				insert(this.targetStart = /* @__PURE__ */ createTextNode(""), target);
				insert(this.targetAnchor = /* @__PURE__ */ createTextNode(""), target);
			}
			if (this.parentComponent && this.parentComponent.isCE) (this.parentComponent.ce._teleportTargets || (this.parentComponent.ce._teleportTargets = /* @__PURE__ */ new Set())).add(target);
			this.mount(target, this.targetAnchor);
			updateCssVars(this);
		} else if (!!(process.env.NODE_ENV !== "production")) warn(`Invalid Teleport target on ${this.targetAnchor ? "update" : "mount"}:`, target, `(${typeof target})`);
	}
	handlePropsUpdate() {
		if (!this.parent || isHydrating$1) return;
		if (this.isDisabled) {
			this.mount(this.parent, this.anchor);
			updateCssVars(this);
		} else if (isTeleportDeferred(this.resolvedProps) || !this.parent.isConnected) queuePostFlushCb(this.mountToTarget.bind(this));
		else this.mountToTarget();
	}
	hydrateDisabledTeleport(targetNode) {
		if (!isHydrating$1) return;
		let nextNode = this.placeholder.nextSibling;
		setCurrentHydrationNode(nextNode);
		this.mountAnchor = this.anchor = locateTeleportEndAnchor(nextNode);
		this.mountContainer = this.anchor.parentNode;
		this.targetStart = targetNode;
		this.targetAnchor = targetNode && targetNode.nextSibling;
		this.initChildren();
	}
	mountChildren(target) {
		if (!isHydrating$1) return;
		target.appendChild(this.targetStart = /* @__PURE__ */ createTextNode(""));
		target.appendChild(this.mountAnchor = this.targetAnchor = /* @__PURE__ */ createTextNode(""));
		if (!isMismatchAllowed(target, 1)) {
			if (!!(process.env.NODE_ENV !== "production") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) warn(`Hydration children mismatch on`, target, `\nServer rendered element contains fewer child nodes than client nodes.`);
			logMismatchError();
		}
		runWithoutHydration(this.initChildren.bind(this));
	}
};
/**
* Use duck typing to check for VaporTeleport instead of direct reference
* to VaporTeleportImpl, allowing tree-shaking when Teleport is not used.
*/
function isVaporTeleport(value) {
	return !!(value && value.__isTeleport && value.__vapor);
}
/**
* Use duck typing to check for TeleportFragment instead of instanceof,
* allowing tree-shaking when Teleport is not used.
*/
function isTeleportFragment(value) {
	return !!(value && value.__isTeleportFragment);
}
function locateTeleportEndAnchor(node = currentHydrationNode) {
	while (node) {
		if (isComment(node, "teleport end")) return node;
		node = node.nextSibling;
	}
	return null;
}
function updateCssVars(frag) {
	const ctx = frag.parentComponent;
	if (ctx && ctx.ut) {
		let node, anchor;
		if (frag.isDisabled) {
			node = frag.placeholder;
			anchor = frag.anchor;
		} else {
			node = frag.targetStart;
			anchor = frag.targetAnchor;
		}
		while (node && node !== anchor) {
			if (node.nodeType === 1) node.setAttribute("data-v-owner", String(ctx.uid));
			node = node.nextSibling;
		}
		ctx.ut();
	}
}

//#endregion
//#region packages/runtime-vapor/src/block.ts
function isBlock(val) {
	return val instanceof Node || isArray(val) || isVaporComponent(val) || isFragment(val);
}
function isValidBlock(block) {
	if (block instanceof Node) return !(block instanceof Comment);
	else if (isVaporComponent(block)) return isValidBlock(block.block);
	else if (isArray(block)) return block.length > 0 && block.some(isValidBlock);
	else return isValidBlock(block.nodes);
}
function insert(block, parent, anchor = null, parentSuspense) {
	anchor = anchor === 0 ? parent.$fc || /* @__PURE__ */ _child(parent) : anchor;
	if (block instanceof Node) {
		if (!isHydrating$1) if (block instanceof Element && block.$transition && !block.$transition.disabled) performTransitionEnter(block, block.$transition, () => parent.insertBefore(block, anchor), parentSuspense);
		else parent.insertBefore(block, anchor);
	} else if (isVaporComponent(block)) if (block.isMounted && !block.isDeactivated) insert(block.block, parent, anchor);
	else mountComponent(block, parent, anchor);
	else if (isArray(block)) for (const b of block) insert(b, parent, anchor);
	else {
		if (block.anchor) {
			insert(block.anchor, parent, anchor);
			anchor = block.anchor;
		}
		if (block.insert) block.insert(parent, anchor, block.$transition);
		else insert(block.nodes, parent, anchor, parentSuspense);
	}
}
function move(block, parent, anchor = null, moveType = 1, parentComponent, parentSuspense) {
	anchor = anchor === 0 ? parent.$fc || /* @__PURE__ */ _child(parent) : anchor;
	if (block instanceof Node) if (block instanceof Element && block.$transition && !block.$transition.disabled && moveType !== 2) if (moveType === 0) performTransitionEnter(block, block.$transition, () => parent.insertBefore(block, anchor), parentSuspense, true);
	else performTransitionLeave(block, block.$transition, () => {
		if (moveType === 1 && parentComponent && parentComponent.isUnmounted) block.remove();
		else parent.insertBefore(block, anchor);
	}, parentSuspense, true);
	else parent.insertBefore(block, anchor);
	else if (isVaporComponent(block)) if (block.isMounted) move(block.block, parent, anchor, moveType, parentComponent, parentSuspense);
	else mountComponent(block, parent, anchor);
	else if (isArray(block)) for (const b of block) move(b, parent, anchor, moveType, parentComponent, parentSuspense);
	else {
		if (block.anchor) {
			move(block.anchor, parent, anchor, moveType, parentComponent, parentSuspense);
			anchor = block.anchor;
		}
		if (block.insert) block.insert(parent, anchor, block.$transition);
		else move(block.nodes, parent, anchor, moveType, parentComponent, parentSuspense);
	}
}
function prepend(parent, ...blocks) {
	let i = blocks.length;
	while (i--) insert(blocks[i], parent, 0);
}
function remove(block, parent) {
	if (block instanceof Node) if (block.$transition && block instanceof Element) performTransitionLeave(block, block.$transition, () => parent && parent.removeChild(block));
	else parent && parent.removeChild(block);
	else if (isVaporComponent(block)) unmountComponent(block, parent);
	else if (isArray(block)) for (let i = 0; i < block.length; i++) remove(block[i], parent);
	else {
		if (block.remove) block.remove(parent, block.$transition);
		else remove(block.nodes, parent);
		if (block.anchor) remove(block.anchor, parent);
		if (block.scope) block.scope.stop();
	}
}
/**
* dev / test only
*/
function normalizeBlock(block) {
	if (!!!(process.env.NODE_ENV !== "production") && true) throw new Error("normalizeBlock should not be used in production code paths");
	const nodes = [];
	if (block instanceof Node) nodes.push(block);
	else if (isArray(block)) block.forEach((child) => nodes.push(...normalizeBlock(child)));
	else if (isVaporComponent(block)) nodes.push(...normalizeBlock(block.block));
	else if (isTeleportFragment(block)) nodes.push(block.placeholder, block.anchor);
	else {
		nodes.push(...normalizeBlock(block.nodes));
		block.anchor && nodes.push(block.anchor);
	}
	return nodes;
}
function findBlockNode(block) {
	let { parentNode, nextSibling: nextNode } = findLastChild(block);
	if (nextNode && isComment(nextNode, "]") && isFragmentBlock(block)) nextNode = nextNode.nextSibling;
	return {
		parentNode,
		nextNode
	};
}
function findLastChild(node) {
	if (node && node instanceof Node) return node;
	else if (isArray(node)) return findLastChild(node[node.length - 1]);
	else if (isVaporComponent(node)) return findLastChild(node.block);
	else {
		if (node.anchor) return node.anchor;
		return findLastChild(node.nodes);
	}
}
function isFragmentBlock(block) {
	if (isArray(block)) return true;
	else if (isVaporComponent(block)) return isFragmentBlock(block.block);
	else if (isFragment(block)) return isFragmentBlock(block.nodes);
	return false;
}
function setScopeId(block, scopeIds) {
	if (block instanceof Element) for (const id of scopeIds) block.setAttribute(id, "");
	else if (isVaporComponent(block)) setScopeId(block.block, scopeIds);
	else if (isArray(block)) for (const b of block) setScopeId(b, scopeIds);
	else if (isFragment(block)) setScopeId(block.nodes, scopeIds);
}
function setComponentScopeId(instance) {
	const { parent, scopeId } = instance;
	if (!parent || !scopeId) return;
	if (isArray(instance.block) && instance.block.length > 1) return;
	const scopeIds = [];
	const parentScopeId = parent && parent.type.__scopeId;
	if (parentScopeId !== scopeId) scopeIds.push(scopeId);
	else if (parentScopeId) scopeIds.push(parentScopeId);
	if (parent.subTree && parent.subTree.component === instance && parent.vnode.scopeId) {
		scopeIds.push(parent.vnode.scopeId);
		const inheritedScopeIds = getInheritedScopeIds(parent.vnode, parent.parent);
		scopeIds.push(...inheritedScopeIds);
	}
	if (scopeIds.length > 0) setScopeId(instance.block, scopeIds);
}
let _applyTransitionHooks;
let _applyTransitionLeaveHooks;
function registerTransitionHooks(applyHooks, applyLeaveHooks) {
	_applyTransitionHooks = applyHooks;
	_applyTransitionLeaveHooks = applyLeaveHooks;
}
function applyTransitionHooks(block, hooks) {
	return _applyTransitionHooks ? _applyTransitionHooks(block, hooks) : hooks;
}
function applyTransitionLeaveHooks(block, enterHooks, afterLeaveCb) {
	_applyTransitionLeaveHooks && _applyTransitionLeaveHooks(block, enterHooks, afterLeaveCb);
}

//#endregion
//#region packages/runtime-vapor/src/hmr.ts
function hmrRerender(instance) {
	const normalized = normalizeBlock(instance.block);
	const parent = normalized[0].parentNode;
	const anchor = normalized[normalized.length - 1].nextSibling;
	instance.scope.reset();
	remove(instance.block, parent);
	const prev = setCurrentInstance(instance);
	pushWarningContext(instance);
	devRender(instance);
	popWarningContext();
	setCurrentInstance(...prev);
	insert(instance.block, parent, anchor);
}
function hmrReload(instance, newComp) {
	if (instance.parent && isKeepAlive(instance.parent)) {
		instance.parent.hmrRerender();
		return;
	}
	const normalized = normalizeBlock(instance.block);
	const parent = normalized[0].parentNode;
	const anchor = normalized[normalized.length - 1].nextSibling;
	unmountComponent(instance, parent);
	const parentInstance = instance.parent;
	const prev = setCurrentInstance(parentInstance);
	const newInstance = createComponent(newComp, instance.rawProps, instance.rawSlots, instance.isSingleRoot);
	setCurrentInstance(...prev);
	mountComponent(newInstance, parent, anchor);
	updateParentBlockOnHmrReload(parentInstance, instance, newInstance);
	updateParentTeleportOnHmrReload(instance, newInstance);
}
/**
* dev only
* update parentInstance.block to ensure that the correct parent and
* anchor are found during parentInstance HMR rerender/reload, as
* `normalizeBlock` relies on the current instance.block
*/
function updateParentBlockOnHmrReload(parentInstance, instance, newInstance) {
	if (parentInstance) {
		if (parentInstance.block === instance) parentInstance.block = newInstance;
		else if (isArray(parentInstance.block)) {
			for (let i = 0; i < parentInstance.block.length; i++) if (parentInstance.block[i] === instance) {
				parentInstance.block[i] = newInstance;
				break;
			}
		}
	}
}
/**
* dev only
* during root component HMR reload, since the old component will be unmounted
* and a new one will be mounted, we need to update the teleport's nodes
* to ensure that the correct parent and anchor are found during parentInstance
* HMR rerender/reload, as `normalizeBlock` relies on the current instance.block
*/
function updateParentTeleportOnHmrReload(instance, newInstance) {
	const teleport = instance.parentTeleport;
	if (teleport) {
		newInstance.parentTeleport = teleport;
		if (teleport.nodes === instance) teleport.nodes = newInstance;
		else if (isArray(teleport.nodes)) {
			for (let i = 0; i < teleport.nodes.length; i++) if (teleport.nodes[i] === instance) {
				teleport.nodes[i] = newInstance;
				break;
			}
		}
	}
}

//#endregion
//#region packages/runtime-vapor/src/component.ts
function createComponent(component, rawProps, rawSlots, isSingleRoot, once, appContext = currentInstance && currentInstance.appContext || emptyContext) {
	const _insertionParent = insertionParent;
	const _insertionAnchor = insertionAnchor;
	const _isLastInsertion = isLastInsertion;
	if (isHydrating$1) locateHydrationNode();
	else resetInsertionState();
	let prevSuspense = null;
	if (currentInstance && currentInstance.suspense) prevSuspense = setParentSuspense(currentInstance.suspense);
	if ((isSingleRoot || currentInstance && isVaporTransition(currentInstance.type)) && component.inheritAttrs !== false && isVaporComponent(currentInstance) && currentInstance.hasFallthrough) {
		const attrs = currentInstance.attrs;
		if (rawProps && rawProps !== EMPTY_OBJ) (rawProps.$ || (rawProps.$ = [])).push(() => attrs);
		else rawProps = { $: [() => attrs] };
	}
	if (currentInstance && currentInstance.vapor && isKeepAlive(currentInstance)) {
		const cached = currentInstance.ctx.getCachedComponent(component);
		if (cached) return cached;
	}
	if (appContext.vapor && !component.__vapor) {
		const frag = appContext.vapor.vdomMount(component, currentInstance, rawProps, rawSlots, isSingleRoot);
		if (!isHydrating$1) {
			if (_insertionParent) insert(frag, _insertionParent, _insertionAnchor);
		} else {
			frag.hydrate();
			if (_isLastInsertion) advanceHydrationNode(_insertionParent);
		}
		return frag;
	}
	if (isVaporTeleport(component)) {
		const frag = component.process(rawProps, rawSlots);
		if (!isHydrating$1) {
			if (_insertionParent) insert(frag, _insertionParent, _insertionAnchor);
		} else {
			frag.hydrate();
			if (_isLastInsertion) advanceHydrationNode(_insertionParent);
		}
		return frag;
	}
	const instance = new VaporComponentInstance(component, rawProps, rawSlots, appContext, once);
	if (currentKeepAliveCtx && !isAsyncWrapper(instance)) {
		currentKeepAliveCtx.processShapeFlag(instance);
		setCurrentKeepAliveCtx(null);
	}
	const prevSlotOwner = setCurrentSlotOwner(null);
	if (!!(process.env.NODE_ENV !== "production")) {
		registerHMR(instance);
		instance.isSingleRoot = isSingleRoot;
		instance.hmrRerender = hmrRerender.bind(null, instance);
		instance.hmrReload = hmrReload.bind(null, instance);
		pushWarningContext(instance);
		startMeasure(instance, `init`);
		instance.propsOptions = normalizePropsOptions(component);
		instance.emitsOptions = normalizeEmitsOptions(component);
	}
	if (isHydrating$1 && isAsyncWrapper(instance) && component.__asyncHydrate && !component.__asyncResolved) component.__asyncHydrate(currentHydrationNode, instance, () => setupComponent(instance, component));
	else setupComponent(instance, component);
	if (!!(process.env.NODE_ENV !== "production")) {
		popWarningContext();
		endMeasure(instance, "init");
	}
	if (currentInstance && currentInstance.suspense) setParentSuspense(prevSuspense);
	setCurrentSlotOwner(prevSlotOwner);
	onScopeDispose$1(() => unmountComponent(instance), true);
	if (_insertionParent || isHydrating$1) mountComponent(instance, _insertionParent, _insertionAnchor);
	if (isHydrating$1 && _insertionAnchor !== void 0) advanceHydrationNode(_insertionParent);
	return instance;
}
function setupComponent(instance, component) {
	const prevInstance = setCurrentInstance(instance);
	const prevSub = setActiveSub();
	if (!!(process.env.NODE_ENV !== "production")) setupPropsValidation(instance);
	const setupFn = isFunction(component) ? component : component.setup;
	const setupResult = setupFn ? callWithErrorHandling(setupFn, instance, 0, [instance.props, instance]) || EMPTY_OBJ : EMPTY_OBJ;
	const isAsyncSetup = isPromise(setupResult);
	if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) markAsyncBoundary(instance);
	if (isAsyncSetup) {
		instance.asyncDep = setupResult;
		if (!!(process.env.NODE_ENV !== "production") && !instance.suspense) {
			var _getComponentName;
			warn(`Component <${(_getComponentName = getComponentName(component)) !== null && _getComponentName !== void 0 ? _getComponentName : "Anonymous"}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
		}
	} else handleSetupResult(setupResult, component, instance);
	setActiveSub(prevSub);
	setCurrentInstance(...prevInstance);
}
let isApplyingFallthroughProps = false;
function applyFallthroughProps(el, attrs) {
	isApplyingFallthroughProps = true;
	setDynamicProps(el, [attrs]);
	isApplyingFallthroughProps = false;
}
/**
* dev only
*/
function createDevSetupStateProxy(instance) {
	const { setupState } = instance;
	return new Proxy(setupState, { get(target, key, receiver) {
		if (isString(key) && !key.startsWith("__v") && !hasOwn(toRaw(setupState), key)) warn(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
		return Reflect.get(target, key, receiver);
	} });
}
/**
* dev only
*/
function devRender(instance) {
	instance.block = (instance.type.render ? callWithErrorHandling(instance.type.render, instance, 1, [
		instance.setupState,
		instance.props,
		instance.emit,
		instance.attrs,
		instance.slots
	]) : callWithErrorHandling(isFunction(instance.type) ? instance.type : instance.type.setup, instance, 0, [instance.props, {
		slots: instance.slots,
		attrs: instance.attrs,
		emit: instance.emit,
		expose: instance.expose
	}])) || [];
}
const emptyContext = {
	app: null,
	config: {},
	provides: /* @__PURE__ */ Object.create(null)
};
var VaporComponentInstance = class {
	constructor(comp, rawProps, rawSlots, appContext, once) {
		this.accessedAttrs = false;
		this.vapor = true;
		this.uid = nextUid();
		this.type = comp;
		this.parent = currentInstance;
		if (currentInstance) {
			this.root = currentInstance.root;
			this.appContext = currentInstance.appContext;
			this.provides = currentInstance.provides;
			this.ids = currentInstance.ids;
		} else {
			this.root = this;
			this.appContext = appContext || emptyContext;
			this.provides = Object.create(this.appContext.provides);
			this.ids = [
				"",
				0,
				0
			];
		}
		this.block = null;
		this.scope = new EffectScope(true);
		this.emit = emit.bind(null, this);
		this.expose = expose.bind(null, this);
		this.refs = EMPTY_OBJ;
		this.emitted = this.exposed = this.exposeProxy = this.propsDefaults = null;
		this.suspense = parentSuspense;
		this.suspenseId = parentSuspense ? parentSuspense.pendingId : 0;
		this.asyncDep = null;
		this.asyncResolved = false;
		this.isMounted = this.isUnmounted = this.isUpdating = this.isDeactivated = false;
		this.rawProps = rawProps || EMPTY_OBJ;
		this.hasFallthrough = hasFallthroughAttrs(comp, rawProps);
		if (rawProps || comp.props) {
			const [propsHandlers, attrsHandlers] = getPropsProxyHandlers(comp, once);
			this.attrs = new Proxy(this, attrsHandlers);
			this.props = comp.props ? new Proxy(this, propsHandlers) : isFunction(comp) ? this.attrs : EMPTY_OBJ;
		} else this.props = this.attrs = EMPTY_OBJ;
		this.rawSlots = rawSlots || EMPTY_OBJ;
		this.slots = rawSlots ? rawSlots.$ ? new Proxy(rawSlots, dynamicSlotsProxyHandlers) : rawSlots : EMPTY_OBJ;
		this.scopeId = getCurrentScopeId();
		if (comp.ce) comp.ce(this);
		if (!!(process.env.NODE_ENV !== "production")) if (this.props === this.attrs) this.accessedAttrs = true;
		else {
			const attrs = this.attrs;
			const instance = this;
			this.attrs = new Proxy(attrs, { get(target, key, receiver) {
				instance.accessedAttrs = true;
				return Reflect.get(target, key, receiver);
			} });
		}
	}
	/**
	* Expose `getKeysFromRawProps` on the instance so it can be used in code
	* paths where it's needed, e.g. `useModel`
	*/
	rawKeys() {
		return getKeysFromRawProps(this.rawProps);
	}
};
function isVaporComponent(value) {
	return value instanceof VaporComponentInstance;
}
/**
* Used when a component cannot be resolved at compile time
* and needs rely on runtime resolution - where it might fallback to a plain
* element if the resolution fails.
*/
function createComponentWithFallback(comp, rawProps, rawSlots, isSingleRoot, once, appContext) {
	if (comp === NULL_DYNAMIC_COMPONENT) return !!(process.env.NODE_ENV !== "production") ? /* @__PURE__ */ createComment("ndc") : /* @__PURE__ */ createTextNode("");
	if (!isString(comp)) return createComponent(comp, rawProps, rawSlots, isSingleRoot, once, appContext);
	return createPlainElement(comp, rawProps, rawSlots, isSingleRoot, once);
}
function createPlainElement(comp, rawProps, rawSlots, isSingleRoot, once) {
	const _insertionParent = insertionParent;
	const _insertionAnchor = insertionAnchor;
	const _isLastInsertion = isLastInsertion;
	if (isHydrating$1) locateHydrationNode();
	else resetInsertionState();
	const el = isHydrating$1 ? adoptTemplate(currentHydrationNode, `<${comp}/>`) : /* @__PURE__ */ createElement(comp);
	el.$root = isSingleRoot;
	if (!isHydrating$1) {
		const scopeId = getCurrentScopeId();
		if (scopeId) setScopeId(el, [scopeId]);
	}
	if (rawProps) {
		const setFn = () => setDynamicProps(el, [resolveDynamicProps(rawProps)]);
		if (once) setFn();
		else renderEffect(setFn);
	}
	if (rawSlots) {
		let nextNode = null;
		if (isHydrating$1) {
			nextNode = locateNextNode(el);
			setCurrentHydrationNode(el.firstChild);
		}
		if (rawSlots.$) {
			const frag = new DynamicFragment(isHydrating$1 ? "" : !!(process.env.NODE_ENV !== "production") ? "slot" : void 0);
			renderEffect(() => frag.update(getSlot(rawSlots, "default")));
			if (!isHydrating$1) insert(frag, el);
		} else {
			const block = getSlot(rawSlots, "default")();
			if (!isHydrating$1) insert(block, el);
		}
		if (isHydrating$1) setCurrentHydrationNode(nextNode);
	}
	if (!isHydrating$1) {
		if (_insertionParent) insert(el, _insertionParent, _insertionAnchor);
	} else if (_isLastInsertion) advanceHydrationNode(_insertionParent);
	return el;
}
function mountComponent(instance, parent, anchor) {
	if (instance.suspense && instance.asyncDep && !instance.asyncResolved) {
		const component = instance.type;
		instance.suspense.registerDep(instance, (setupResult) => {
			handleSetupResult(setupResult, component, instance);
			mountComponent(instance, parent, anchor);
		});
		return;
	}
	if (instance.shapeFlag & 512) {
		instance.parent.ctx.activate(instance, parent, anchor);
		return;
	}
	const { root, type } = instance;
	if (root && root.ce && root.ce._hasShadowRoot()) root.ce._injectChildStyle(type);
	if (!!(process.env.NODE_ENV !== "production")) startMeasure(instance, `mount`);
	if (instance.bm) invokeArrayFns(instance.bm);
	if (!isHydrating$1) {
		insert(instance.block, parent, anchor);
		setComponentScopeId(instance);
	}
	if (instance.m) queuePostFlushCb(instance.m);
	if (instance.shapeFlag & 256 && instance.a) queuePostFlushCb(instance.a);
	instance.isMounted = true;
	if (!!(process.env.NODE_ENV !== "production")) endMeasure(instance, `mount`);
}
function unmountComponent(instance, parentNode) {
	if (instance.shapeFlag & 256 && instance.parent && instance.parent.vapor) {
		if (parentNode) instance.parent.ctx.deactivate(instance);
		return;
	}
	if (instance.isMounted && !instance.isUnmounted) {
		if (!!(process.env.NODE_ENV !== "production")) unregisterHMR(instance);
		if (instance.bum) invokeArrayFns(instance.bum);
		instance.scope.stop();
		if (instance.um) queuePostFlushCb(instance.um);
		instance.isUnmounted = true;
	}
	if (parentNode) remove(instance.block, parentNode);
}
function getExposed(instance) {
	if (instance.exposed) return instance.exposeProxy || (instance.exposeProxy = new Proxy(markRaw(instance.exposed), { get: (target, key) => unref(target[key]) }));
}
function getRootElement(block, onDynamicFragment, recurse = true) {
	if (block instanceof Element) return block;
	if (recurse && isVaporComponent(block)) return getRootElement(block.block, onDynamicFragment, recurse);
	if (isFragment(block) && !isTeleportFragment(block)) {
		if (block instanceof DynamicFragment && onDynamicFragment) onDynamicFragment(block);
		const { nodes } = block;
		if (nodes instanceof Element && nodes.$root) return nodes;
		return getRootElement(nodes, onDynamicFragment, recurse);
	}
	if (isArray(block)) {
		let singleRoot;
		let hasComment = false;
		for (const b of block) {
			if (b instanceof Comment) {
				hasComment = true;
				continue;
			}
			const thisRoot = getRootElement(b, onDynamicFragment, recurse);
			if (!thisRoot || singleRoot) return;
			singleRoot = thisRoot;
		}
		return hasComment ? singleRoot : void 0;
	}
}
function isVaporTransition(component) {
	return getComponentName(component) === "VaporTransition";
}
function handleSetupResult(setupResult, component, instance) {
	if (!!(process.env.NODE_ENV !== "production")) pushWarningContext(instance);
	if (!!(process.env.NODE_ENV !== "production") && !isBlock(setupResult)) if (isFunction(component)) {
		warn(`Functional vapor component must return a block directly.`);
		instance.block = [];
	} else if (!component.render) {
		warn(`Vapor component setup() returned non-block value, and has no render function.`);
		instance.block = [];
	} else {
		if (!!(process.env.NODE_ENV !== "production") || __VUE_PROD_DEVTOOLS__) instance.devtoolsRawSetupState = setupResult;
		instance.setupState = proxyRefs(setupResult);
		if (!!(process.env.NODE_ENV !== "production")) instance.setupState = createDevSetupStateProxy(instance);
		devRender(instance);
	}
	else if (setupResult === EMPTY_OBJ && component.render) instance.block = callWithErrorHandling(component.render, instance, 1);
	else instance.block = setupResult;
	if (instance.hasFallthrough && component.inheritAttrs !== false && Object.keys(instance.attrs).length) {
		const root = getRootElement(instance.block, (frag) => frag.attrs = instance.attrs, false);
		if (root) renderEffect(() => {
			const attrs = isFunction(component) && !isVaporTransition(component) ? getFunctionalFallthrough(instance.attrs) : instance.attrs;
			if (attrs) applyFallthroughProps(root, attrs);
		});
		else if (!!(process.env.NODE_ENV !== "production") && (!instance.accessedAttrs && isArray(instance.block) && instance.block.length || isTeleportFragment(instance.block))) warnExtraneousAttributes(instance.attrs);
	}
	if (!!(process.env.NODE_ENV !== "production")) popWarningContext();
}
function getCurrentScopeId() {
	const scopeOwner = getScopeOwner();
	return scopeOwner ? scopeOwner.type.__scopeId : void 0;
}

//#endregion
//#region packages/runtime-vapor/src/apiCreateApp.ts
let _createApp;
const mountApp = (app, container) => {
	optimizePropertyLookup();
	if (container.nodeType === 1) {
		if (!!(process.env.NODE_ENV !== "production") && container.childNodes.length) warn("mount target container is not empty and will be cleared.");
		container.textContent = "";
	}
	const instance = app._ceComponent || createComponent(app._component, app._props, null, false, false, app._context);
	mountComponent(instance, container);
	flushOnAppMount();
	return instance;
};
let _hydrateApp;
const hydrateApp = (app, container) => {
	optimizePropertyLookup();
	let instance;
	withHydration(container, () => {
		instance = app._ceComponent || createComponent(app._component, app._props, null, false, false, app._context);
		mountComponent(instance, container);
		flushOnAppMount();
	});
	return instance;
};
const unmountApp = (app) => {
	unmountComponent(app._instance, app._container);
};
function prepareApp() {
	initFeatureFlags();
	const target = getGlobalThis();
	target.__VUE__ = true;
	if (!!(process.env.NODE_ENV !== "production") || __VUE_PROD_DEVTOOLS__) setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
}
function postPrepareApp(app) {
	app.vapor = true;
	const mount = app.mount;
	app.mount = (container, ...args) => {
		container = normalizeContainer(container);
		const proxy = mount(container, ...args);
		if (container instanceof Element) {
			container.removeAttribute("v-cloak");
			container.setAttribute("data-v-app", "");
		}
		return proxy;
	};
}
const createVaporApp = (comp, props) => {
	prepareApp();
	if (!_createApp) _createApp = createAppAPI(mountApp, unmountApp, getExposed);
	const app = _createApp(comp, props);
	postPrepareApp(app);
	return app;
};
const createVaporSSRApp = (comp, props) => {
	setIsHydratingEnabled(true);
	prepareApp();
	if (!_hydrateApp) _hydrateApp = createAppAPI(hydrateApp, unmountApp, getExposed);
	const app = _hydrateApp(comp, props);
	postPrepareApp(app);
	return app;
};

//#endregion
//#region packages/runtime-vapor/src/apiDefineAsyncComponent.ts
function defineVaporAsyncComponent(source) {
	const { load, getResolvedComp, setPendingRequest, source: { loadingComponent, errorComponent, delay, hydrate: hydrateStrategy, timeout, suspensible = true } } = createAsyncComponentContext(source);
	return /* @__PURE__ */ defineVaporComponent({
		name: "VaporAsyncComponentWrapper",
		__asyncLoader: load,
		__asyncHydrate(el, instance, hydrate) {
			if (!isHydrating$1) return;
			if (isComment(el, "[")) {
				const end = /* @__PURE__ */ _next(locateEndAnchor(el));
				const block = instance.block = [el];
				let cur = el;
				while (true) {
					let n = /* @__PURE__ */ _next(cur);
					if (n && n !== end) block.push(cur = n);
					else break;
				}
			} else instance.block = el;
			instance.isMounted = true;
			setCurrentHydrationNode(isComment(el, "[") ? locateEndAnchor(el) : el.nextSibling);
			let isHydrated = false;
			watch(() => instance.attrs, () => {
				if (isHydrated) return;
				instance.bu && invokeArrayFns(instance.bu);
				const parent = /* @__PURE__ */ parentNode(el);
				load().then(() => {
					if (instance.isUnmounted) return;
					hydrate();
					if (isComment(el, "[")) {
						const endAnchor = locateEndAnchor(el);
						removeFragmentNodes(el, endAnchor);
						insert(instance.block, parent, endAnchor);
					} else {
						insert(instance.block, parent, el);
						remove(el, parent);
					}
				});
			}, {
				deep: true,
				once: true
			});
			performAsyncHydrate(el, instance, () => {
				hydrateNode(el, () => {
					hydrate();
					insert(instance.block, /* @__PURE__ */ parentNode(el), el);
					isHydrated = true;
				});
			}, getResolvedComp, load, hydrateStrategy);
		},
		get __asyncResolved() {
			return getResolvedComp();
		},
		setup() {
			const instance = currentInstance;
			markAsyncBoundary(instance);
			const frag = !!(process.env.NODE_ENV !== "production") || isHydrating$1 ? new DynamicFragment("async component") : new DynamicFragment();
			let resolvedComp = getResolvedComp();
			if (resolvedComp) {
				frag.update(() => createInnerComp(resolvedComp, instance, frag));
				return frag;
			}
			const onError = (err) => {
				setPendingRequest(null);
				handleError(err, instance, 13, !errorComponent);
			};
			if (suspensible && instance.suspense) {}
			const { loaded, error, delayed } = useAsyncComponentState(delay, timeout, onError);
			load().then(() => {
				loaded.value = true;
			}).catch((err) => {
				onError(err);
				error.value = err;
			});
			renderEffect(() => {
				resolvedComp = getResolvedComp();
				let render;
				if (loaded.value && resolvedComp) render = () => createInnerComp(resolvedComp, instance, frag);
				else if (error.value && errorComponent) render = () => createComponent(errorComponent, { error: () => error.value });
				else if (loadingComponent && !delayed.value) render = () => createComponent(loadingComponent);
				frag.update(render);
				if (frag.keepAliveCtx) frag.keepAliveCtx.cacheBlock();
			});
			return frag;
		}
	});
}
function createInnerComp(comp, parent, frag) {
	const { rawProps, rawSlots, appContext } = parent;
	const instance = createComponent(comp, rawProps, rawSlots, void 0, void 0, appContext);
	frag && frag.setAsyncRef && frag.setAsyncRef(instance);
	return instance;
}

//#endregion
//#region packages/runtime-vapor/src/apiDefineCustomElement.ts
/* @__NO_SIDE_EFFECTS__ */
function defineVaporCustomElement(options, extraOptions, _createApp) {
	let Comp = /* @__PURE__ */ defineVaporComponent(options, extraOptions);
	if (isPlainObject(Comp)) Comp = extend({}, Comp, extraOptions);
	class VaporCustomElement extends VaporElement {
		constructor(initialProps) {
			super(Comp, initialProps, _createApp);
		}
	}
	VaporCustomElement.def = Comp;
	return VaporCustomElement;
}
const defineVaporSSRCustomElement = ((options, extraOptions) => {
	return /* @__PURE__ */ defineVaporCustomElement(options, extraOptions, createVaporSSRApp);
});
var VaporElement = class extends VueElementBase {
	constructor(def, props = {}, createAppFn = createVaporApp) {
		super(def, props, createAppFn);
	}
	_needsHydration() {
		if (this.shadowRoot && this._createApp !== createVaporApp) return true;
		else if (!!(process.env.NODE_ENV !== "production") && this.shadowRoot) warn("Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use `defineVaporSSRCustomElement`.");
		return false;
	}
	_mount(def) {
		if ((!!(process.env.NODE_ENV !== "production") || __VUE_PROD_DEVTOOLS__) && !def.name) def.name = "VaporElement";
		this._app = this._createApp(this._def);
		this._inheritParentContext();
		if (this._def.configureApp) this._def.configureApp(this._app);
		if (this.shadowRoot && this._createApp === createVaporSSRApp) withHydration(this._root, this._createComponent.bind(this));
		else this._createComponent();
		this._app.mount(this._root);
		if (!this.shadowRoot) this._renderSlots();
	}
	_update() {
		if (!this._app) return;
		const renderEffects = this._instance.renderEffects;
		if (renderEffects) renderEffects.forEach((e) => e.run());
	}
	_unmount() {
		this._app.unmount();
		if (this._instance && this._instance.ce) this._instance.ce = void 0;
		this._app = this._instance = null;
	}
	/**
	* Only called when shadowRoot is false
	*/
	_updateSlotNodes(replacements) {
		this._updateFragmentNodes(this._instance.block, replacements);
	}
	/**
	* Replace slot nodes with their replace content
	* @internal
	*/
	_updateFragmentNodes(block, replacements) {
		if (Array.isArray(block)) {
			block.forEach((item) => this._updateFragmentNodes(item, replacements));
			return;
		}
		if (!isFragment(block)) return;
		const { nodes } = block;
		if (Array.isArray(nodes)) {
			const newNodes = [];
			for (const node of nodes) if (node instanceof HTMLSlotElement) newNodes.push(...replacements.get(node));
			else {
				this._updateFragmentNodes(node, replacements);
				newNodes.push(node);
			}
			block.nodes = newNodes;
		} else if (nodes instanceof HTMLSlotElement) block.nodes = replacements.get(nodes);
		else this._updateFragmentNodes(nodes, replacements);
	}
	_createComponent() {
		this._def.ce = (instance) => {
			this._app._ceComponent = this._instance = instance;
			if (!this.shadowRoot) this._instance.u = [this._renderSlots.bind(this)];
			this._processInstance();
		};
		createComponent(this._def, this._props, void 0, void 0, void 0, this._app._context);
	}
};

//#endregion
//#region packages/runtime-vapor/src/dom/template.ts
let t;
/* @__NO_SIDE_EFFECTS__ */
function template(html, root, ns) {
	let node;
	return () => {
		if (isHydrating$1) {
			const adopted = adoptTemplate(currentHydrationNode, html);
			if (root) adopted.$root = true;
			return adopted;
		}
		if (html[0] !== "<") return /* @__PURE__ */ createTextNode(html);
		if (!node) {
			t = t || document.createElement("template");
			if (ns) {
				const tag = ns === 1 ? "svg" : "math";
				t.innerHTML = `<${tag}>${html}</${tag}>`;
				node = /* @__PURE__ */ _child(/* @__PURE__ */ _child(t.content));
			} else {
				t.innerHTML = html;
				node = /* @__PURE__ */ _child(t.content);
			}
		}
		const ret = node.cloneNode(true);
		if (root) ret.$root = true;
		return ret;
	};
}

//#endregion
//#region packages/runtime-vapor/src/apiCreateIf.ts
function createIf(condition, b1, b2, once, index) {
	const _insertionParent = insertionParent;
	const _insertionAnchor = insertionAnchor;
	const _isLastInsertion = isLastInsertion;
	if (!isHydrating$1) resetInsertionState();
	let frag;
	if (once) frag = condition() ? b1() : b2 ? b2() : [!!(process.env.NODE_ENV !== "production") ? /* @__PURE__ */ createComment("if") : /* @__PURE__ */ createTextNode()];
	else {
		const keyed = index != null;
		frag = isHydrating$1 || !!(process.env.NODE_ENV !== "production") ? new DynamicFragment("if", keyed) : new DynamicFragment(void 0, keyed);
		renderEffect(() => {
			const ok = condition();
			frag.update(ok ? b1 : b2, keyed ? `${index}${ok ? 0 : 1}` : void 0);
		});
	}
	if (!isHydrating$1) {
		if (_insertionParent) insert(frag, _insertionParent, _insertionAnchor);
	} else if (_isLastInsertion) advanceHydrationNode(_insertionParent);
	return frag;
}

//#endregion
//#region packages/runtime-vapor/src/apiCreateFragment.ts
/**
* Create a dynamic fragment keyed by a reactive value for Vapor transitions.
* The fragment is re-rendered when the key changes to trigger enter/leave
* animations.
*
* Example:
* <VaporTransition>
*   <h1 :key="count">{{ count }}</h1>
* </VaporTransition>
*/
function createKeyedFragment(key, render) {
	const _insertionParent = insertionParent;
	const _insertionAnchor = insertionAnchor;
	const _isLastInsertion = isLastInsertion;
	if (!isHydrating$1) resetInsertionState();
	const frag = !!(process.env.NODE_ENV !== "production") ? new DynamicFragment("keyed", true) : new DynamicFragment(void 0, true);
	renderEffect(() => frag.update(render, key()));
	if (!isHydrating$1) {
		if (_insertionParent) insert(frag, _insertionParent, _insertionAnchor);
	} else if (_isLastInsertion) advanceHydrationNode(_insertionParent);
	return frag;
}

//#endregion
//#region packages/runtime-vapor/src/apiCreateFor.ts
var ForBlock = class extends VaporFragment {
	constructor(nodes, scope, item, key, index, renderKey) {
		super(nodes);
		this.scope = scope;
		this.itemRef = item;
		this.keyRef = key;
		this.indexRef = index;
		this.key = renderKey;
	}
};
const createFor = (src, renderItem, getKey, flags = 0, setup) => {
	const _insertionParent = insertionParent;
	const _insertionAnchor = insertionAnchor;
	const _insertionIndex = insertionIndex;
	const _isLastInsertion = isLastInsertion;
	if (isHydrating$1) locateHydrationNode();
	else resetInsertionState();
	let isMounted = false;
	let oldBlocks = [];
	let newBlocks;
	let parent;
	let currentKey;
	let parentAnchor;
	if (!isHydrating$1) parentAnchor = !!(process.env.NODE_ENV !== "production") ? /* @__PURE__ */ createComment("for") : /* @__PURE__ */ createTextNode();
	const frag = new ForFragment(oldBlocks);
	const instance = currentInstance$1;
	const canUseFastRemove = !!(flags & 1);
	const isComponent = !!(flags & 2);
	const selectors = [];
	const scopeOwner = currentSlotOwner;
	if (!!(process.env.NODE_ENV !== "production") && !instance) warn("createFor() can only be used inside setup()");
	const renderList = () => {
		const source = normalizeSource(src());
		const newLength = source.values.length;
		const oldLength = oldBlocks.length;
		newBlocks = new Array(newLength);
		let isFallback = false;
		const prevSub = setActiveSub();
		if (!isMounted) {
			isMounted = true;
			for (let i = 0; i < newLength; i++) {
				const nodes = mount(source, i).nodes;
				if (isHydrating$1) setCurrentHydrationNode(findBlockNode(nodes).nextNode);
			}
			if (isHydrating$1) {
				parentAnchor = newLength === 0 ? currentHydrationNode.nextSibling : currentHydrationNode;
				if (!!(process.env.NODE_ENV !== "production") && (!parentAnchor || parentAnchor && !isComment(parentAnchor, "]"))) throw new Error(`v-for fragment anchor node was not found. this is likely a Vue internal bug.`);
				if (_insertionParent && isComment(parentAnchor, "]")) {
					parentAnchor.$idx = _insertionIndex || 0;
					_insertionParent.$llc = parentAnchor;
				}
			}
		} else {
			const prevOwner = setCurrentSlotOwner(scopeOwner);
			parent = parent || parentAnchor.parentNode;
			if (!oldLength) {
				if (frag.fallback && frag.nodes[0].length > 0) remove(frag.nodes[0], parent);
				for (let i = 0; i < newLength; i++) mount(source, i);
			} else if (!newLength) {
				for (const selector of selectors) selector.cleanup();
				const doRemove = !canUseFastRemove;
				for (let i = 0; i < oldLength; i++) unmount(oldBlocks[i], doRemove, false);
				if (canUseFastRemove) {
					parent.textContent = "";
					parent.appendChild(parentAnchor);
				}
				if (frag.fallback) {
					insert(frag.nodes[0] = frag.fallback(), parent, parentAnchor);
					isFallback = true;
				}
			} else if (!getKey) {
				const commonLength = Math.min(newLength, oldLength);
				for (let i = 0; i < commonLength; i++) update(newBlocks[i] = oldBlocks[i], getItem(source, i)[0]);
				for (let i = oldLength; i < newLength; i++) mount(source, i);
				for (let i = newLength; i < oldLength; i++) unmount(oldBlocks[i]);
			} else {
				if (!!(process.env.NODE_ENV !== "production")) {
					const keyToIndexMap = /* @__PURE__ */ new Map();
					for (let i = 0; i < newLength; i++) {
						const key = getKey(...getItem(source, i));
						if (key != null) {
							if (keyToIndexMap.has(key)) warn(`Duplicate keys found during update:`, JSON.stringify(key), `Make sure keys are unique.`);
							keyToIndexMap.set(key, i);
						}
					}
				}
				const commonLength = Math.min(oldLength, newLength);
				const oldKeyIndexPairs = new Array(oldLength);
				const queuedBlocks = new Array(newLength);
				let endOffset = 0;
				let queuedBlocksLength = 0;
				let oldKeyIndexPairsLength = 0;
				while (endOffset < commonLength) {
					const index = newLength - endOffset - 1;
					const item = getItem(source, index);
					const key = getKey(...item);
					const existingBlock = oldBlocks[oldLength - endOffset - 1];
					if (existingBlock.key !== key) break;
					update(existingBlock, ...item);
					newBlocks[index] = existingBlock;
					endOffset++;
				}
				const e1 = commonLength - endOffset;
				const e2 = oldLength - endOffset;
				const e3 = newLength - endOffset;
				for (let i = 0; i < e1; i++) {
					const currentItem = getItem(source, i);
					const currentKey = getKey(...currentItem);
					const oldBlock = oldBlocks[i];
					const oldKey = oldBlock.key;
					if (oldKey === currentKey) update(newBlocks[i] = oldBlock, currentItem[0]);
					else {
						queuedBlocks[queuedBlocksLength++] = [
							i,
							currentItem,
							currentKey
						];
						oldKeyIndexPairs[oldKeyIndexPairsLength++] = [oldKey, i];
					}
				}
				for (let i = e1; i < e2; i++) oldKeyIndexPairs[oldKeyIndexPairsLength++] = [oldBlocks[i].key, i];
				for (let i = e1; i < e3; i++) {
					const blockItem = getItem(source, i);
					const blockKey = getKey(...blockItem);
					queuedBlocks[queuedBlocksLength++] = [
						i,
						blockItem,
						blockKey
					];
				}
				queuedBlocks.length = queuedBlocksLength;
				oldKeyIndexPairs.length = oldKeyIndexPairsLength;
				const oldKeyIndexMap = new Map(oldKeyIndexPairs);
				const opers = new Array(queuedBlocks.length);
				let mountCounter = 0;
				let opersLength = 0;
				for (let i = queuedBlocks.length - 1; i >= 0; i--) {
					const [index, item, key] = queuedBlocks[i];
					const oldIndex = oldKeyIndexMap.get(key);
					if (oldIndex !== void 0) {
						oldKeyIndexMap.delete(key);
						const reusedBlock = newBlocks[index] = oldBlocks[oldIndex];
						update(reusedBlock, ...item);
						opers[opersLength++] = {
							index,
							block: reusedBlock
						};
					} else {
						mountCounter++;
						opers[opersLength++] = {
							source,
							index,
							item,
							key
						};
					}
				}
				const useFastRemove = mountCounter === newLength;
				for (const leftoverIndex of oldKeyIndexMap.values()) unmount(oldBlocks[leftoverIndex], !(useFastRemove && canUseFastRemove), !useFastRemove);
				if (useFastRemove) {
					for (const selector of selectors) selector.cleanup();
					if (canUseFastRemove) {
						parent.textContent = "";
						parent.appendChild(parentAnchor);
					}
				}
				if (opers.length === mountCounter) for (const { source, index, item, key } of opers) mount(source, index, index < newLength - 1 ? normalizeAnchor(newBlocks[index + 1].nodes) : parentAnchor, item, key);
				else if (opers.length) {
					let anchor = oldBlocks[0];
					let blocksTail;
					for (let i = 0; i < oldLength; i++) {
						const block = oldBlocks[i];
						if (oldKeyIndexMap.has(block.key)) continue;
						block.prevAnchor = anchor;
						anchor = oldBlocks[i + 1];
						if (blocksTail !== void 0) {
							blocksTail.next = block;
							block.prev = blocksTail;
						}
						blocksTail = block;
					}
					for (const action of opers) {
						const { index } = action;
						if (index < newLength - 1) {
							const nextBlock = newBlocks[index + 1];
							let anchorNode = normalizeAnchor(nextBlock.prevAnchor.nodes);
							if (!anchorNode.parentNode) anchorNode = normalizeAnchor(nextBlock.nodes);
							if ("source" in action) {
								const { item, key } = action;
								moveLink(mount(source, index, anchorNode, item, key), nextBlock.prev, nextBlock);
							} else if (action.block.next !== nextBlock) {
								insert(action.block, parent, anchorNode);
								moveLink(action.block, nextBlock.prev, nextBlock);
							}
						} else if ("source" in action) {
							const { item, key } = action;
							const block = mount(source, index, parentAnchor, item, key);
							moveLink(block, blocksTail);
							blocksTail = block;
						} else if (action.block.next !== void 0) {
							let anchorNode = anchor ? normalizeAnchor(anchor.nodes) : parentAnchor;
							if (!anchorNode.parentNode) anchorNode = parentAnchor;
							insert(action.block, parent, anchorNode);
							moveLink(action.block, blocksTail);
							blocksTail = action.block;
						}
					}
					for (const block of newBlocks) block.prevAnchor = block.next = block.prev = void 0;
				}
			}
			setCurrentSlotOwner(prevOwner);
		}
		if (!isFallback) {
			frag.nodes = [oldBlocks = newBlocks];
			if (parentAnchor) frag.nodes.push(parentAnchor);
		} else oldBlocks = [];
		if (isMounted && frag.onUpdated) frag.onUpdated.forEach((m) => m());
		setActiveSub(prevSub);
	};
	const needKey = renderItem.length > 1;
	const needIndex = renderItem.length > 2;
	const mount = (source, idx, anchor = parentAnchor, [item, key, index] = getItem(source, idx), key2 = getKey && getKey(item, key, index)) => {
		const itemRef = shallowRef$1(item);
		const keyRef = needKey ? shallowRef$1(key) : void 0;
		const indexRef = needIndex ? shallowRef$1(index) : void 0;
		currentKey = key2;
		let nodes;
		let scope;
		if (isComponent) nodes = renderItem(itemRef, keyRef, indexRef);
		else {
			scope = new EffectScope$1();
			nodes = scope.run(() => renderItem(itemRef, keyRef, indexRef));
		}
		const block = newBlocks[idx] = new ForBlock(nodes, scope, itemRef, keyRef, indexRef, key2);
		if (frag.$transition) applyTransitionHooks(block.nodes, frag.$transition);
		if (parent) insert(block.nodes, parent, anchor);
		return block;
	};
	const update = ({ itemRef, keyRef, indexRef }, newItem, newKey, newIndex) => {
		if (newItem !== itemRef.value) itemRef.value = newItem;
		if (keyRef && newKey !== void 0 && newKey !== keyRef.value) keyRef.value = newKey;
		if (indexRef && newIndex !== void 0 && newIndex !== indexRef.value) indexRef.value = newIndex;
	};
	const unmount = (block, doRemove = true, doDeregister = true) => {
		if (!isComponent) block.scope.stop();
		if (doRemove) remove(block.nodes, parent);
		if (doDeregister) for (const selector of selectors) selector.deregister(block.key);
	};
	if (setup) setup({ createSelector });
	if (flags & 4) renderList();
	else renderEffect(renderList);
	if (!isHydrating$1) {
		if (_insertionParent) insert(frag, _insertionParent, _insertionAnchor);
	} else advanceHydrationNode(_isLastInsertion ? _insertionParent : parentAnchor);
	return frag;
	function createSelector(source) {
		let operMap = /* @__PURE__ */ new Map();
		let activeKey = source();
		let activeOpers;
		watch$1(source, (newValue) => {
			if (activeOpers !== void 0) for (const oper of activeOpers) oper();
			activeOpers = operMap.get(newValue);
			if (activeOpers !== void 0) for (const oper of activeOpers) oper();
		});
		selectors.push({
			deregister,
			cleanup
		});
		return register;
		function cleanup() {
			operMap = /* @__PURE__ */ new Map();
			activeOpers = void 0;
		}
		function register(oper) {
			oper();
			let opers = operMap.get(currentKey);
			if (opers !== void 0) opers.push(oper);
			else {
				opers = [oper];
				operMap.set(currentKey, opers);
				if (currentKey === activeKey) activeOpers = opers;
			}
		}
		function deregister(key) {
			operMap.delete(key);
			if (key === activeKey) activeOpers = void 0;
		}
	}
};
function moveLink(block, newPrev, newNext) {
	const { prev: oldPrev, next: oldNext } = block;
	if (oldPrev) oldPrev.next = oldNext;
	if (oldNext) {
		oldNext.prev = oldPrev;
		if (block.prevAnchor !== block) oldNext.prevAnchor = block.prevAnchor;
	}
	if (newPrev) newPrev.next = block;
	if (newNext) newNext.prev = block;
	block.prev = newPrev;
	block.next = newNext;
	block.prevAnchor = block;
}
function createForSlots(rawSource, getSlot) {
	const source = normalizeSource(rawSource);
	const sourceLength = source.values.length;
	const slots = new Array(sourceLength);
	for (let i = 0; i < sourceLength; i++) slots[i] = getSlot(...getItem(source, i));
	return slots;
}
function normalizeSource(source) {
	let values = source;
	let needsWrap = false;
	let isReadonlySource = false;
	let keys;
	if (isArray(source)) {
		if (isReactive(source)) {
			needsWrap = !isShallow(source);
			values = shallowReadArray(source);
			isReadonlySource = isReadonly(source);
		}
	} else if (isString(source)) values = source.split("");
	else if (typeof source === "number") {
		if (!!(process.env.NODE_ENV !== "production") && !Number.isInteger(source)) warn(`The v-for range expect an integer value but got ${source}.`);
		values = new Array(source);
		for (let i = 0; i < source; i++) values[i] = i + 1;
	} else if (isObject(source)) if (source[Symbol.iterator]) values = Array.from(source);
	else {
		keys = Object.keys(source);
		values = new Array(keys.length);
		for (let i = 0, l = keys.length; i < l; i++) values[i] = source[keys[i]];
	}
	else values = [];
	return {
		values,
		needsWrap,
		isReadonlySource,
		keys
	};
}
function getItem({ keys, values, needsWrap, isReadonlySource }, idx) {
	const value = needsWrap ? isReadonlySource ? toReadonly(toReactive(values[idx])) : toReactive(values[idx]) : values[idx];
	if (keys) return [
		value,
		keys[idx],
		idx
	];
	else return [
		value,
		idx,
		void 0
	];
}
function normalizeAnchor(node) {
	if (node instanceof Node) return node;
	else if (isArray(node)) return normalizeAnchor(node[0]);
	else if (isVaporComponent(node)) return normalizeAnchor(node.block);
	else return normalizeAnchor(node.nodes);
}
function getRestElement(val, keys) {
	const res = {};
	for (const key in val) if (!keys.includes(key)) res[key] = val[key];
	return res;
}
function getDefaultValue(val, defaultVal) {
	return val === void 0 ? defaultVal : val;
}
function isForBlock(block) {
	return block instanceof ForBlock;
}

//#endregion
//#region packages/runtime-vapor/src/apiTemplateRef.ts
const refCleanups = /* @__PURE__ */ new WeakMap();
function ensureCleanup(el) {
	let cleanupRef = refCleanups.get(el);
	if (!cleanupRef) {
		refCleanups.set(el, cleanupRef = { fn: NOOP });
		onScopeDispose$1(() => {
			cleanupRef.fn();
			refCleanups.delete(el);
		});
	}
	return cleanupRef;
}
function createTemplateRefSetter() {
	const instance = currentInstance$1;
	const oldRefMap = /* @__PURE__ */ new WeakMap();
	return (el, ref, refFor, refKey) => {
		const oldRef = setRef$1(instance, el, ref, oldRefMap.get(el), refFor, refKey);
		oldRefMap.set(el, oldRef);
		return oldRef;
	};
}
/**
* Function for handling a template ref
*/
function setRef$1(instance, el, ref, oldRef, refFor = false, refKey) {
	if (!instance || instance.isUnmounted) return;
	if (isFragment(el) && el.setRef) {
		el.setRef(instance, ref, refFor, refKey);
		return;
	}
	if (isVaporComponent(el) && isAsyncWrapper(el)) {
		const frag = el.block;
		if (!el.type.__asyncResolved) {
			frag.setAsyncRef = (i) => setRef$1(instance, i, ref, oldRef, refFor);
			return;
		}
		el = frag.nodes;
	}
	const setupState = !!(process.env.NODE_ENV !== "production") ? instance.setupState || {} : null;
	const refValue = getRefValue(el);
	const refs = instance.refs === EMPTY_OBJ ? instance.refs = {} : instance.refs;
	const canSetSetupRef = !!(process.env.NODE_ENV !== "production") ? createCanSetSetupRefChecker(setupState) : NO;
	if (oldRef != null && oldRef !== ref) {
		if (isString(oldRef)) {
			refs[oldRef] = null;
			if (!!(process.env.NODE_ENV !== "production") && canSetSetupRef(oldRef)) setupState[oldRef] = null;
		} else if (isRef$1(oldRef)) oldRef.value = null;
	}
	if (isFunction(ref)) {
		const invokeRefSetter = (value) => {
			callWithErrorHandling(ref, currentInstance$1, 12, [value, refs]);
		};
		invokeRefSetter(refValue);
		ensureCleanup(el).fn = () => invokeRefSetter(null);
	} else {
		const _isString = isString(ref);
		const _isRef = isRef$1(ref);
		let existing;
		if (_isString || _isRef) {
			const doSet = () => {
				if (refFor) {
					existing = _isString ? !!(process.env.NODE_ENV !== "production") && canSetSetupRef(ref) ? setupState[ref] : refs[ref] : ref.value;
					if (!isArray(existing)) {
						existing = [refValue];
						if (_isString) {
							refs[ref] = existing;
							if (!!(process.env.NODE_ENV !== "production") && canSetSetupRef(ref)) {
								setupState[ref] = refs[ref];
								existing = setupState[ref];
							}
						} else {
							ref.value = existing;
							if (refKey) refs[refKey] = existing;
						}
					} else if (!existing.includes(refValue)) existing.push(refValue);
				} else if (_isString) {
					refs[ref] = refValue;
					if (!!(process.env.NODE_ENV !== "production") && canSetSetupRef(ref)) setupState[ref] = refValue;
				} else if (_isRef) {
					ref.value = refValue;
					if (refKey) refs[refKey] = refValue;
				} else if (!!(process.env.NODE_ENV !== "production")) warn("Invalid template ref type:", ref, `(${typeof ref})`);
			};
			queuePostFlushCb(doSet, -1);
			ensureCleanup(el).fn = () => {
				queuePostFlushCb(() => {
					if (isArray(existing)) remove$1(existing, refValue);
					else if (_isString) {
						refs[ref] = null;
						if (!!(process.env.NODE_ENV !== "production") && canSetSetupRef(ref)) setupState[ref] = null;
					} else if (_isRef) {
						ref.value = null;
						if (refKey) refs[refKey] = null;
					}
				});
			};
		} else if (!!(process.env.NODE_ENV !== "production")) warn("Invalid template ref type:", ref, `(${typeof ref})`);
	}
	return ref;
}
const getRefValue = (el) => {
	if (isVaporComponent(el)) return getExposed(el) || el;
	else if (el instanceof DynamicFragment) return getRefValue(el.nodes);
	return el;
};

//#endregion
//#region packages/runtime-vapor/src/helpers/useCssVars.ts
function useVaporCssVars(getter) {
	const instance = currentInstance;
	baseUseCssVars(instance, () => resolveParentNode(instance.block), getter, (vars) => setVars(instance, vars));
}
function resolveParentNode(block) {
	if (block instanceof Node) return block.parentNode;
	else if (isArray(block)) return resolveParentNode(block[block.length - 1]);
	else if (isVaporComponent(block)) return resolveParentNode(block.block);
	else return resolveParentNode(block.anchor || block.nodes);
}
function setVars(instance, vars) {
	if (instance.ce) setVarsOnNode(instance.ce, vars);
	else setVarsOnBlock(instance.block, vars);
}
function setVarsOnBlock(block, vars) {
	if (block instanceof Node) setVarsOnNode(block, vars);
	else if (isArray(block)) block.forEach((child) => setVarsOnBlock(child, vars));
	else if (isVaporComponent(block)) setVarsOnBlock(block.block, vars);
	else setVarsOnBlock(block.nodes, vars);
}

//#endregion
//#region packages/runtime-vapor/src/apiCreateDynamicComponent.ts
function createDynamicComponent(getter, rawProps, rawSlots, isSingleRoot, once) {
	const _insertionParent = insertionParent;
	const _insertionAnchor = insertionAnchor;
	const _isLastInsertion = isLastInsertion;
	if (!isHydrating$1) resetInsertionState();
	const frag = isHydrating$1 || !!(process.env.NODE_ENV !== "production") ? new DynamicFragment("dynamic-component") : new DynamicFragment();
	const renderFn = () => {
		const value = getter();
		const appContext = currentInstance && currentInstance.appContext || emptyContext;
		frag.update(() => {
			if (isBlock(value)) return value;
			if (appContext.vapor && isVNode(value)) {
				if (isKeepAlive(currentInstance)) {
					const frag = currentInstance.ctx.getCachedComponent(value.type);
					if (frag) return frag;
				}
				const frag = appContext.vapor.vdomMountVNode(value, currentInstance);
				if (isHydrating$1) {
					frag.hydrate();
					if (_isLastInsertion) advanceHydrationNode(_insertionParent);
				}
				return frag;
			}
			return createComponentWithFallback(resolveDynamicComponent(value), rawProps, rawSlots, isSingleRoot, once, appContext);
		}, value);
	};
	if (once) renderFn();
	else renderEffect(renderFn);
	if (!isHydrating$1) {
		if (_insertionParent) insert(frag, _insertionParent, _insertionAnchor);
	} else if (_isLastInsertion) advanceHydrationNode(_insertionParent);
	return frag;
}

//#endregion
//#region packages/runtime-vapor/src/directives/vShow.ts
function applyVShow(target, source) {
	if (isVaporComponent(target)) return applyVShow(target.block, source);
	if (isArray(target) && target.length === 1) return applyVShow(target[0], source);
	if (target instanceof DynamicFragment) {
		const update = target.update;
		target.update = (render, key) => {
			update.call(target, render, key);
			setDisplay(target, source());
		};
	} else if (target instanceof VaporFragment && target.insert) {
		const insert = target.insert;
		target.insert = (parent, anchor) => {
			insert.call(target, parent, anchor);
			setDisplay(target, source());
		};
	}
	renderEffect(() => setDisplay(target, source()));
}
function setDisplay(target, value) {
	if (isVaporComponent(target)) return setDisplay(target.block, value);
	if (isArray(target)) {
		if (target.length === 0) return;
		if (target.length === 1) return setDisplay(target[0], value);
	}
	if (isFragment(target)) return setDisplay(target.nodes, value);
	if (target instanceof Element) {
		const el = target;
		if (!(vShowOriginalDisplay in el)) el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
		const { $transition } = target;
		if ($transition) if (value) {
			$transition.beforeEnter(target);
			el.style.display = el[vShowOriginalDisplay];
			$transition.enter(target);
		} else if (target.isConnected) $transition.leave(target, () => {
			el.style.display = "none";
		});
		else el.style.display = "none";
		else if ((!!(process.env.NODE_ENV !== "production") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && isHydrating$1) {
			if (!value && el.style.display !== "none") {
				warnPropMismatch(el, "style", 3, `display: ${el.style.display}`, "display: none");
				logMismatchError();
				el.style.display = "none";
				el[vShowOriginalDisplay] = "";
			}
		} else el.style.display = value ? el[vShowOriginalDisplay] : "none";
		el[vShowHidden] = !value;
	} else if (!!(process.env.NODE_ENV !== "production")) warn("v-show used on component with non-single-element root node and will be ignored.");
}

//#endregion
//#region packages/runtime-vapor/src/directives/vModel.ts
function ensureMounted(cb) {
	if (currentInstance.isMounted) cb();
	else onMounted(cb);
}
const applyTextModel = (el, get, set, { trim, number, lazy } = {}) => {
	vModelTextInit(el, trim, number, lazy, set);
	ensureMounted(() => {
		let value;
		renderEffect(() => {
			vModelTextUpdate(el, value, value = get(), trim, number, lazy);
		});
	});
};
const applyCheckboxModel = (el, get, set) => {
	vModelCheckboxInit(el, set);
	ensureMounted(() => {
		let value;
		renderEffect(() => {
			vModelCheckboxUpdate(el, value, traverse(value = get()));
		});
	});
};
const applyRadioModel = (el, get, set) => {
	addEventListener(el, "change", () => set(vModelGetValue(el)));
	ensureMounted(() => {
		let value;
		renderEffect(() => {
			if (value !== (value = get())) el.checked = looseEqual(value, vModelGetValue(el));
		});
	});
};
const applySelectModel = (el, get, set, modifiers) => {
	vModelSelectInit(el, get(), modifiers && modifiers.number, set);
	ensureMounted(() => {
		renderEffect(() => vModelSetSelected(el, traverse(get())));
	});
};
const applyDynamicModel = (el, get, set, modifiers) => {
	let apply = applyTextModel;
	if (el.tagName === "SELECT") apply = applySelectModel;
	else if (el.tagName === "TEXTAREA") apply = applyTextModel;
	else if (el.type === "checkbox") apply = applyCheckboxModel;
	else if (el.type === "radio") apply = applyRadioModel;
	apply(el, get, set, modifiers);
};

//#endregion
//#region packages/runtime-vapor/src/directives/custom.ts
function withVaporDirectives(node, dirs) {
	const element = isVaporComponent(node) ? getRootElement(node.block) : node;
	if (!element) {
		if (!!(process.env.NODE_ENV !== "production")) warn("Runtime directive used on component with non-element root node. The directives will not function as intended.");
		return;
	}
	for (const [dir, value, argument, modifiers] of dirs) if (dir) {
		const ret = dir(element, value, argument, modifiers);
		if (ret) onScopeDispose(ret);
	}
}

//#endregion
//#region packages/runtime-vapor/src/components/TransitionGroup.ts
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const decorate = (t) => {
	delete t.props.mode;
	t.__vapor = true;
	return t;
};
const VaporTransitionGroupImpl = {
	name: "VaporTransitionGroup",
	props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
		tag: String,
		moveClass: String
	}),
	setup(props, { slots }) {
		ensureTransitionHooksRegistered();
		const instance = currentInstance;
		const state = useTransitionState();
		let cssTransitionProps = resolveTransitionProps(props);
		const propsProxy = new Proxy({}, { get(_, key) {
			return cssTransitionProps[key];
		} });
		renderEffect(() => {
			cssTransitionProps = resolveTransitionProps(props);
		});
		let prevChildren;
		let children;
		const slottedBlock = slots.default && slots.default();
		onBeforeUpdate(() => {
			prevChildren = [];
			children = getTransitionBlocks(slottedBlock);
			if (children) for (let i = 0; i < children.length; i++) {
				const child = children[i];
				if (isValidTransitionBlock(child)) {
					prevChildren.push(child);
					child.$transition.disabled = true;
					positionMap.set(child, getTransitionElement(child).getBoundingClientRect());
				}
			}
		});
		onUpdated(() => {
			if (!prevChildren.length) return;
			const moveClass = props.moveClass || `${props.name || "v"}-move`;
			const firstChild = getFirstConnectedChild(prevChildren);
			if (!firstChild || !hasCSSTransform(firstChild, firstChild.parentNode, moveClass)) {
				prevChildren = [];
				return;
			}
			prevChildren.forEach(callPendingCbs);
			prevChildren.forEach((child) => {
				child.$transition.disabled = false;
				recordPosition(child);
			});
			const movedChildren = prevChildren.filter(applyTranslation);
			forceReflow();
			movedChildren.forEach((c) => handleMovedChildren(getTransitionElement(c), moveClass));
			prevChildren = [];
		});
		setTransitionHooksOnFragment(slottedBlock, {
			props: propsProxy,
			state,
			instance
		});
		children = getTransitionBlocks(slottedBlock);
		for (let i = 0; i < children.length; i++) {
			const child = children[i];
			if (isValidTransitionBlock(child)) {
				if (child.$key != null) setTransitionHooks$1(child, resolveTransitionHooks(child, propsProxy, state, instance));
				else if (!!(process.env.NODE_ENV !== "production")) warn(`<transition-group> children must be keyed`);
			}
		}
		const tag = props.tag;
		if (tag) {
			const container = /* @__PURE__ */ createElement(tag);
			insert(slottedBlock, container);
			return container;
		} else return slottedBlock;
	}
};
const VaporTransitionGroup = /* @__PURE__ */ decorate(VaporTransitionGroupImpl);
function getTransitionBlocks(block) {
	let children = [];
	if (block instanceof Node) children.push(block);
	else if (isVaporComponent(block)) children.push(...getTransitionBlocks(block.block));
	else if (isArray(block)) for (let i = 0; i < block.length; i++) {
		const b = block[i];
		const blocks = getTransitionBlocks(b);
		if (isForBlock(b)) blocks.forEach((block) => block.$key = b.key);
		children.push(...blocks);
	}
	else if (isFragment(block)) if (block.insert) children.push(block);
	else children.push(...getTransitionBlocks(block.nodes));
	return children;
}
function isValidTransitionBlock(block) {
	return !!(block instanceof Element || isFragment(block) && block.insert);
}
function getTransitionElement(c) {
	return isFragment(c) ? c.nodes : c;
}
function recordPosition(c) {
	newPositionMap.set(c, getTransitionElement(c).getBoundingClientRect());
}
function applyTranslation(c) {
	if (baseApplyTranslation(positionMap.get(c), newPositionMap.get(c), getTransitionElement(c))) return c;
}
function getFirstConnectedChild(children) {
	for (let i = 0; i < children.length; i++) {
		const child = children[i];
		const el = getTransitionElement(child);
		if (el.isConnected) return el;
	}
}

//#endregion
export { VaporElement, VaporFragment, VaporKeepAliveImpl as VaporKeepAlive, VaporTeleportImpl as VaporTeleport, VaporTransition, VaporTransitionGroup, applyCheckboxModel, applyDynamicModel, applyRadioModel, applySelectModel, applyTextModel, applyVShow, child, createComponent, createComponentWithFallback, createDynamicComponent, createFor, createForSlots, createIf, createInvoker, createKeyedFragment, createPlainElement, createSlot, createTemplateRefSetter, createTextNode, createVaporApp, createVaporSSRApp, defineVaporAsyncComponent, defineVaporComponent, defineVaporCustomElement, defineVaporSSRCustomElement, delegate, delegateEvents, getDefaultValue, getRestElement, insert, isFragment, isVaporComponent, next, nthChild, on, prepend, remove, renderEffect, setAttr, setBlockHtml, setBlockText, setClass, setDOMProp, setDynamicEvents, setDynamicProps, setElementText, setHtml, setInsertionState, setProp, setStyle, setText, setValue, template, txt, useVaporCssVars, vaporInteropPlugin, withVaporCtx, withVaporDirectives };