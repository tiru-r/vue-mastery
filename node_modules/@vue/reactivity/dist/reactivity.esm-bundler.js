/**
  * @vue/reactivity v3.6.0-beta.5
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
import { EMPTY_OBJ, NOOP, capitalize, def, extend, hasChanged, hasOwn, isArray, isFunction, isIntegerKey, isMap, isObject, isPlainObject, isSet, isSymbol, makeMap, toRawType } from "@vue/shared";

//#region packages/reactivity/src/debug.ts
const triggerEventInfos = [];
function onTrack(sub, debugInfo) {
	if (!!!(process.env.NODE_ENV !== "production")) throw new Error(`Internal error: onTrack should be called only in development.`);
	if (sub.onTrack) sub.onTrack(extend({ effect: sub }, debugInfo));
}
function onTrigger(sub) {
	if (!!!(process.env.NODE_ENV !== "production")) throw new Error(`Internal error: onTrigger should be called only in development.`);
	if (sub.onTrigger) {
		const debugInfo = triggerEventInfos[triggerEventInfos.length - 1];
		sub.onTrigger(extend({ effect: sub }, debugInfo));
	}
}
function setupOnTrigger(target) {
	if (!!!(process.env.NODE_ENV !== "production")) throw new Error(`Internal error: setupOnTrigger should be called only in development.`);
	Object.defineProperty(target.prototype, "onTrigger", {
		get() {
			return this._onTrigger;
		},
		set(val) {
			if (val && !this._onTrigger) setupFlagsHandler(this);
			this._onTrigger = val;
		}
	});
}
function setupFlagsHandler(target) {
	target._flags = target.flags;
	Object.defineProperty(target, "flags", {
		get() {
			return target._flags;
		},
		set(value) {
			if (!(target._flags & 48) && !!(value & 48)) onTrigger(this);
			target._flags = value;
		}
	});
}

//#endregion
//#region packages/reactivity/src/warning.ts
function warn(msg, ...args) {
	console.warn(`[Vue warn] ${msg}`, ...args);
}

//#endregion
//#region packages/reactivity/src/system.ts
const ReactiveFlags$1 = {
	"None": 0,
	"0": "None",
	"Mutable": 1,
	"1": "Mutable",
	"Watching": 2,
	"2": "Watching",
	"RecursedCheck": 4,
	"4": "RecursedCheck",
	"Recursed": 8,
	"8": "Recursed",
	"Dirty": 16,
	"16": "Dirty",
	"Pending": 32,
	"32": "Pending"
};
const notifyBuffer = [];
let batchDepth = 0;
let activeSub = void 0;
let globalVersion = 0;
let notifyIndex = 0;
let notifyBufferLength = 0;
function setActiveSub(sub) {
	try {
		return activeSub;
	} finally {
		activeSub = sub;
	}
}
function startBatch() {
	++batchDepth;
}
function endBatch() {
	if (!--batchDepth && notifyBufferLength) flush();
}
function link(dep, sub) {
	const prevDep = sub.depsTail;
	if (prevDep !== void 0 && prevDep.dep === dep) return;
	const nextDep = prevDep !== void 0 ? prevDep.nextDep : sub.deps;
	if (nextDep !== void 0 && nextDep.dep === dep) {
		nextDep.version = globalVersion;
		sub.depsTail = nextDep;
		return;
	}
	const prevSub = dep.subsTail;
	if (prevSub !== void 0 && prevSub.version === globalVersion && prevSub.sub === sub) return;
	const newLink = sub.depsTail = dep.subsTail = {
		version: globalVersion,
		dep,
		sub,
		prevDep,
		nextDep,
		prevSub,
		nextSub: void 0
	};
	if (nextDep !== void 0) nextDep.prevDep = newLink;
	if (prevDep !== void 0) prevDep.nextDep = newLink;
	else sub.deps = newLink;
	if (prevSub !== void 0) prevSub.nextSub = newLink;
	else dep.subs = newLink;
}
function unlink(link, sub = link.sub) {
	const dep = link.dep;
	const prevDep = link.prevDep;
	const nextDep = link.nextDep;
	const nextSub = link.nextSub;
	const prevSub = link.prevSub;
	if (nextDep !== void 0) nextDep.prevDep = prevDep;
	else sub.depsTail = prevDep;
	if (prevDep !== void 0) prevDep.nextDep = nextDep;
	else sub.deps = nextDep;
	if (nextSub !== void 0) nextSub.prevSub = prevSub;
	else dep.subsTail = prevSub;
	if (prevSub !== void 0) prevSub.nextSub = nextSub;
	else if ((dep.subs = nextSub) === void 0) {
		let toRemove = dep.deps;
		if (toRemove !== void 0) {
			do
				toRemove = unlink(toRemove, dep);
			while (toRemove !== void 0);
			dep.flags |= 16;
		}
	}
	return nextDep;
}
function propagate(link) {
	let next = link.nextSub;
	let stack;
	top: do {
		const sub = link.sub;
		let flags = sub.flags;
		if (flags & 3) {
			if (!(flags & 60)) sub.flags = flags | 32;
			else if (!(flags & 12)) flags = 0;
			else if (!(flags & 4)) sub.flags = flags & -9 | 32;
			else if (!(flags & 48) && isValidLink(link, sub)) {
				sub.flags = flags | 40;
				flags &= 1;
			} else flags = 0;
			if (flags & 2) notifyBuffer[notifyBufferLength++] = sub;
			if (flags & 1) {
				const subSubs = sub.subs;
				if (subSubs !== void 0) {
					link = subSubs;
					if (subSubs.nextSub !== void 0) {
						stack = {
							value: next,
							prev: stack
						};
						next = link.nextSub;
					}
					continue;
				}
			}
		}
		if ((link = next) !== void 0) {
			next = link.nextSub;
			continue;
		}
		while (stack !== void 0) {
			link = stack.value;
			stack = stack.prev;
			if (link !== void 0) {
				next = link.nextSub;
				continue top;
			}
		}
		break;
	} while (true);
}
function startTracking(sub) {
	++globalVersion;
	sub.depsTail = void 0;
	sub.flags = sub.flags & -57 | 4;
	return setActiveSub(sub);
}
function endTracking(sub, prevSub) {
	if (!!(process.env.NODE_ENV !== "production") && activeSub !== sub) warn("Active effect was not restored correctly - this is likely a Vue internal bug.");
	activeSub = prevSub;
	const depsTail = sub.depsTail;
	let toRemove = depsTail !== void 0 ? depsTail.nextDep : sub.deps;
	while (toRemove !== void 0) toRemove = unlink(toRemove, sub);
	sub.flags &= -5;
}
function flush() {
	while (notifyIndex < notifyBufferLength) {
		const effect = notifyBuffer[notifyIndex];
		notifyBuffer[notifyIndex++] = void 0;
		effect.notify();
	}
	notifyIndex = 0;
	notifyBufferLength = 0;
}
function checkDirty(link, sub) {
	let stack;
	let checkDepth = 0;
	top: do {
		const dep = link.dep;
		const depFlags = dep.flags;
		let dirty = false;
		if (sub.flags & 16) dirty = true;
		else if ((depFlags & 17) === 17) {
			if (dep.update()) {
				const subs = dep.subs;
				if (subs.nextSub !== void 0) shallowPropagate(subs);
				dirty = true;
			}
		} else if ((depFlags & 33) === 33) {
			if (link.nextSub !== void 0 || link.prevSub !== void 0) stack = {
				value: link,
				prev: stack
			};
			link = dep.deps;
			sub = dep;
			++checkDepth;
			continue;
		}
		if (!dirty && link.nextDep !== void 0) {
			link = link.nextDep;
			continue;
		}
		while (checkDepth) {
			--checkDepth;
			const firstSub = sub.subs;
			const hasMultipleSubs = firstSub.nextSub !== void 0;
			if (hasMultipleSubs) {
				link = stack.value;
				stack = stack.prev;
			} else link = firstSub;
			if (dirty) {
				if (sub.update()) {
					if (hasMultipleSubs) shallowPropagate(firstSub);
					sub = link.sub;
					continue;
				}
			} else sub.flags &= -33;
			sub = link.sub;
			if (link.nextDep !== void 0) {
				link = link.nextDep;
				continue top;
			}
			dirty = false;
		}
		return dirty;
	} while (true);
}
function shallowPropagate(link) {
	do {
		const sub = link.sub;
		const nextSub = link.nextSub;
		const subFlags = sub.flags;
		if ((subFlags & 48) === 32) sub.flags = subFlags | 16;
		link = nextSub;
	} while (link !== void 0);
}
function isValidLink(checkLink, sub) {
	let link = sub.depsTail;
	while (link !== void 0) {
		if (link === checkLink) return true;
		link = link.prevDep;
	}
	return false;
}

//#endregion
//#region packages/reactivity/src/dep.ts
var Dep = class {
	constructor(map, key) {
		this.map = map;
		this.key = key;
		this._subs = void 0;
		this.subsTail = void 0;
		this.flags = 0;
	}
	get subs() {
		return this._subs;
	}
	set subs(value) {
		this._subs = value;
		if (value === void 0) this.map.delete(this.key);
	}
};
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== "production") ? "Object iterate" : "");
const MAP_KEY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== "production") ? "Map keys iterate" : "");
const ARRAY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== "production") ? "Array iterate" : "");
/**
* Tracks access to a reactive property.
*
* This will check which effect is running at the moment and record it as dep
* which records all effects that depend on the reactive property.
*
* @param target - Object holding the reactive property.
* @param type - Defines the type of access to the reactive property.
* @param key - Identifier of the reactive property to track.
*/
function track(target, type, key) {
	if (activeSub !== void 0) {
		let depsMap = targetMap.get(target);
		if (!depsMap) targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
		let dep = depsMap.get(key);
		if (!dep) depsMap.set(key, dep = new Dep(depsMap, key));
		if (!!(process.env.NODE_ENV !== "production")) onTrack(activeSub, {
			target,
			type,
			key
		});
		link(dep, activeSub);
	}
}
/**
* Finds all deps associated with the target (or a specific property) and
* triggers the effects stored within.
*
* @param target - The reactive object.
* @param type - Defines the type of the operation that needs to trigger effects.
* @param key - Can be used to target a specific reactive property in the target object.
*/
function trigger(target, type, key, newValue, oldValue, oldTarget) {
	const depsMap = targetMap.get(target);
	if (!depsMap) return;
	const run = (dep) => {
		if (dep !== void 0 && dep.subs !== void 0) {
			if (!!(process.env.NODE_ENV !== "production")) triggerEventInfos.push({
				target,
				type,
				key,
				newValue,
				oldValue,
				oldTarget
			});
			propagate(dep.subs);
			shallowPropagate(dep.subs);
			if (!!(process.env.NODE_ENV !== "production")) triggerEventInfos.pop();
		}
	};
	startBatch();
	if (type === "clear") depsMap.forEach(run);
	else {
		const targetIsArray = isArray(target);
		const isArrayIndex = targetIsArray && isIntegerKey(key);
		if (targetIsArray && key === "length") {
			const newLength = Number(newValue);
			depsMap.forEach((dep, key) => {
				if (key === "length" || key === ARRAY_ITERATE_KEY || !isSymbol(key) && key >= newLength) run(dep);
			});
		} else {
			if (key !== void 0 || depsMap.has(void 0)) run(depsMap.get(key));
			if (isArrayIndex) run(depsMap.get(ARRAY_ITERATE_KEY));
			switch (type) {
				case "add":
					if (!targetIsArray) {
						run(depsMap.get(ITERATE_KEY));
						if (isMap(target)) run(depsMap.get(MAP_KEY_ITERATE_KEY));
					} else if (isArrayIndex) run(depsMap.get("length"));
					break;
				case "delete":
					if (!targetIsArray) {
						run(depsMap.get(ITERATE_KEY));
						if (isMap(target)) run(depsMap.get(MAP_KEY_ITERATE_KEY));
					}
					break;
				case "set":
					if (isMap(target)) run(depsMap.get(ITERATE_KEY));
					break;
			}
		}
	}
	endBatch();
}
function getDepFromReactive(object, key) {
	const depMap = targetMap.get(object);
	return depMap && depMap.get(key);
}

//#endregion
//#region packages/reactivity/src/arrayInstrumentations.ts
/**
* Track array iteration and return:
* - if input is reactive: a cloned raw array with reactive values
* - if input is non-reactive or shallowReactive: the original raw array
*/
function reactiveReadArray(array) {
	const raw = /* @__PURE__ */ toRaw(array);
	if (raw === array) return raw;
	track(raw, "iterate", ARRAY_ITERATE_KEY);
	return /* @__PURE__ */ isShallow(array) ? raw : raw.map(toReactive);
}
/**
* Track array iteration and return raw array
*/
function shallowReadArray(arr) {
	track(arr = /* @__PURE__ */ toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
	return arr;
}
function toWrapped(target, item) {
	if (/* @__PURE__ */ isReadonly(target)) return /* @__PURE__ */ isReactive(target) ? toReadonly(toReactive(item)) : toReadonly(item);
	return toReactive(item);
}
const arrayInstrumentations = {
	__proto__: null,
	[Symbol.iterator]() {
		return iterator(this, Symbol.iterator, (item) => toWrapped(this, item));
	},
	concat(...args) {
		return reactiveReadArray(this).concat(...args.map((x) => isArray(x) ? reactiveReadArray(x) : x));
	},
	entries() {
		return iterator(this, "entries", (value) => {
			value[1] = toWrapped(this, value[1]);
			return value;
		});
	},
	every(fn, thisArg) {
		return apply(this, "every", fn, thisArg, void 0, arguments);
	},
	filter(fn, thisArg) {
		return apply(this, "filter", fn, thisArg, (v) => v.map((item) => toWrapped(this, item)), arguments);
	},
	find(fn, thisArg) {
		return apply(this, "find", fn, thisArg, (item) => toWrapped(this, item), arguments);
	},
	findIndex(fn, thisArg) {
		return apply(this, "findIndex", fn, thisArg, void 0, arguments);
	},
	findLast(fn, thisArg) {
		return apply(this, "findLast", fn, thisArg, (item) => toWrapped(this, item), arguments);
	},
	findLastIndex(fn, thisArg) {
		return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
	},
	forEach(fn, thisArg) {
		return apply(this, "forEach", fn, thisArg, void 0, arguments);
	},
	includes(...args) {
		return searchProxy(this, "includes", args);
	},
	indexOf(...args) {
		return searchProxy(this, "indexOf", args);
	},
	join(separator) {
		return reactiveReadArray(this).join(separator);
	},
	lastIndexOf(...args) {
		return searchProxy(this, "lastIndexOf", args);
	},
	map(fn, thisArg) {
		return apply(this, "map", fn, thisArg, void 0, arguments);
	},
	pop() {
		return noTracking(this, "pop");
	},
	push(...args) {
		return noTracking(this, "push", args);
	},
	reduce(fn, ...args) {
		return reduce(this, "reduce", fn, args);
	},
	reduceRight(fn, ...args) {
		return reduce(this, "reduceRight", fn, args);
	},
	shift() {
		return noTracking(this, "shift");
	},
	some(fn, thisArg) {
		return apply(this, "some", fn, thisArg, void 0, arguments);
	},
	splice(...args) {
		return noTracking(this, "splice", args);
	},
	toReversed() {
		return reactiveReadArray(this).toReversed();
	},
	toSorted(comparer) {
		return reactiveReadArray(this).toSorted(comparer);
	},
	toSpliced(...args) {
		return reactiveReadArray(this).toSpliced(...args);
	},
	unshift(...args) {
		return noTracking(this, "unshift", args);
	},
	values() {
		return iterator(this, "values", (item) => toWrapped(this, item));
	}
};
function iterator(self, method, wrapValue) {
	const arr = shallowReadArray(self);
	const iter = arr[method]();
	if (arr !== self && !/* @__PURE__ */ isShallow(self)) {
		iter._next = iter.next;
		iter.next = () => {
			const result = iter._next();
			if (!result.done) result.value = wrapValue(result.value);
			return result;
		};
	}
	return iter;
}
const arrayProto = Array.prototype;
function apply(self, method, fn, thisArg, wrappedRetFn, args) {
	const arr = shallowReadArray(self);
	const needsWrap = arr !== self && !/* @__PURE__ */ isShallow(self);
	const methodFn = arr[method];
	if (methodFn !== arrayProto[method]) {
		const result = methodFn.apply(self, args);
		return needsWrap ? toReactive(result) : result;
	}
	let wrappedFn = fn;
	if (arr !== self) {
		if (needsWrap) wrappedFn = function(item, index) {
			return fn.call(this, toWrapped(self, item), index, self);
		};
		else if (fn.length > 2) wrappedFn = function(item, index) {
			return fn.call(this, item, index, self);
		};
	}
	const result = methodFn.call(arr, wrappedFn, thisArg);
	return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self, method, fn, args) {
	const arr = shallowReadArray(self);
	let wrappedFn = fn;
	if (arr !== self) {
		if (!/* @__PURE__ */ isShallow(self)) wrappedFn = function(acc, item, index) {
			return fn.call(this, acc, toWrapped(self, item), index, self);
		};
		else if (fn.length > 3) wrappedFn = function(acc, item, index) {
			return fn.call(this, acc, item, index, self);
		};
	}
	return arr[method](wrappedFn, ...args);
}
function searchProxy(self, method, args) {
	const arr = /* @__PURE__ */ toRaw(self);
	track(arr, "iterate", ARRAY_ITERATE_KEY);
	const res = arr[method](...args);
	if ((res === -1 || res === false) && /* @__PURE__ */ isProxy(args[0])) {
		args[0] = /* @__PURE__ */ toRaw(args[0]);
		return arr[method](...args);
	}
	return res;
}
function noTracking(self, method, args = []) {
	startBatch();
	const prevSub = setActiveSub();
	const res = (/* @__PURE__ */ toRaw(self))[method].apply(self, args);
	setActiveSub(prevSub);
	endBatch();
	return res;
}

//#endregion
//#region packages/reactivity/src/baseHandlers.ts
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol));
function hasOwnProperty(key) {
	if (!isSymbol(key)) key = String(key);
	const obj = /* @__PURE__ */ toRaw(this);
	track(obj, "has", key);
	return obj.hasOwnProperty(key);
}
var BaseReactiveHandler = class {
	constructor(_isReadonly = false, _isShallow = false) {
		this._isReadonly = _isReadonly;
		this._isShallow = _isShallow;
	}
	get(target, key, receiver) {
		if (key === "__v_skip") return target["__v_skip"];
		const isReadonly = this._isReadonly, isShallow = this._isShallow;
		if (key === "__v_isReactive") return !isReadonly;
		else if (key === "__v_isReadonly") return isReadonly;
		else if (key === "__v_isShallow") return isShallow;
		else if (key === "__v_raw") {
			if (receiver === (isReadonly ? isShallow ? shallowReadonlyMap : readonlyMap : isShallow ? shallowReactiveMap : reactiveMap).get(target) || Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) return target;
			return;
		}
		const targetIsArray = isArray(target);
		if (!isReadonly) {
			let fn;
			if (targetIsArray && (fn = arrayInstrumentations[key])) return fn;
			if (key === "hasOwnProperty") return hasOwnProperty;
		}
		const wasRef = /* @__PURE__ */ isRef(target);
		const res = Reflect.get(target, key, wasRef ? target : receiver);
		if (wasRef && key !== "value") return res;
		if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) return res;
		if (!isReadonly) track(target, "get", key);
		if (isShallow) return res;
		if (/* @__PURE__ */ isRef(res)) {
			const value = targetIsArray && isIntegerKey(key) ? res : res.value;
			return isReadonly && isObject(value) ? /* @__PURE__ */ readonly(value) : value;
		}
		if (isObject(res)) return isReadonly ? /* @__PURE__ */ readonly(res) : /* @__PURE__ */ reactive(res);
		return res;
	}
};
var MutableReactiveHandler = class extends BaseReactiveHandler {
	constructor(isShallow = false) {
		super(false, isShallow);
	}
	set(target, key, value, receiver) {
		let oldValue = target[key];
		const isArrayWithIntegerKey = isArray(target) && isIntegerKey(key);
		if (!this._isShallow) {
			const isOldValueReadonly = /* @__PURE__ */ isReadonly(oldValue);
			if (!/* @__PURE__ */ isShallow(value) && !/* @__PURE__ */ isReadonly(value)) {
				oldValue = /* @__PURE__ */ toRaw(oldValue);
				value = /* @__PURE__ */ toRaw(value);
			}
			if (!isArrayWithIntegerKey && /* @__PURE__ */ isRef(oldValue) && !/* @__PURE__ */ isRef(value)) if (isOldValueReadonly) {
				if (!!(process.env.NODE_ENV !== "production")) warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target[key]);
				return true;
			} else {
				oldValue.value = value;
				return true;
			}
		}
		const hadKey = isArrayWithIntegerKey ? Number(key) < target.length : hasOwn(target, key);
		const result = Reflect.set(target, key, value, /* @__PURE__ */ isRef(target) ? target : receiver);
		if (target === /* @__PURE__ */ toRaw(receiver)) {
			if (!hadKey) trigger(target, "add", key, value);
			else if (hasChanged(value, oldValue)) trigger(target, "set", key, value, oldValue);
		}
		return result;
	}
	deleteProperty(target, key) {
		const hadKey = hasOwn(target, key);
		const oldValue = target[key];
		const result = Reflect.deleteProperty(target, key);
		if (result && hadKey) trigger(target, "delete", key, void 0, oldValue);
		return result;
	}
	has(target, key) {
		const result = Reflect.has(target, key);
		if (!isSymbol(key) || !builtInSymbols.has(key)) track(target, "has", key);
		return result;
	}
	ownKeys(target) {
		track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
		return Reflect.ownKeys(target);
	}
};
var ReadonlyReactiveHandler = class extends BaseReactiveHandler {
	constructor(isShallow = false) {
		super(true, isShallow);
	}
	set(target, key) {
		if (!!(process.env.NODE_ENV !== "production")) warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
		return true;
	}
	deleteProperty(target, key) {
		if (!!(process.env.NODE_ENV !== "production")) warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
		return true;
	}
};
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);

//#endregion
//#region packages/reactivity/src/collectionHandlers.ts
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function createIterableMethod(method, isReadonly, isShallow) {
	return function(...args) {
		const target = this["__v_raw"];
		const rawTarget = /* @__PURE__ */ toRaw(target);
		const targetIsMap = isMap(rawTarget);
		const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
		const isKeyOnly = method === "keys" && targetIsMap;
		const innerIterator = target[method](...args);
		const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
		!isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
		return extend(Object.create(innerIterator), { next() {
			const { value, done } = innerIterator.next();
			return done ? {
				value,
				done
			} : {
				value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
				done
			};
		} });
	};
}
function createReadonlyMethod(type) {
	return function(...args) {
		if (!!(process.env.NODE_ENV !== "production")) {
			const key = args[0] ? `on key "${args[0]}" ` : ``;
			warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, /* @__PURE__ */ toRaw(this));
		}
		return type === "delete" ? false : type === "clear" ? void 0 : this;
	};
}
function createInstrumentations(readonly, shallow) {
	const instrumentations = {
		get(key) {
			const target = this["__v_raw"];
			const rawTarget = /* @__PURE__ */ toRaw(target);
			const rawKey = /* @__PURE__ */ toRaw(key);
			if (!readonly) {
				if (hasChanged(key, rawKey)) track(rawTarget, "get", key);
				track(rawTarget, "get", rawKey);
			}
			const { has } = getProto(rawTarget);
			const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;
			if (has.call(rawTarget, key)) return wrap(target.get(key));
			else if (has.call(rawTarget, rawKey)) return wrap(target.get(rawKey));
			else if (target !== rawTarget) target.get(key);
		},
		get size() {
			const target = this["__v_raw"];
			!readonly && track(/* @__PURE__ */ toRaw(target), "iterate", ITERATE_KEY);
			return target.size;
		},
		has(key) {
			const target = this["__v_raw"];
			const rawTarget = /* @__PURE__ */ toRaw(target);
			const rawKey = /* @__PURE__ */ toRaw(key);
			if (!readonly) {
				if (hasChanged(key, rawKey)) track(rawTarget, "has", key);
				track(rawTarget, "has", rawKey);
			}
			return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
		},
		forEach(callback, thisArg) {
			const observed = this;
			const target = observed["__v_raw"];
			const rawTarget = /* @__PURE__ */ toRaw(target);
			const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;
			!readonly && track(rawTarget, "iterate", ITERATE_KEY);
			return target.forEach((value, key) => {
				return callback.call(thisArg, wrap(value), wrap(key), observed);
			});
		}
	};
	extend(instrumentations, readonly ? {
		add: createReadonlyMethod("add"),
		set: createReadonlyMethod("set"),
		delete: createReadonlyMethod("delete"),
		clear: createReadonlyMethod("clear")
	} : {
		add(value) {
			if (!shallow && !/* @__PURE__ */ isShallow(value) && !/* @__PURE__ */ isReadonly(value)) value = /* @__PURE__ */ toRaw(value);
			const target = /* @__PURE__ */ toRaw(this);
			if (!getProto(target).has.call(target, value)) {
				target.add(value);
				trigger(target, "add", value, value);
			}
			return this;
		},
		set(key, value) {
			if (!shallow && !/* @__PURE__ */ isShallow(value) && !/* @__PURE__ */ isReadonly(value)) value = /* @__PURE__ */ toRaw(value);
			const target = /* @__PURE__ */ toRaw(this);
			const { has, get } = getProto(target);
			let hadKey = has.call(target, key);
			if (!hadKey) {
				key = /* @__PURE__ */ toRaw(key);
				hadKey = has.call(target, key);
			} else if (!!(process.env.NODE_ENV !== "production")) checkIdentityKeys(target, has, key);
			const oldValue = get.call(target, key);
			target.set(key, value);
			if (!hadKey) trigger(target, "add", key, value);
			else if (hasChanged(value, oldValue)) trigger(target, "set", key, value, oldValue);
			return this;
		},
		delete(key) {
			const target = /* @__PURE__ */ toRaw(this);
			const { has, get } = getProto(target);
			let hadKey = has.call(target, key);
			if (!hadKey) {
				key = /* @__PURE__ */ toRaw(key);
				hadKey = has.call(target, key);
			} else if (!!(process.env.NODE_ENV !== "production")) checkIdentityKeys(target, has, key);
			const oldValue = get ? get.call(target, key) : void 0;
			const result = target.delete(key);
			if (hadKey) trigger(target, "delete", key, void 0, oldValue);
			return result;
		},
		clear() {
			const target = /* @__PURE__ */ toRaw(this);
			const hadItems = target.size !== 0;
			const oldTarget = !!(process.env.NODE_ENV !== "production") ? isMap(target) ? new Map(target) : new Set(target) : void 0;
			const result = target.clear();
			if (hadItems) trigger(target, "clear", void 0, void 0, oldTarget);
			return result;
		}
	});
	[
		"keys",
		"values",
		"entries",
		Symbol.iterator
	].forEach((method) => {
		instrumentations[method] = createIterableMethod(method, readonly, shallow);
	});
	return instrumentations;
}
function createInstrumentationGetter(isReadonly, shallow) {
	const instrumentations = createInstrumentations(isReadonly, shallow);
	return (target, key, receiver) => {
		if (key === "__v_isReactive") return !isReadonly;
		else if (key === "__v_isReadonly") return isReadonly;
		else if (key === "__v_raw") return target;
		return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
	};
}
const mutableCollectionHandlers = { get: /* @__PURE__ */ createInstrumentationGetter(false, false) };
const shallowCollectionHandlers = { get: /* @__PURE__ */ createInstrumentationGetter(false, true) };
const readonlyCollectionHandlers = { get: /* @__PURE__ */ createInstrumentationGetter(true, false) };
const shallowReadonlyCollectionHandlers = { get: /* @__PURE__ */ createInstrumentationGetter(true, true) };
function checkIdentityKeys(target, has, key) {
	const rawKey = /* @__PURE__ */ toRaw(key);
	if (rawKey !== key && has.call(target, rawKey)) {
		const type = toRawType(target);
		warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
	}
}

//#endregion
//#region packages/reactivity/src/reactive.ts
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
	switch (rawType) {
		case "Object":
		case "Array": return 1;
		case "Map":
		case "Set":
		case "WeakMap":
		case "WeakSet": return 2;
		default: return 0;
	}
}
function getTargetType(value) {
	return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
/* @__NO_SIDE_EFFECTS__ */
function reactive(target) {
	if (/* @__PURE__ */ isReadonly(target)) return target;
	return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
/**
* Shallow version of {@link reactive}.
*
* Unlike {@link reactive}, there is no deep conversion: only root-level
* properties are reactive for a shallow reactive object. Property values are
* stored and exposed as-is - this also means properties with ref values will
* not be automatically unwrapped.
*
* @example
* ```js
* const state = shallowReactive({
*   foo: 1,
*   nested: {
*     bar: 2
*   }
* })
*
* // mutating state's own properties is reactive
* state.foo++
*
* // ...but does not convert nested objects
* isReactive(state.nested) // false
*
* // NOT reactive
* state.nested.bar++
* ```
*
* @param target - The source object.
* @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowreactive}
*/
/* @__NO_SIDE_EFFECTS__ */
function shallowReactive(target) {
	return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
/**
* Takes an object (reactive or plain) or a ref and returns a readonly proxy to
* the original.
*
* A readonly proxy is deep: any nested property accessed will be readonly as
* well. It also has the same ref-unwrapping behavior as {@link reactive},
* except the unwrapped values will also be made readonly.
*
* @example
* ```js
* const original = reactive({ count: 0 })
*
* const copy = readonly(original)
*
* watchEffect(() => {
*   // works for reactivity tracking
*   console.log(copy.count)
* })
*
* // mutating original will trigger watchers relying on the copy
* original.count++
*
* // mutating the copy will fail and result in a warning
* copy.count++ // warning!
* ```
*
* @param target - The source object.
* @see {@link https://vuejs.org/api/reactivity-core.html#readonly}
*/
/* @__NO_SIDE_EFFECTS__ */
function readonly(target) {
	return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
/**
* Shallow version of {@link readonly}.
*
* Unlike {@link readonly}, there is no deep conversion: only root-level
* properties are made readonly. Property values are stored and exposed as-is -
* this also means properties with ref values will not be automatically
* unwrapped.
*
* @example
* ```js
* const state = shallowReadonly({
*   foo: 1,
*   nested: {
*     bar: 2
*   }
* })
*
* // mutating state's own properties will fail
* state.foo++
*
* // ...but works on nested objects
* isReadonly(state.nested) // false
*
* // works
* state.nested.bar++
* ```
*
* @param target - The source object.
* @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowreadonly}
*/
/* @__NO_SIDE_EFFECTS__ */
function shallowReadonly(target) {
	return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
	if (!isObject(target)) {
		if (!!(process.env.NODE_ENV !== "production")) warn(`value cannot be made ${isReadonly ? "readonly" : "reactive"}: ${String(target)}`);
		return target;
	}
	if (target["__v_raw"] && !(isReadonly && target["__v_isReactive"])) return target;
	const targetType = getTargetType(target);
	if (targetType === 0) return target;
	const existingProxy = proxyMap.get(target);
	if (existingProxy) return existingProxy;
	const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
	proxyMap.set(target, proxy);
	return proxy;
}
/**
* Checks if an object is a proxy created by {@link reactive} or
* {@link shallowReactive} (or {@link ref} in some cases).
*
* @example
* ```js
* isReactive(reactive({}))            // => true
* isReactive(readonly(reactive({})))  // => true
* isReactive(ref({}).value)           // => true
* isReactive(readonly(ref({})).value) // => true
* isReactive(ref(true))               // => false
* isReactive(shallowRef({}).value)    // => false
* isReactive(shallowReactive({}))     // => true
* ```
*
* @param value - The value to check.
* @see {@link https://vuejs.org/api/reactivity-utilities.html#isreactive}
*/
/* @__NO_SIDE_EFFECTS__ */
function isReactive(value) {
	if (/* @__PURE__ */ isReadonly(value)) return /* @__PURE__ */ isReactive(value["__v_raw"]);
	return !!(value && value["__v_isReactive"]);
}
/**
* Checks whether the passed value is a readonly object. The properties of a
* readonly object can change, but they can't be assigned directly via the
* passed object.
*
* The proxies created by {@link readonly} and {@link shallowReadonly} are
* both considered readonly, as is a computed ref without a set function.
*
* @param value - The value to check.
* @see {@link https://vuejs.org/api/reactivity-utilities.html#isreadonly}
*/
/* @__NO_SIDE_EFFECTS__ */
function isReadonly(value) {
	return !!(value && value["__v_isReadonly"]);
}
/* @__NO_SIDE_EFFECTS__ */
function isShallow(value) {
	return !!(value && value["__v_isShallow"]);
}
/**
* Checks if an object is a proxy created by {@link reactive},
* {@link readonly}, {@link shallowReactive} or {@link shallowReadonly}.
*
* @param value - The value to check.
* @see {@link https://vuejs.org/api/reactivity-utilities.html#isproxy}
*/
/* @__NO_SIDE_EFFECTS__ */
function isProxy(value) {
	return value ? !!value["__v_raw"] : false;
}
/**
* Returns the raw, original object of a Vue-created proxy.
*
* `toRaw()` can return the original object from proxies created by
* {@link reactive}, {@link readonly}, {@link shallowReactive} or
* {@link shallowReadonly}.
*
* This is an escape hatch that can be used to temporarily read without
* incurring proxy access / tracking overhead or write without triggering
* changes. It is **not** recommended to hold a persistent reference to the
* original object. Use with caution.
*
* @example
* ```js
* const foo = {}
* const reactiveFoo = reactive(foo)
*
* console.log(toRaw(reactiveFoo) === foo) // true
* ```
*
* @param observed - The object for which the "raw" value is requested.
* @see {@link https://vuejs.org/api/reactivity-advanced.html#toraw}
*/
/* @__NO_SIDE_EFFECTS__ */
function toRaw(observed) {
	const raw = observed && observed["__v_raw"];
	return raw ? /* @__PURE__ */ toRaw(raw) : observed;
}
/**
* Marks an object so that it will never be converted to a proxy. Returns the
* object itself.
*
* @example
* ```js
* const foo = markRaw({})
* console.log(isReactive(reactive(foo))) // false
*
* // also works when nested inside other reactive objects
* const bar = reactive({ foo })
* console.log(isReactive(bar.foo)) // false
* ```
*
* **Warning:** `markRaw()` together with the shallow APIs such as
* {@link shallowReactive} allow you to selectively opt-out of the default
* deep reactive/readonly conversion and embed raw, non-proxied objects in your
* state graph.
*
* @param value - The object to be marked as "raw".
* @see {@link https://vuejs.org/api/reactivity-advanced.html#markraw}
*/
function markRaw(value) {
	if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) def(value, "__v_skip", true);
	return value;
}
/**
* Returns a reactive proxy of the given value (if possible).
*
* If the given value is not an object, the original value itself is returned.
*
* @param value - The value for which a reactive proxy shall be created.
*/
const toReactive = (value) => isObject(value) ? /* @__PURE__ */ reactive(value) : value;
/**
* Returns a readonly proxy of the given value (if possible).
*
* If the given value is not an object, the original value itself is returned.
*
* @param value - The value for which a readonly proxy shall be created.
*/
const toReadonly = (value) => isObject(value) ? /* @__PURE__ */ readonly(value) : value;

//#endregion
//#region packages/reactivity/src/ref.ts
/* @__NO_SIDE_EFFECTS__ */
function isRef(r) {
	return r ? r["__v_isRef"] === true : false;
}
/* @__NO_SIDE_EFFECTS__ */
function ref(value) {
	return createRef(value, toReactive);
}
/* @__NO_SIDE_EFFECTS__ */
function shallowRef(value) {
	return createRef(value);
}
function createRef(rawValue, wrap) {
	if (/* @__PURE__ */ isRef(rawValue)) return rawValue;
	return new RefImpl(rawValue, wrap);
}
/**
* @internal
*/
var RefImpl = class {
	constructor(value, wrap) {
		this.subs = void 0;
		this.subsTail = void 0;
		this.flags = ReactiveFlags$1.Mutable;
		this.__v_isRef = true;
		this.__v_isShallow = false;
		this._oldValue = this._rawValue = wrap ? /* @__PURE__ */ toRaw(value) : value;
		this._value = wrap ? wrap(value) : value;
		this._wrap = wrap;
		this["__v_isShallow"] = !wrap;
	}
	get dep() {
		return this;
	}
	get value() {
		trackRef(this);
		if (this.flags & ReactiveFlags$1.Dirty && this.update()) {
			const subs = this.subs;
			if (subs !== void 0) shallowPropagate(subs);
		}
		return this._value;
	}
	set value(newValue) {
		const oldValue = this._rawValue;
		const useDirectValue = this["__v_isShallow"] || /* @__PURE__ */ isShallow(newValue) || /* @__PURE__ */ isReadonly(newValue);
		newValue = useDirectValue ? newValue : /* @__PURE__ */ toRaw(newValue);
		if (hasChanged(newValue, oldValue)) {
			this.flags |= ReactiveFlags$1.Dirty;
			this._rawValue = newValue;
			this._value = !useDirectValue && this._wrap ? this._wrap(newValue) : newValue;
			const subs = this.subs;
			if (subs !== void 0) {
				if (!!(process.env.NODE_ENV !== "production")) triggerEventInfos.push({
					target: this,
					type: "set",
					key: "value",
					newValue,
					oldValue
				});
				propagate(subs);
				if (!batchDepth) flush();
				if (!!(process.env.NODE_ENV !== "production")) triggerEventInfos.pop();
			}
		}
	}
	update() {
		this.flags &= ~ReactiveFlags$1.Dirty;
		return hasChanged(this._oldValue, this._oldValue = this._rawValue);
	}
};
/**
* Force trigger effects that depends on a shallow ref. This is typically used
* after making deep mutations to the inner value of a shallow ref.
*
* @example
* ```js
* const shallow = shallowRef({
*   greet: 'Hello, world'
* })
*
* // Logs "Hello, world" once for the first run-through
* watchEffect(() => {
*   console.log(shallow.value.greet)
* })
*
* // This won't trigger the effect because the ref is shallow
* shallow.value.greet = 'Hello, universe'
*
* // Logs "Hello, universe"
* triggerRef(shallow)
* ```
*
* @param ref - The ref whose tied effects shall be executed.
* @see {@link https://vuejs.org/api/reactivity-advanced.html#triggerref}
*/
function triggerRef(ref) {
	const dep = ref.dep;
	if (dep !== void 0 && dep.subs !== void 0) {
		propagate(dep.subs);
		shallowPropagate(dep.subs);
		if (!batchDepth) flush();
	}
}
function trackRef(dep) {
	if (activeSub !== void 0) {
		if (!!(process.env.NODE_ENV !== "production")) onTrack(activeSub, {
			target: dep,
			type: "get",
			key: "value"
		});
		link(dep, activeSub);
	}
}
/**
* Returns the inner value if the argument is a ref, otherwise return the
* argument itself. This is a sugar function for
* `val = isRef(val) ? val.value : val`.
*
* @example
* ```js
* function useFoo(x: number | Ref<number>) {
*   const unwrapped = unref(x)
*   // unwrapped is guaranteed to be number now
* }
* ```
*
* @param ref - Ref or plain value to be converted into the plain value.
* @see {@link https://vuejs.org/api/reactivity-utilities.html#unref}
*/
function unref(ref) {
	return /* @__PURE__ */ isRef(ref) ? ref.value : ref;
}
/**
* Normalizes values / refs / getters to values.
* This is similar to {@link unref}, except that it also normalizes getters.
* If the argument is a getter, it will be invoked and its return value will
* be returned.
*
* @example
* ```js
* toValue(1) // 1
* toValue(ref(1)) // 1
* toValue(() => 1) // 1
* ```
*
* @param source - A getter, an existing ref, or a non-function value.
* @see {@link https://vuejs.org/api/reactivity-utilities.html#tovalue}
*/
function toValue(source) {
	return isFunction(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
	get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
	set: (target, key, value, receiver) => {
		const oldValue = target[key];
		if (/* @__PURE__ */ isRef(oldValue) && !/* @__PURE__ */ isRef(value)) {
			oldValue.value = value;
			return true;
		} else return Reflect.set(target, key, value, receiver);
	}
};
/**
* Returns a proxy for the given object that shallowly unwraps properties that
* are refs. If the object already is reactive, it's returned as-is. If not, a
* new reactive proxy is created.
*
* @param objectWithRefs - Either an already-reactive object or a simple object
* that contains refs.
*/
function proxyRefs(objectWithRefs) {
	return /* @__PURE__ */ isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
var CustomRefImpl = class {
	constructor(factory) {
		this.subs = void 0;
		this.subsTail = void 0;
		this.flags = ReactiveFlags$1.None;
		this["__v_isRef"] = true;
		this._value = void 0;
		const { get, set } = factory(() => trackRef(this), () => triggerRef(this));
		this._get = get;
		this._set = set;
	}
	get dep() {
		return this;
	}
	get value() {
		return this._value = this._get();
	}
	set value(newVal) {
		this._set(newVal);
	}
};
/**
* Creates a customized ref with explicit control over its dependency tracking
* and updates triggering.
*
* @param factory - The function that receives the `track` and `trigger` callbacks.
* @see {@link https://vuejs.org/api/reactivity-advanced.html#customref}
*/
function customRef(factory) {
	return new CustomRefImpl(factory);
}
/**
* Converts a reactive object to a plain object where each property of the
* resulting object is a ref pointing to the corresponding property of the
* original object. Each individual ref is created using {@link toRef}.
*
* @param object - Reactive object to be made into an object of linked refs.
* @see {@link https://vuejs.org/api/reactivity-utilities.html#torefs}
*/
/* @__NO_SIDE_EFFECTS__ */
function toRefs(object) {
	const ret = isArray(object) ? new Array(object.length) : {};
	for (const key in object) ret[key] = propertyToRef(object, key);
	return ret;
}
var ObjectRefImpl = class {
	constructor(_object, _key, _defaultValue) {
		this._object = _object;
		this._key = _key;
		this._defaultValue = _defaultValue;
		this["__v_isRef"] = true;
		this._value = void 0;
		this._raw = /* @__PURE__ */ toRaw(_object);
		let shallow = true;
		let obj = _object;
		if (!isArray(_object) || !isIntegerKey(String(_key))) do
			shallow = !/* @__PURE__ */ isProxy(obj) || /* @__PURE__ */ isShallow(obj);
		while (shallow && (obj = obj["__v_raw"]));
		this._shallow = shallow;
	}
	get value() {
		let val = this._object[this._key];
		if (this._shallow) val = unref(val);
		return this._value = val === void 0 ? this._defaultValue : val;
	}
	set value(newVal) {
		if (this._shallow && /* @__PURE__ */ isRef(this._raw[this._key])) {
			const nestedRef = this._object[this._key];
			if (/* @__PURE__ */ isRef(nestedRef)) {
				nestedRef.value = newVal;
				return;
			}
		}
		this._object[this._key] = newVal;
	}
	get dep() {
		return getDepFromReactive(this._raw, this._key);
	}
};
var GetterRefImpl = class {
	constructor(_getter) {
		this._getter = _getter;
		this["__v_isRef"] = true;
		this["__v_isReadonly"] = true;
		this._value = void 0;
	}
	get value() {
		return this._value = this._getter();
	}
};
/* @__NO_SIDE_EFFECTS__ */
function toRef(source, key, defaultValue) {
	if (/* @__PURE__ */ isRef(source)) return source;
	else if (isFunction(source)) return new GetterRefImpl(source);
	else if (isObject(source) && arguments.length > 1) return propertyToRef(source, key, defaultValue);
	else return /* @__PURE__ */ ref(source);
}
function propertyToRef(source, key, defaultValue) {
	return new ObjectRefImpl(source, key, defaultValue);
}

//#endregion
//#region packages/reactivity/src/effect.ts
const EffectFlags = {
	"ALLOW_RECURSE": 128,
	"128": "ALLOW_RECURSE",
	"PAUSED": 256,
	"256": "PAUSED",
	"STOP": 1024,
	"1024": "STOP"
};
var ReactiveEffect = class {
	fn() {}
	constructor(fn) {
		this.deps = void 0;
		this.depsTail = void 0;
		this.subs = void 0;
		this.subsTail = void 0;
		this.flags = 18;
		this.cleanups = [];
		this.cleanupsLength = 0;
		if (fn !== void 0) this.fn = fn;
		if (activeEffectScope) link(this, activeEffectScope);
	}
	get active() {
		return !(this.flags & 1024);
	}
	pause() {
		this.flags |= 256;
	}
	resume() {
		if ((this.flags &= -257) & 48) this.notify();
	}
	notify() {
		if (!(this.flags & 256) && this.dirty) this.run();
	}
	run() {
		if (!this.active) return this.fn();
		cleanup(this);
		const prevSub = startTracking(this);
		try {
			return this.fn();
		} finally {
			endTracking(this, prevSub);
			const flags = this.flags;
			if ((flags & 136) === 136) {
				this.flags = flags & -9;
				this.notify();
			}
		}
	}
	stop() {
		if (!this.active) return;
		this.flags = 1024;
		let dep = this.deps;
		while (dep !== void 0) dep = unlink(dep, this);
		const sub = this.subs;
		if (sub !== void 0) unlink(sub);
		cleanup(this);
	}
	get dirty() {
		const flags = this.flags;
		if (flags & 16) return true;
		if (flags & 32) if (checkDirty(this.deps, this)) {
			this.flags = flags | 16;
			return true;
		} else this.flags = flags & -33;
		return false;
	}
};
if (!!(process.env.NODE_ENV !== "production")) setupOnTrigger(ReactiveEffect);
function effect(fn, options) {
	if (fn.effect instanceof ReactiveEffect) fn = fn.effect.fn;
	const e = new ReactiveEffect(fn);
	if (options) {
		const { onStop, scheduler } = options;
		if (onStop) {
			options.onStop = void 0;
			const stop = e.stop.bind(e);
			e.stop = () => {
				stop();
				onStop();
			};
		}
		if (scheduler) {
			options.scheduler = void 0;
			e.notify = () => {
				if (!(e.flags & 256)) scheduler();
			};
		}
		extend(e, options);
	}
	try {
		e.run();
	} catch (err) {
		e.stop();
		throw err;
	}
	const runner = e.run.bind(e);
	runner.effect = e;
	return runner;
}
/**
* Stops the effect associated with the given runner.
*
* @param runner - Association with the effect to stop tracking.
*/
function stop(runner) {
	runner.effect.stop();
}
const resetTrackingStack = [];
/**
* Temporarily pauses tracking.
*/
function pauseTracking() {
	resetTrackingStack.push(activeSub);
	setActiveSub();
}
/**
* Re-enables effect tracking (if it was paused).
*/
function enableTracking() {
	if (!(activeSub === void 0)) resetTrackingStack.push(activeSub);
	else {
		resetTrackingStack.push(void 0);
		for (let i = resetTrackingStack.length - 1; i >= 0; i--) if (resetTrackingStack[i] !== void 0) {
			setActiveSub(resetTrackingStack[i]);
			break;
		}
	}
}
/**
* Resets the previous global effect tracking state.
*/
function resetTracking() {
	if (!!(process.env.NODE_ENV !== "production") && resetTrackingStack.length === 0) warn("resetTracking() was called when there was no active tracking to reset.");
	if (resetTrackingStack.length) setActiveSub(resetTrackingStack.pop());
	else setActiveSub();
}
function cleanup(sub) {
	const l = sub.cleanupsLength;
	if (l) {
		for (let i = 0; i < l; i++) sub.cleanups[i]();
		sub.cleanupsLength = 0;
	}
}
/**
* Registers a cleanup function for the current active effect.
* The cleanup function is called right before the next effect run, or when the
* effect is stopped.
*
* Throws a warning if there is no current active effect. The warning can be
* suppressed by passing `true` to the second argument.
*
* @param fn - the cleanup function to be registered
* @param failSilently - if `true`, will not throw warning when called without
* an active effect.
*/
function onEffectCleanup(fn, failSilently = false) {
	if (activeSub instanceof ReactiveEffect) activeSub.cleanups[activeSub.cleanupsLength++] = () => cleanupEffect(fn);
	else if (!!(process.env.NODE_ENV !== "production") && !failSilently) warn("onEffectCleanup() was called when there was no active effect to associate with.");
}
function cleanupEffect(fn) {
	const prevSub = setActiveSub();
	try {
		fn();
	} finally {
		setActiveSub(prevSub);
	}
}

//#endregion
//#region packages/reactivity/src/effectScope.ts
let activeEffectScope;
var EffectScope = class {
	constructor(detached = false) {
		this.deps = void 0;
		this.depsTail = void 0;
		this.subs = void 0;
		this.subsTail = void 0;
		this.flags = 0;
		this.cleanups = [];
		this.cleanupsLength = 0;
		if (!detached && activeEffectScope) link(this, activeEffectScope);
	}
	get active() {
		return !(this.flags & 1024);
	}
	pause() {
		if (!(this.flags & 256)) {
			this.flags |= 256;
			for (let link = this.deps; link !== void 0; link = link.nextDep) {
				const dep = link.dep;
				if ("pause" in dep) dep.pause();
			}
		}
	}
	/**
	* Resumes the effect scope, including all child scopes and effects.
	*/
	resume() {
		const flags = this.flags;
		if (flags & 256) {
			this.flags = flags & -257;
			for (let link = this.deps; link !== void 0; link = link.nextDep) {
				const dep = link.dep;
				if ("resume" in dep) dep.resume();
			}
		}
	}
	run(fn) {
		const prevScope = activeEffectScope;
		try {
			activeEffectScope = this;
			return fn();
		} finally {
			activeEffectScope = prevScope;
		}
	}
	stop() {
		if (!this.active) return;
		this.flags = 1024;
		this.reset();
		const sub = this.subs;
		if (sub !== void 0) unlink(sub);
	}
	/**
	* @internal
	*/
	reset() {
		let dep = this.deps;
		while (dep !== void 0) {
			const node = dep.dep;
			if ("stop" in node) {
				dep = dep.nextDep;
				node.stop();
			} else dep = unlink(dep, this);
		}
		cleanup(this);
	}
};
/**
* Creates an effect scope object which can capture the reactive effects (i.e.
* computed and watchers) created within it so that these effects can be
* disposed together. For detailed use cases of this API, please consult its
* corresponding {@link https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md | RFC}.
*
* @param detached - Can be used to create a "detached" effect scope.
* @see {@link https://vuejs.org/api/reactivity-advanced.html#effectscope}
*/
function effectScope(detached) {
	return new EffectScope(detached);
}
/**
* Returns the current active effect scope if there is one.
*
* @see {@link https://vuejs.org/api/reactivity-advanced.html#getcurrentscope}
*/
function getCurrentScope() {
	return activeEffectScope;
}
function setCurrentScope(scope) {
	try {
		return activeEffectScope;
	} finally {
		activeEffectScope = scope;
	}
}
/**
* Registers a dispose callback on the current active effect scope. The
* callback will be invoked when the associated effect scope is stopped.
*
* @param fn - The callback function to attach to the scope's cleanup.
* @see {@link https://vuejs.org/api/reactivity-advanced.html#onscopedispose}
*/
function onScopeDispose(fn, failSilently = false) {
	if (activeEffectScope !== void 0) activeEffectScope.cleanups[activeEffectScope.cleanupsLength++] = fn;
	else if (!!(process.env.NODE_ENV !== "production") && !failSilently) warn("onScopeDispose() is called when there is no active effect scope to be associated with.");
}

//#endregion
//#region packages/reactivity/src/computed.ts
/**
* @private exported by @vue/reactivity for Vue core use, but not exported from
* the main vue package
*/
var ComputedRefImpl = class {
	get effect() {
		return this;
	}
	get dep() {
		return this;
	}
	/**
	* @internal
	* for backwards compat
	*/
	get _dirty() {
		const flags = this.flags;
		if (flags & ReactiveFlags$1.Dirty) return true;
		if (flags & ReactiveFlags$1.Pending) if (checkDirty(this.deps, this)) {
			this.flags = flags | ReactiveFlags$1.Dirty;
			return true;
		} else this.flags = flags & ~ReactiveFlags$1.Pending;
		return false;
	}
	/**
	* @internal
	* for backwards compat
	*/
	set _dirty(v) {
		if (v) this.flags |= ReactiveFlags$1.Dirty;
		else this.flags &= ~(ReactiveFlags$1.Dirty | ReactiveFlags$1.Pending);
	}
	constructor(fn, setter) {
		this.fn = fn;
		this.setter = setter;
		this._value = void 0;
		this.subs = void 0;
		this.subsTail = void 0;
		this.deps = void 0;
		this.depsTail = void 0;
		this.flags = ReactiveFlags$1.Mutable | ReactiveFlags$1.Dirty;
		this.__v_isRef = true;
		this["__v_isReadonly"] = !setter;
	}
	get value() {
		const flags = this.flags;
		if (flags & ReactiveFlags$1.Dirty || flags & ReactiveFlags$1.Pending && checkDirty(this.deps, this)) {
			if (this.update()) {
				const subs = this.subs;
				if (subs !== void 0) shallowPropagate(subs);
			}
		} else if (flags & ReactiveFlags$1.Pending) this.flags = flags & ~ReactiveFlags$1.Pending;
		if (activeSub !== void 0) {
			if (!!(process.env.NODE_ENV !== "production")) onTrack(activeSub, {
				target: this,
				type: "get",
				key: "value"
			});
			link(this, activeSub);
		} else if (activeEffectScope !== void 0) link(this, activeEffectScope);
		return this._value;
	}
	set value(newValue) {
		if (this.setter) this.setter(newValue);
		else if (!!(process.env.NODE_ENV !== "production")) warn("Write operation failed: computed value is readonly");
	}
	update() {
		const prevSub = startTracking(this);
		try {
			const oldValue = this._value;
			const newValue = this.fn(oldValue);
			if (hasChanged(oldValue, newValue)) {
				this._value = newValue;
				return true;
			}
			return false;
		} finally {
			endTracking(this, prevSub);
		}
	}
};
if (!!(process.env.NODE_ENV !== "production")) setupOnTrigger(ComputedRefImpl);
/* @__NO_SIDE_EFFECTS__ */
function computed(getterOrOptions, debugOptions, isSSR = false) {
	let getter;
	let setter;
	if (isFunction(getterOrOptions)) getter = getterOrOptions;
	else {
		getter = getterOrOptions.get;
		setter = getterOrOptions.set;
	}
	const cRef = new ComputedRefImpl(getter, setter);
	if (!!(process.env.NODE_ENV !== "production") && debugOptions && !isSSR) {
		cRef.onTrack = debugOptions.onTrack;
		cRef.onTrigger = debugOptions.onTrigger;
	}
	return cRef;
}

//#endregion
//#region packages/reactivity/src/constants.ts
const TrackOpTypes = {
	"GET": "get",
	"HAS": "has",
	"ITERATE": "iterate"
};
const TriggerOpTypes = {
	"SET": "set",
	"ADD": "add",
	"DELETE": "delete",
	"CLEAR": "clear"
};
const ReactiveFlags = {
	"SKIP": "__v_skip",
	"IS_REACTIVE": "__v_isReactive",
	"IS_READONLY": "__v_isReadonly",
	"IS_SHALLOW": "__v_isShallow",
	"RAW": "__v_raw",
	"IS_REF": "__v_isRef"
};

//#endregion
//#region packages/reactivity/src/watch.ts
const WatchErrorCodes = {
	"WATCH_GETTER": 2,
	"2": "WATCH_GETTER",
	"WATCH_CALLBACK": 3,
	"3": "WATCH_CALLBACK",
	"WATCH_CLEANUP": 4,
	"4": "WATCH_CLEANUP"
};
const INITIAL_WATCHER_VALUE = {};
let activeWatcher = void 0;
/**
* Returns the current active effect if there is one.
*/
function getCurrentWatcher() {
	return activeWatcher;
}
/**
* Registers a cleanup callback on the current active effect. This
* registered cleanup callback will be invoked right before the
* associated effect re-runs.
*
* @param cleanupFn - The callback function to attach to the effect's cleanup.
* @param failSilently - if `true`, will not throw warning when called without
* an active effect.
* @param owner - The effect that this cleanup function should be attached to.
* By default, the current active effect.
*/
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
	if (owner) {
		const { call } = owner.options;
		if (call) owner.cleanups[owner.cleanupsLength++] = () => call(cleanupFn, 4);
		else owner.cleanups[owner.cleanupsLength++] = cleanupFn;
	} else if (!!(process.env.NODE_ENV !== "production") && !failSilently) warn("onWatcherCleanup() was called when there was no active watcher to associate with.");
}
var WatcherEffect = class extends ReactiveEffect {
	constructor(source, cb, options = EMPTY_OBJ) {
		const { deep, once, call, onWarn } = options;
		let getter;
		let forceTrigger = false;
		let isMultiSource = false;
		if (/* @__PURE__ */ isRef(source)) {
			getter = () => source.value;
			forceTrigger = /* @__PURE__ */ isShallow(source);
		} else if (/* @__PURE__ */ isReactive(source)) {
			getter = () => reactiveGetter(source, deep);
			forceTrigger = true;
		} else if (isArray(source)) {
			isMultiSource = true;
			forceTrigger = source.some((s) => /* @__PURE__ */ isReactive(s) || /* @__PURE__ */ isShallow(s));
			getter = () => source.map((s) => {
				if (/* @__PURE__ */ isRef(s)) return s.value;
				else if (/* @__PURE__ */ isReactive(s)) return reactiveGetter(s, deep);
				else if (isFunction(s)) return call ? call(s, 2) : s();
				else process.env.NODE_ENV !== "production" && warnInvalidSource(s, onWarn);
			});
		} else if (isFunction(source)) if (cb) getter = call ? () => call(source, 2) : source;
		else getter = () => {
			if (this.cleanupsLength) {
				const prevSub = setActiveSub();
				try {
					cleanup(this);
				} finally {
					setActiveSub(prevSub);
				}
			}
			const currentEffect = activeWatcher;
			activeWatcher = this;
			try {
				return call ? call(source, 3, [this.boundCleanup]) : source(this.boundCleanup);
			} finally {
				activeWatcher = currentEffect;
			}
		};
		else {
			getter = NOOP;
			process.env.NODE_ENV !== "production" && warnInvalidSource(source, onWarn);
		}
		if (cb && deep) {
			const baseGetter = getter;
			const depth = deep === true ? Infinity : deep;
			getter = () => traverse(baseGetter(), depth);
		}
		super(getter);
		this.cb = cb;
		this.options = options;
		this.boundCleanup = (fn) => onWatcherCleanup(fn, false, this);
		this.forceTrigger = forceTrigger;
		this.isMultiSource = isMultiSource;
		if (once && cb) {
			const _cb = cb;
			cb = (...args) => {
				_cb(...args);
				this.stop();
			};
		}
		this.cb = cb;
		this.oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
		if (!!(process.env.NODE_ENV !== "production")) {
			this.onTrack = options.onTrack;
			this.onTrigger = options.onTrigger;
		}
	}
	run(initialRun = false) {
		const oldValue = this.oldValue;
		const newValue = this.oldValue = super.run();
		if (!this.cb) return;
		const { immediate, deep, call } = this.options;
		if (initialRun && !immediate) return;
		if (deep || this.forceTrigger || (this.isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
			cleanup(this);
			const currentWatcher = activeWatcher;
			activeWatcher = this;
			try {
				const args = [
					newValue,
					oldValue === INITIAL_WATCHER_VALUE ? void 0 : this.isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
					this.boundCleanup
				];
				call ? call(this.cb, 3, args) : this.cb(...args);
			} finally {
				activeWatcher = currentWatcher;
			}
		}
	}
};
function reactiveGetter(source, deep) {
	if (deep) return source;
	if (/* @__PURE__ */ isShallow(source) || deep === false || deep === 0) return traverse(source, 1);
	return traverse(source);
}
function warnInvalidSource(s, onWarn) {
	(onWarn || warn)(`Invalid watch source: `, s, "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.");
}
function watch(source, cb, options = EMPTY_OBJ) {
	const effect = new WatcherEffect(source, cb, options);
	effect.run(true);
	const stop = effect.stop.bind(effect);
	stop.pause = effect.pause.bind(effect);
	stop.resume = effect.resume.bind(effect);
	stop.stop = stop;
	return stop;
}
function traverse(value, depth = Infinity, seen) {
	if (depth <= 0 || !isObject(value) || value["__v_skip"]) return value;
	seen = seen || /* @__PURE__ */ new Map();
	if ((seen.get(value) || 0) >= depth) return value;
	seen.set(value, depth);
	depth--;
	if (/* @__PURE__ */ isRef(value)) traverse(value.value, depth, seen);
	else if (isArray(value)) for (let i = 0; i < value.length; i++) traverse(value[i], depth, seen);
	else if (isSet(value) || isMap(value)) value.forEach((v) => {
		traverse(v, depth, seen);
	});
	else if (isPlainObject(value)) {
		for (const key in value) traverse(value[key], depth, seen);
		for (const key of Object.getOwnPropertySymbols(value)) if (Object.prototype.propertyIsEnumerable.call(value, key)) traverse(value[key], depth, seen);
	}
	return value;
}

//#endregion
export { ARRAY_ITERATE_KEY, EffectFlags, EffectScope, ITERATE_KEY, MAP_KEY_ITERATE_KEY, ReactiveEffect, ReactiveFlags, TrackOpTypes, TriggerOpTypes, WatchErrorCodes, WatcherEffect, computed, customRef, effect, effectScope, enableTracking, getCurrentScope, getCurrentWatcher, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onEffectCleanup, onScopeDispose, onWatcherCleanup, pauseTracking, proxyRefs, reactive, reactiveReadArray, readonly, ref, resetTracking, setActiveSub, setCurrentScope, shallowReactive, shallowReadArray, shallowReadonly, shallowRef, stop, toRaw, toReactive, toReadonly, toRef, toRefs, toValue, track, traverse, trigger, triggerRef, unref, watch };