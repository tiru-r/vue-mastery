/**
  * @vue/compiler-core v3.6.0-beta.5
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: 'Module' } });
let _vue_shared = require("@vue/shared");
let _babel_parser = require("@babel/parser");
let estree_walker = require("estree-walker");
let source_map_js = require("source-map-js");

//#region packages/compiler-core/src/runtimeHelpers.ts
const FRAGMENT = Symbol(``);
const TELEPORT = Symbol(``);
const SUSPENSE = Symbol(``);
const KEEP_ALIVE = Symbol(``);
const BASE_TRANSITION = Symbol(``);
const OPEN_BLOCK = Symbol(``);
const CREATE_BLOCK = Symbol(``);
const CREATE_ELEMENT_BLOCK = Symbol(``);
const CREATE_VNODE = Symbol(``);
const CREATE_ELEMENT_VNODE = Symbol(``);
const CREATE_COMMENT = Symbol(``);
const CREATE_TEXT = Symbol(``);
const CREATE_STATIC = Symbol(``);
const RESOLVE_COMPONENT = Symbol(``);
const RESOLVE_DYNAMIC_COMPONENT = Symbol(``);
const RESOLVE_DIRECTIVE = Symbol(``);
const RESOLVE_FILTER = Symbol(``);
const WITH_DIRECTIVES = Symbol(``);
const RENDER_LIST = Symbol(``);
const RENDER_SLOT = Symbol(``);
const CREATE_SLOTS = Symbol(``);
const TO_DISPLAY_STRING = Symbol(``);
const MERGE_PROPS = Symbol(``);
const NORMALIZE_CLASS = Symbol(``);
const NORMALIZE_STYLE = Symbol(``);
const NORMALIZE_PROPS = Symbol(``);
const GUARD_REACTIVE_PROPS = Symbol(``);
const TO_HANDLERS = Symbol(``);
const CAMELIZE = Symbol(``);
const CAPITALIZE = Symbol(``);
const TO_HANDLER_KEY = Symbol(``);
const SET_BLOCK_TRACKING = Symbol(``);
/**
* @deprecated no longer needed in 3.5+ because we no longer hoist element nodes
* but kept for backwards compat
*/
const PUSH_SCOPE_ID = Symbol(``);
/**
* @deprecated kept for backwards compat
*/
const POP_SCOPE_ID = Symbol(``);
const WITH_CTX = Symbol(``);
const UNREF = Symbol(``);
const IS_REF = Symbol(``);
const WITH_MEMO = Symbol(``);
const IS_MEMO_SAME = Symbol(``);
const helperNameMap = {
	[FRAGMENT]: `Fragment`,
	[TELEPORT]: `Teleport`,
	[SUSPENSE]: `Suspense`,
	[KEEP_ALIVE]: `KeepAlive`,
	[BASE_TRANSITION]: `BaseTransition`,
	[OPEN_BLOCK]: `openBlock`,
	[CREATE_BLOCK]: `createBlock`,
	[CREATE_ELEMENT_BLOCK]: `createElementBlock`,
	[CREATE_VNODE]: `createVNode`,
	[CREATE_ELEMENT_VNODE]: `createElementVNode`,
	[CREATE_COMMENT]: `createCommentVNode`,
	[CREATE_TEXT]: `createTextVNode`,
	[CREATE_STATIC]: `createStaticVNode`,
	[RESOLVE_COMPONENT]: `resolveComponent`,
	[RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
	[RESOLVE_DIRECTIVE]: `resolveDirective`,
	[RESOLVE_FILTER]: `resolveFilter`,
	[WITH_DIRECTIVES]: `withDirectives`,
	[RENDER_LIST]: `renderList`,
	[RENDER_SLOT]: `renderSlot`,
	[CREATE_SLOTS]: `createSlots`,
	[TO_DISPLAY_STRING]: `toDisplayString`,
	[MERGE_PROPS]: `mergeProps`,
	[NORMALIZE_CLASS]: `normalizeClass`,
	[NORMALIZE_STYLE]: `normalizeStyle`,
	[NORMALIZE_PROPS]: `normalizeProps`,
	[GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
	[TO_HANDLERS]: `toHandlers`,
	[CAMELIZE]: `camelize`,
	[CAPITALIZE]: `capitalize`,
	[TO_HANDLER_KEY]: `toHandlerKey`,
	[SET_BLOCK_TRACKING]: `setBlockTracking`,
	[PUSH_SCOPE_ID]: `pushScopeId`,
	[POP_SCOPE_ID]: `popScopeId`,
	[WITH_CTX]: `withCtx`,
	[UNREF]: `unref`,
	[IS_REF]: `isRef`,
	[WITH_MEMO]: `withMemo`,
	[IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers) {
	Object.getOwnPropertySymbols(helpers).forEach((s) => {
		helperNameMap[s] = helpers[s];
	});
}

//#endregion
//#region packages/compiler-core/src/ast.ts
const NodeTypes = {
	"ROOT": 0,
	"0": "ROOT",
	"ELEMENT": 1,
	"1": "ELEMENT",
	"TEXT": 2,
	"2": "TEXT",
	"COMMENT": 3,
	"3": "COMMENT",
	"SIMPLE_EXPRESSION": 4,
	"4": "SIMPLE_EXPRESSION",
	"INTERPOLATION": 5,
	"5": "INTERPOLATION",
	"ATTRIBUTE": 6,
	"6": "ATTRIBUTE",
	"DIRECTIVE": 7,
	"7": "DIRECTIVE",
	"COMPOUND_EXPRESSION": 8,
	"8": "COMPOUND_EXPRESSION",
	"IF": 9,
	"9": "IF",
	"IF_BRANCH": 10,
	"10": "IF_BRANCH",
	"FOR": 11,
	"11": "FOR",
	"TEXT_CALL": 12,
	"12": "TEXT_CALL",
	"VNODE_CALL": 13,
	"13": "VNODE_CALL",
	"JS_CALL_EXPRESSION": 14,
	"14": "JS_CALL_EXPRESSION",
	"JS_OBJECT_EXPRESSION": 15,
	"15": "JS_OBJECT_EXPRESSION",
	"JS_PROPERTY": 16,
	"16": "JS_PROPERTY",
	"JS_ARRAY_EXPRESSION": 17,
	"17": "JS_ARRAY_EXPRESSION",
	"JS_FUNCTION_EXPRESSION": 18,
	"18": "JS_FUNCTION_EXPRESSION",
	"JS_CONDITIONAL_EXPRESSION": 19,
	"19": "JS_CONDITIONAL_EXPRESSION",
	"JS_CACHE_EXPRESSION": 20,
	"20": "JS_CACHE_EXPRESSION",
	"JS_BLOCK_STATEMENT": 21,
	"21": "JS_BLOCK_STATEMENT",
	"JS_TEMPLATE_LITERAL": 22,
	"22": "JS_TEMPLATE_LITERAL",
	"JS_IF_STATEMENT": 23,
	"23": "JS_IF_STATEMENT",
	"JS_ASSIGNMENT_EXPRESSION": 24,
	"24": "JS_ASSIGNMENT_EXPRESSION",
	"JS_SEQUENCE_EXPRESSION": 25,
	"25": "JS_SEQUENCE_EXPRESSION",
	"JS_RETURN_STATEMENT": 26,
	"26": "JS_RETURN_STATEMENT"
};
const ElementTypes = {
	"ELEMENT": 0,
	"0": "ELEMENT",
	"COMPONENT": 1,
	"1": "COMPONENT",
	"SLOT": 2,
	"2": "SLOT",
	"TEMPLATE": 3,
	"3": "TEMPLATE"
};
/**
* Static types have several levels.
* Higher levels implies lower levels. e.g. a node that can be stringified
* can always be hoisted and skipped for patch.
*/
const ConstantTypes = {
	"NOT_CONSTANT": 0,
	"0": "NOT_CONSTANT",
	"CAN_SKIP_PATCH": 1,
	"1": "CAN_SKIP_PATCH",
	"CAN_CACHE": 2,
	"2": "CAN_CACHE",
	"CAN_STRINGIFY": 3,
	"3": "CAN_STRINGIFY"
};
const locStub = {
	start: {
		line: 1,
		column: 1,
		offset: 0
	},
	end: {
		line: 1,
		column: 1,
		offset: 0
	},
	source: ""
};
function createRoot(children, source = "") {
	return {
		type: 0,
		source,
		children,
		helpers: /* @__PURE__ */ new Set(),
		components: [],
		directives: [],
		hoists: [],
		imports: [],
		cached: [],
		temps: 0,
		codegenNode: void 0,
		loc: locStub
	};
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {
	if (context) {
		if (isBlock) {
			context.helper(OPEN_BLOCK);
			context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
		} else context.helper(getVNodeHelper(context.inSSR, isComponent));
		if (directives) context.helper(WITH_DIRECTIVES);
	}
	return {
		type: 13,
		tag,
		props,
		children,
		patchFlag,
		dynamicProps,
		directives,
		isBlock,
		disableTracking,
		isComponent,
		loc
	};
}
function createArrayExpression(elements, loc = locStub) {
	return {
		type: 17,
		loc,
		elements
	};
}
function createObjectExpression(properties, loc = locStub) {
	return {
		type: 15,
		loc,
		properties
	};
}
function createObjectProperty(key, value) {
	return {
		type: 16,
		loc: locStub,
		key: (0, _vue_shared.isString)(key) ? createSimpleExpression(key, true) : key,
		value
	};
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
	return {
		type: 4,
		loc,
		content,
		isStatic,
		constType: isStatic ? 3 : constType
	};
}
function createInterpolation(content, loc) {
	return {
		type: 5,
		loc,
		content: (0, _vue_shared.isString)(content) ? createSimpleExpression(content, false, loc) : content
	};
}
function createCompoundExpression(children, loc = locStub) {
	return {
		type: 8,
		loc,
		children
	};
}
function createCallExpression(callee, args = [], loc = locStub) {
	return {
		type: 14,
		loc,
		callee,
		arguments: args
	};
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
	return {
		type: 18,
		params,
		returns,
		newline,
		isSlot,
		loc
	};
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
	return {
		type: 19,
		test,
		consequent,
		alternate,
		newline,
		loc: locStub
	};
}
function createCacheExpression(index, value, needPauseTracking = false, inVOnce = false) {
	return {
		type: 20,
		index,
		value,
		needPauseTracking,
		inVOnce,
		needArraySpread: false,
		loc: locStub
	};
}
function createBlockStatement(body) {
	return {
		type: 21,
		body,
		loc: locStub
	};
}
function createTemplateLiteral(elements) {
	return {
		type: 22,
		elements,
		loc: locStub
	};
}
function createIfStatement(test, consequent, alternate) {
	return {
		type: 23,
		test,
		consequent,
		alternate,
		loc: locStub
	};
}
function createAssignmentExpression(left, right) {
	return {
		type: 24,
		left,
		right,
		loc: locStub
	};
}
function createSequenceExpression(expressions) {
	return {
		type: 25,
		expressions,
		loc: locStub
	};
}
function createReturnStatement(returns) {
	return {
		type: 26,
		returns,
		loc: locStub
	};
}
function getVNodeHelper(ssr, isComponent) {
	return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent) {
	return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function convertToBlock(node, { helper, removeHelper, inSSR }) {
	if (!node.isBlock) {
		node.isBlock = true;
		removeHelper(getVNodeHelper(inSSR, node.isComponent));
		helper(OPEN_BLOCK);
		helper(getVNodeBlockHelper(inSSR, node.isComponent));
	}
}

//#endregion
//#region node_modules/.pnpm/entities@7.0.1/node_modules/entities/dist/esm/decode-codepoint.js
var _a;
const decodeMap = new Map([
	[0, 65533],
	[128, 8364],
	[130, 8218],
	[131, 402],
	[132, 8222],
	[133, 8230],
	[134, 8224],
	[135, 8225],
	[136, 710],
	[137, 8240],
	[138, 352],
	[139, 8249],
	[140, 338],
	[142, 381],
	[145, 8216],
	[146, 8217],
	[147, 8220],
	[148, 8221],
	[149, 8226],
	[150, 8211],
	[151, 8212],
	[152, 732],
	[153, 8482],
	[154, 353],
	[155, 8250],
	[156, 339],
	[158, 382],
	[159, 376]
]);
/**
* Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
*/
const fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : ((codePoint) => {
	let output = "";
	if (codePoint > 65535) {
		codePoint -= 65536;
		output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
		codePoint = 56320 | codePoint & 1023;
	}
	output += String.fromCharCode(codePoint);
	return output;
});
/**
* Replace the given code point with a replacement character if it is a
* surrogate or is outside the valid range. Otherwise return the code
* point unchanged.
*/
function replaceCodePoint(codePoint) {
	var _a;
	if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) return 65533;
	return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
}

//#endregion
//#region node_modules/.pnpm/entities@7.0.1/node_modules/entities/dist/esm/internal/decode-shared.js
function decodeBase64(input) {
	const binary = typeof atob === "function" ? atob(input) : typeof Buffer.from === "function" ? Buffer.from(input, "base64").toString("binary") : new Buffer(input, "base64").toString("binary");
	const evenLength = binary.length & -2;
	const out = new Uint16Array(evenLength / 2);
	for (let index = 0, outIndex = 0; index < evenLength; index += 2) {
		const lo = binary.charCodeAt(index);
		const hi = binary.charCodeAt(index + 1);
		out[outIndex++] = lo | hi << 8;
	}
	return out;
}

//#endregion
//#region node_modules/.pnpm/entities@7.0.1/node_modules/entities/dist/esm/generated/decode-data-html.js
const htmlDecodeTree = /* @__PURE__ */ decodeBase64("QR08ALkAAgH6AYsDNQR2BO0EPgXZBQEGLAbdBxMISQrvCmQLfQurDKQNLw4fD4YPpA+6D/IPAAAAAAAAAAAAAAAAKhBMEY8TmxUWF2EYLBkxGuAa3RsJHDscWR8YIC8jSCSIJcMl6ie3Ku8rEC0CLjoupS7kLgAIRU1hYmNmZ2xtbm9wcnN0dVQAWgBeAGUAaQBzAHcAfgCBAIQAhwCSAJoAoACsALMAbABpAGcAO4DGAMZAUAA7gCYAJkBjAHUAdABlADuAwQDBQHIiZXZlAAJhAAFpeW0AcgByAGMAO4DCAMJAEGRyAADgNdgE3XIAYQB2AGUAO4DAAMBA8CFoYZFj4SFjcgBhZAAAoFMqAAFncIsAjgBvAG4ABGFmAADgNdg43fAlbHlGdW5jdGlvbgCgYSBpAG4AZwA7gMUAxUAAAWNzpACoAHIAAOA12Jzc6SFnbgCgVCJpAGwAZABlADuAwwDDQG0AbAA7gMQAxEAABGFjZWZvcnN1xQDYANoA7QDxAPYA+QD8AAABY3LJAM8AayNzbGFzaAAAoBYidgHTANUAAKDnKmUAZAAAoAYjeQARZIABY3J0AOAA5QDrAGEidXNlAACgNSLuI291bGxpcwCgLCFhAJJjcgAA4DXYBd1wAGYAAOA12Dnd5SF2ZdhiYwDyAOoAbSJwZXEAAKBOIgAHSE9hY2RlZmhpbG9yc3UXARoBHwE6AVIBVQFiAWQBZgGCAakB6QHtAfIBYwB5ACdkUABZADuAqQCpQIABY3B5ACUBKAE1AfUhdGUGYWmg0iJ0KGFsRGlmZmVyZW50aWFsRAAAoEUhbCJleXMAAKAtIQACYWVpb0EBRAFKAU0B8iFvbgxhZABpAGwAO4DHAMdAcgBjAAhhbiJpbnQAAKAwIm8AdAAKYQABZG5ZAV0BaSJsbGEAuGB0I2VyRG90ALdg8gA5AWkAp2NyImNsZQAAAkRNUFRwAXQBeQF9AW8AdAAAoJkiaSJudXMAAKCWIuwhdXMAoJUiaSJtZXMAAKCXIm8AAAFjc4cBlAFrKndpc2VDb250b3VySW50ZWdyYWwAAKAyImUjQ3VybHkAAAFEUZwBpAFvJXVibGVRdW90ZQAAoB0gdSJvdGUAAKAZIAACbG5wdbABtgHNAdgBbwBuAGWgNyIAoHQqgAFnaXQAvAHBAcUB8iJ1ZW50AKBhIm4AdAAAoC8i7yV1ckludGVncmFsAKAuIgABZnLRAdMBAKACIe8iZHVjdACgECJuLnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbAAAoDMi7yFzcwCgLypjAHIAAOA12J7ccABDoNMiYQBwAACgTSKABURKU1phY2VmaW9zAAsCEgIVAhgCGwIsAjQCOQI9AnMCfwNvoEUh9CJyYWhkAKARKWMAeQACZGMAeQAFZGMAeQAPZIABZ3JzACECJQIoAuchZXIAoCEgcgAAoKEhaAB2AACg5CoAAWF5MAIzAvIhb24OYRRkbAB0oAciYQCUY3IAAOA12AfdAAFhZkECawIAAWNtRQJnAvIjaXRpY2FsAAJBREdUUAJUAl8CYwJjInV0ZQC0YG8AdAFZAloC2WJiJGxlQWN1dGUA3WJyImF2ZQBgYGkibGRlANxi7yFuZACgxCJmJWVyZW50aWFsRAAAoEYhcAR9AgAAAAAAAIECjgIAABoDZgAA4DXYO91EoagAhQKJAm8AdAAAoNwgcSJ1YWwAAKBQIuIhbGUAA0NETFJVVpkCqAK1Au8C/wIRA28AbgB0AG8AdQByAEkAbgB0AGUAZwByAGEA7ADEAW8AdAKvAgAAAACwAqhgbiNBcnJvdwAAoNMhAAFlb7kC0AJmAHQAgAFBUlQAwQLGAs0CciJyb3cAAKDQIekkZ2h0QXJyb3cAoNQhZQDlACsCbgBnAAABTFLWAugC5SFmdAABQVLcAuECciJyb3cAAKD4J+kkZ2h0QXJyb3cAoPon6SRnaHRBcnJvdwCg+SdpImdodAAAAUFU9gL7AnIicm93AACg0iFlAGUAAKCoInAAQQIGAwAAAAALA3Iicm93AACg0SFvJHduQXJyb3cAAKDVIWUlcnRpY2FsQmFyAACgJSJuAAADQUJMUlRhJAM2AzoDWgNxA3oDciJyb3cAAKGTIUJVLAMwA2EAcgAAoBMpcCNBcnJvdwAAoPUhciJldmUAEWPlIWZ00gJDAwAASwMAAFIDaSVnaHRWZWN0b3IAAKBQKWUkZVZlY3RvcgAAoF4p5SJjdG9yQqC9IWEAcgAAoFYpaSJnaHQA1AFiAwAAaQNlJGVWZWN0b3IAAKBfKeUiY3RvckKgwSFhAHIAAKBXKWUAZQBBoKQiciJyb3cAAKCnIXIAcgBvAPcAtAIAAWN0gwOHA3IA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YwAAoN8i4SFycnCgtiEAoD0pgKIqImJjZG9zACsVMBU6FT4VQRVyImNhcAAAoEgqAAFhdTQVNxVwAACgRipwAACgSipvAHQAAKCNInIAAKBFKgDgKiIA/gACYWxydksVURVuFXMVcgByAG2gtyEAoDwpeQCAAWV2dwBYFWUVaRVxAHACXxUAAAAAYxVyAGUA4wAXFXUA4wAZFWUAZQAAoM4iZSJkZ2UAAKDPImUAbgA7gKQApEBlI2Fycm93AAABbHJ7FX8V5SFmdACgtiFpImdodAAAoLchZQDkAG0VAAFjaYsVkRVvAG4AaQBuAPQAkwFuAHQAAKAxImwiY3R5AACgLSOACUFIYWJjZGVmaGlqbG9yc3R1d3oAuBW7Fb8V1RXgFegV+RUKFhUWHxZUFlcWZRbFFtsW7xb7FgUXChdyAPIAtAJhAHIAAKBlKQACZ2xyc8YVyhXOFdAV5yFlcgCgICDlIXRoAKA4IfIA9QxoAHagECAAoKMiawHZFd4VYSJyb3cAAKAPKWEA4wBfAgABYXnkFecV8iFvbg9hNGQAoUYhYW/tFfQVAAFnciEC8RVyAACgyiF0InNlcQAAoHcqgAFnbG0A/xUCFgUWO4CwALBAdABhALRjcCJ0eXYAAKCxKQABaXIOFhIW8yFodACgfykA4DXYId1hAHIAAAFschsWHRYAoMMhAKDCIYACYWVnc3YAKBauAjYWOhY+Fm0AAKHEIm9zLhY0Fm4AZABzoMQi9SFpdACgZiZhIm1tYQDdY2kAbgAAoPIiAKH3AGlvQxZRFmQAZQAAgfcAO29KFksW90BuI3RpbWVzAACgxyJuAPgAUBZjAHkAUmRjAG8CXhYAAAAAYhZyAG4AAKAeI28AcAAAoA0jgAJscHR1dwBuFnEWdRaSFp4W7CFhciRgZgAA4DXYVd0AotkCZW1wc30WhBaJFo0WcQBkoFAibwB0AACgUSJpIm51cwAAoDgi7CF1cwCgFCLxInVhcmUAoKEiYgBsAGUAYgBhAHIAdwBlAGQAZwDlANcAbgCAAWFkaAClFqoWtBZyAHIAbwD3APUMbwB3AG4AYQByAHIAbwB3APMA8xVhI3Jwb29uAAABbHK8FsAWZQBmAPQAHBZpAGcAaAD0AB4WYgHJFs8WawBhAHIAbwD3AJILbwLUFgAAAADYFnIAbgAAoB8jbwBwAACgDCOAAWNvdADhFukW7BYAAXJ55RboFgDgNdi53FVkbAAAoPYp8iFvaxFhAAFkcvMW9xZvAHQAAKDxImkA5qC/JVsSAAFhaP8WAhdyAPIANQNhAPIA1wvhIm5nbGUAoKYpAAFjaQ4XEBd5AF9k5yJyYXJyAKD/JwAJRGFjZGVmZ2xtbm9wcXJzdHV4MRc4F0YXWxcyBF4XaRd5F40XrBe0F78X2RcVGCEYLRg1GEAYAAFEbzUXgRZvAPQA+BUAAWNzPBdCF3UAdABlADuA6QDpQPQhZXIAoG4qAAJhaW95TRdQF1YXWhfyIW9uG2FyAGOgViI7gOoA6kDsIW9uAKBVIk1kbwB0ABdhAAFEcmIXZhdvAHQAAKBSIgDgNdgi3XKhmipuF3QXYQB2AGUAO4DoAOhAZKCWKm8AdAAAoJgqgKGZKmlscwCAF4UXhxfuInRlcnMAoOcjAKATIWSglSpvAHQAAKCXKoABYXBzAJMXlheiF2MAcgATYXQAeQBzogUinxcAAAAAoRdlAHQAAKAFInAAMaADIDMBqRerFwCgBCAAoAUgAAFnc7AXsRdLYXAAAKACIAABZ3C4F7sXbwBuABlhZgAA4DXYVt2AAWFscwDFF8sXzxdyAHOg1SJsAACg4yl1AHMAAKBxKmkAAKG1A2x21RfYF28AbgC1Y/VjAAJjc3V24BfoF/0XEBgAAWlv5BdWF3IAYwAAoFYiaQLuFwAAAADwF+0ADQThIW50AAFnbPUX+Rd0AHIAAKCWKuUhc3MAoJUqgAFhZWkAAxgGGAoYbABzAD1gcwB0AACgXyJ2AESgYSJEAACgeCrwImFyc2wAoOUpAAFEYRkYHRhvAHQAAKBTInIAcgAAoHEpgAFjZGkAJxgqGO0XcgAAoC8hbwD0AIwCAAFhaDEYMhi3YzuA8ADwQAABbXI5GD0YbAA7gOsA60BvAACgrCCAAWNpcABGGEgYSxhsACFgcwD0ACwEAAFlb08YVxhjAHQAYQB0AGkAbwDuABoEbgBlAG4AdABpAGEAbADlADME4Ql1GAAAgRgAAIMYiBgAAAAAoRilGAAAqhgAALsYvhjRGAAA1xgnGWwAbABpAG4AZwBkAG8AdABzAGUA8QBlF3kARGRtImFsZQAAoEAmgAFpbHIAjRiRGJ0Y7CFpZwCgA/tpApcYAAAAAJoYZwAAoAD7aQBnAACgBPsA4DXYI93sIWlnAKAB++whaWcA4GYAagCAAWFsdACvGLIYthh0AACgbSZpAGcAAKAC+24AcwAAoLElbwBmAJJh8AHCGAAAxhhmAADgNdhX3QABYWvJGMwYbADsAGsEdqDUIgCg2SphI3J0aW50AACgDSoAAWFv2hgiGQABY3PeGB8ZsQPnGP0YBRkSGRUZAAAdGbID7xjyGPQY9xj5GAAA+xg7gL0AvUAAoFMhO4C8ALxAAKBVIQCgWSEAoFshswEBGQAAAxkAoFQhAKBWIbQCCxkOGQAAAAAQGTuAvgC+QACgVyEAoFwhNQAAoFghtgEZGQAAGxkAoFohAKBdITgAAKBeIWwAAKBEIHcAbgAAoCIjYwByAADgNdi73IAIRWFiY2RlZmdpamxub3JzdHYARhlKGVoZXhlmGWkZkhmWGZkZnRmgGa0ZxhnLGc8Z4BkjGmygZyIAoIwqgAFjbXAAUBlTGVgZ9SF0ZfVhbQBhAOSgswM6FgCghipyImV2ZQAfYQABaXliGWUZcgBjAB1hM2RvAHQAIWGAoWUibHFzAMYEcBl6GfGhZSLOBAAAdhlsAGEAbgD0AN8EgKF+KmNkbACBGYQZjBljAACgqSpvAHQAb6CAKmyggioAoIQqZeDbIgD+cwAAoJQqcgAA4DXYJN3noGsirATtIWVsAKA3IWMAeQBTZIChdyJFYWoApxmpGasZAKCSKgCgpSoAoKQqAAJFYWVztBm2Gb0ZwhkAoGkicABwoIoq8iFveACgiipxoIgq8aCIKrUZaQBtAACg5yJwAGYAAOA12FjdYQB2AOUAYwIAAWNp0xnWGXIAAKAKIW0AAKFzImVs3BneGQCgjioAoJAqAIM+ADtjZGxxco0E6xn0GfgZ/BkBGgABY2nvGfEZAKCnKnIAAKB6Km8AdAAAoNci0CFhcgCglSl1ImVzdAAAoHwqgAJhZGVscwAKGvQZFhrVBCAa8AEPGgAAFBpwAHIAbwD4AFkZcgAAoHgpcQAAAWxxxAQbGmwAZQBzAPMASRlpAO0A5AQAAWVuJxouGnIjdG5lcXEAAOBpIgD+xQAsGgAFQWFiY2Vma29zeUAaQxpmGmoabRqDGocalhrCGtMacgDyAMwCAAJpbG1yShpOGlAaVBpyAHMA8ABxD2YAvWBpAGwA9AASBQABZHJYGlsaYwB5AEpkAKGUIWN3YBpkGmkAcgAAoEgpAKCtIWEAcgAAoA8h6SFyYyVhgAFhbHIAcxp7Gn8a8iF0c3WgZSZpAHQAAKBlJuwhaXAAoCYg4yFvbgCguSJyAADgNdgl3XMAAAFld4wakRphInJvdwAAoCUpYSJyb3cAAKAmKYACYW1vcHIAnxqjGqcauhq+GnIAcgAAoP8h9CFodACgOyJrAAABbHKsGrMaZSRmdGFycm93AACgqSHpJGdodGFycm93AKCqIWYAAOA12Fnd4iFhcgCgFSCAAWNsdADIGswa0BpyAADgNdi93GEAcwDoAGka8iFvaydhAAFicNca2xr1IWxsAKBDIOghZW4AoBAg4Qr2GgAA/RoAAAgbExsaGwAAIRs7GwAAAAA+G2IbmRuVG6sbAACyG80b0htjAHUAdABlADuA7QDtQAChYyBpeQEbBhtyAGMAO4DuAO5AOGQAAWN4CxsNG3kANWRjAGwAO4ChAKFAAAFmcssCFhsA4DXYJt1yAGEAdgBlADuA7ADsQIChSCFpbm8AJxsyGzYbAAFpbisbLxtuAHQAAKAMKnQAAKAtIuYhaW4AoNwpdABhAACgKSHsIWlnM2GAAWFvcABDG1sbXhuAAWNndABJG0sbWRtyACthgAFlbHAAcQVRG1UbaQBuAOUAyAVhAHIA9AByBWgAMWFmAACgtyJlAGQAtWEAoggiY2ZvdGkbbRt1G3kb4SFyZQCgBSFpAG4AdKAeImkAZQAAoN0pZABvAPQAWxsAoisiY2VscIEbhRuPG5QbYQBsAACguiIAAWdyiRuNG2UAcgDzACMQ4wCCG2EicmhrAACgFyryIW9kAKA8KgACY2dwdJ8boRukG6gbeQBRZG8AbgAvYWYAAOA12FrdYQC5Y3UAZQBzAHQAO4C/AL9AAAFjabUbuRtyAADgNdi+3G4AAKIIIkVkc3bCG8QbyBvQAwCg+SJvAHQAAKD1Inag9CIAoPMiaaBiIOwhZGUpYesB1hsAANkbYwB5AFZkbAA7gO8A70AAA2NmbW9zdeYb7hvyG/Ub+hsFHAABaXnqG+0bcgBjADVhOWRyAADgNdgn3eEhdGg3YnAAZgAA4DXYW93jAf8bAAADHHIAAOA12L/c8iFjeVhk6yFjeVRkAARhY2ZnaGpvcxUcGhwiHCYcKhwtHDAcNRzwIXBhdqC6A/BjAAFleR4cIRzkIWls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ZmdobG1vcHJzdHV3CiwNLBEsHSwnLDEsQCxLLFIsYix6LIQsjyzLLOgs7Sz/LAotcgDyAAkDYQByAACgYykAAWNyFSwbLHUAdABlADuA+gD6QPIACQ1yAOMBIywAACUseQBeZHYAZQBtYQABaXkrLDAscgBjADuA+wD7QENkgAFhYmgANyw6LD0scgDyANEO7CFhY3FhYQDyAOAOAAFpckQsSCzzIWh0AKB+KQDgNdgy3XIAYQB2AGUAO4D5APlAYQFWLF8scgAAAWxyWixcLACgvyEAoL4hbABrAACggCUAAWN0Zix2LG8CbCwAAAAAcyxyAG4AZaAcI3IAAKAcI28AcAAAoA8jcgBpAACg+CUAAWFsfiyBLGMAcgBrYTuAqACoQAABZ3CILIssbwBuAHNhZgAA4DXYZt0AA2FkaGxzdZksniynLLgsuyzFLHIAcgBvAPcACQ1vAHcAbgBhAHIAcgBvAPcA2A5hI3Jwb29uAAABbHKvLLMsZQBmAPQAWyxpAGcAaAD0AF0sdQDzAKYOaQAAocUDaGzBLMIs0mNvAG4AxWPwI2Fycm93cwCgyCGAAWNpdADRLOEs5CxvAtcsAAAAAN4scgBuAGWgHSNyAACgHSNvAHAAAKAOI24AZwBvYXIAaQAAoPklYwByAADgNdjK3IABZGlyAPMs9yz6LG8AdAAAoPAi7CFkZWlhaQBmoLUlAKC0JQABYW0DLQYtcgDyAMosbAA7gPwA/EDhIm5nbGUAoKcpgAdBQkRhY2RlZmxub3Byc3oAJy0qLTAtNC2bLZ0toS2/LcMtxy3TLdgt3C3gLfwtcgDyABADYQByAHag6CoAoOkqYQBzAOgA/gIAAW5yOC08LechcnQAoJwpgANla25wcnN0AJkpSC1NLVQtXi1iLYItYQBwAHAA4QAaHG8AdABoAGkAbgDnAKEXgAFoaXIAoSmzJFotbwBwAPQAdCVooJUh7wD4JgABaXVmLWotZwBtAOEAuygAAWJwbi14LXMjZXRuZXEAceCKIgD+AODLKgD+cyNldG5lcQBx4IsiAP4A4MwqAP4AAWhyhi2KLWUAdADhABIraSNhbmdsZQAAAWxyki2WLeUhZnQAoLIiaSJnaHQAAKCzInkAMmThIXNoAKCiIoABZWxyAKcttC24LWKiKCKuLQAAAACyLWEAcgAAoLsicQAAoFoi7CFpcACg7iIAAWJ0vC1eD2EA8gBfD3IAAOA12DPddAByAOkAlS1zAHUAAAFicM0t0C0A4IIi0iAA4IMi0iBwAGYAAOA12GfdcgBvAPAAWQt0AHIA6QCaLQABY3XkLegtcgAA4DXYy9wAAWJw7C30LW4AAAFFZXUt8S0A4IoiAP5uAAABRWV/LfktAOCLIgD+6SJnemFnAKCaKYADY2Vmb3BycwANLhAuJS4pLiMuLi40LukhcmN1YQABZGkULiEuAAFiZxguHC5hAHIAAKBfKmUAcaAnIgCgWSLlIXJwAKAYIXIAAOA12DTdcABmAADgNdho3WWgQCJhAHQA6ABqD2MAcgAA4DXYzNzjCuQRUC4AAFQuAABYLmIuAAAAAGMubS5wLnQuAAAAAIguki4AAJouJxIqEnQAcgDpAB0ScgAA4DXYNd0AAUFhWy5eLnIA8gDnAnIA8gCTB75jAAFBYWYuaS5yAPIA4AJyAPIAjAdhAPAAeh5pAHMAAKD7IoABZHB0APgReS6DLgABZmx9LoAuAOA12GnddQDzAP8RaQBtAOUABBIAAUFhiy6OLnIA8gDuAnIA8gCaBwABY3GVLgoScgAA4DXYzdwAAXB0nS6hLmwAdQDzACUScgDpACASAARhY2VmaW9zdbEuvC7ELsguzC7PLtQu2S5jAAABdXm2LrsudABlADuA/QD9QE9kAAFpecAuwy5yAGMAd2FLZG4AO4ClAKVAcgAA4DXYNt1jAHkAV2RwAGYAAOA12GrdYwByAADgNdjO3AABY23dLt8ueQBOZGwAO4D/AP9AAAVhY2RlZmhpb3N38y73Lv8uAi8MLxAvEy8YLx0vIi9jInV0ZQB6YQABYXn7Lv4u8iFvbn5hN2RvAHQAfGEAAWV0Bi8KL3QAcgDmAB8QYQC2Y3IAAOA12DfdYwB5ADZk5yJyYXJyAKDdIXAAZgAA4DXYa91jAHIAAOA12M/cAAFqbiYvKC8AoA0gagAAoAwg");

//#endregion
//#region node_modules/.pnpm/entities@7.0.1/node_modules/entities/dist/esm/internal/bin-trie-flags.js
/**
* Bit flags & masks for the binary trie encoding used for entity decoding.
*
* Bit layout (16 bits total):
* 15..14 VALUE_LENGTH   (+1 encoding; 0 => no value)
* 13     FLAG13.        If valueLength>0: semicolon required flag (implicit ';').
*                       If valueLength==0: compact run flag.
* 12..7  BRANCH_LENGTH  Branch length (0 => single branch in 6..0 if jumpOffset==char) OR run length (when compact run)
* 6..0   JUMP_TABLE     Jump offset (jump table) OR single-branch char code OR first run char
*/
var BinTrieFlags;
(function(BinTrieFlags) {
	BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
	BinTrieFlags[BinTrieFlags["FLAG13"] = 8192] = "FLAG13";
	BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 8064] = "BRANCH_LENGTH";
	BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));

//#endregion
//#region node_modules/.pnpm/entities@7.0.1/node_modules/entities/dist/esm/decode.js
var CharCodes;
(function(CharCodes) {
	CharCodes[CharCodes["NUM"] = 35] = "NUM";
	CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
	CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
	CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
	CharCodes[CharCodes["NINE"] = 57] = "NINE";
	CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
	CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
	CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
	CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
	CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
	CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
	CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
/** Bit that needs to be set to convert an upper case ASCII character to lower case */
const TO_LOWER_BIT = 32;
function isNumber(code) {
	return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
	return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
	return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
}
/**
* Checks if the given character is a valid end character for an entity in an attribute.
*
* Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
* See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
*/
function isEntityInAttributeInvalidEnd(code) {
	return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function(EntityDecoderState) {
	EntityDecoderState[EntityDecoderState["EntityStart"] = 0] = "EntityStart";
	EntityDecoderState[EntityDecoderState["NumericStart"] = 1] = "NumericStart";
	EntityDecoderState[EntityDecoderState["NumericDecimal"] = 2] = "NumericDecimal";
	EntityDecoderState[EntityDecoderState["NumericHex"] = 3] = "NumericHex";
	EntityDecoderState[EntityDecoderState["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode) {
	/** Entities in text nodes that can end with any character. */
	DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
	/** Only allow entities terminated with a semicolon. */
	DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
	/** Entities in attributes have limitations on ending characters. */
	DecodingMode[DecodingMode["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
/**
* Token decoder with support of writing partial entities.
*/
var EntityDecoder = class {
	constructor(decodeTree, emitCodePoint, errors) {
		this.decodeTree = decodeTree;
		this.emitCodePoint = emitCodePoint;
		this.errors = errors;
		/** The current state of the decoder. */
		this.state = EntityDecoderState.EntityStart;
		/** Characters that were consumed while parsing an entity. */
		this.consumed = 1;
		/**
		* The result of the entity.
		*
		* Either the result index of a numeric entity, or the codepoint of a
		* numeric entity.
		*/
		this.result = 0;
		/** The current index in the decode tree. */
		this.treeIndex = 0;
		/** The number of characters that were consumed in excess. */
		this.excess = 1;
		/** The mode in which the decoder is operating. */
		this.decodeMode = DecodingMode.Strict;
		/** The number of characters that have been consumed in the current run. */
		this.runConsumed = 0;
	}
	/** Resets the instance to make it reusable. */
	startEntity(decodeMode) {
		this.decodeMode = decodeMode;
		this.state = EntityDecoderState.EntityStart;
		this.result = 0;
		this.treeIndex = 0;
		this.excess = 1;
		this.consumed = 1;
		this.runConsumed = 0;
	}
	/**
	* Write an entity to the decoder. This can be called multiple times with partial entities.
	* If the entity is incomplete, the decoder will return -1.
	*
	* Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
	* entity is incomplete, and resume when the next string is written.
	*
	* @param input The string containing the entity (or a continuation of the entity).
	* @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
	* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	*/
	write(input, offset) {
		switch (this.state) {
			case EntityDecoderState.EntityStart:
				if (input.charCodeAt(offset) === CharCodes.NUM) {
					this.state = EntityDecoderState.NumericStart;
					this.consumed += 1;
					return this.stateNumericStart(input, offset + 1);
				}
				this.state = EntityDecoderState.NamedEntity;
				return this.stateNamedEntity(input, offset);
			case EntityDecoderState.NumericStart: return this.stateNumericStart(input, offset);
			case EntityDecoderState.NumericDecimal: return this.stateNumericDecimal(input, offset);
			case EntityDecoderState.NumericHex: return this.stateNumericHex(input, offset);
			case EntityDecoderState.NamedEntity: return this.stateNamedEntity(input, offset);
		}
	}
	/**
	* Switches between the numeric decimal and hexadecimal states.
	*
	* Equivalent to the `Numeric character reference state` in the HTML spec.
	*
	* @param input The string containing the entity (or a continuation of the entity).
	* @param offset The current offset.
	* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	*/
	stateNumericStart(input, offset) {
		if (offset >= input.length) return -1;
		if ((input.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
			this.state = EntityDecoderState.NumericHex;
			this.consumed += 1;
			return this.stateNumericHex(input, offset + 1);
		}
		this.state = EntityDecoderState.NumericDecimal;
		return this.stateNumericDecimal(input, offset);
	}
	/**
	* Parses a hexadecimal numeric entity.
	*
	* Equivalent to the `Hexademical character reference state` in the HTML spec.
	*
	* @param input The string containing the entity (or a continuation of the entity).
	* @param offset The current offset.
	* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	*/
	stateNumericHex(input, offset) {
		while (offset < input.length) {
			const char = input.charCodeAt(offset);
			if (isNumber(char) || isHexadecimalCharacter(char)) {
				const digit = char <= CharCodes.NINE ? char - CharCodes.ZERO : (char | TO_LOWER_BIT) - CharCodes.LOWER_A + 10;
				this.result = this.result * 16 + digit;
				this.consumed++;
				offset++;
			} else return this.emitNumericEntity(char, 3);
		}
		return -1;
	}
	/**
	* Parses a decimal numeric entity.
	*
	* Equivalent to the `Decimal character reference state` in the HTML spec.
	*
	* @param input The string containing the entity (or a continuation of the entity).
	* @param offset The current offset.
	* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	*/
	stateNumericDecimal(input, offset) {
		while (offset < input.length) {
			const char = input.charCodeAt(offset);
			if (isNumber(char)) {
				this.result = this.result * 10 + (char - CharCodes.ZERO);
				this.consumed++;
				offset++;
			} else return this.emitNumericEntity(char, 2);
		}
		return -1;
	}
	/**
	* Validate and emit a numeric entity.
	*
	* Implements the logic from the `Hexademical character reference start
	* state` and `Numeric character reference end state` in the HTML spec.
	*
	* @param lastCp The last code point of the entity. Used to see if the
	*               entity was terminated with a semicolon.
	* @param expectedLength The minimum number of characters that should be
	*                       consumed. Used to validate that at least one digit
	*                       was consumed.
	* @returns The number of characters that were consumed.
	*/
	emitNumericEntity(lastCp, expectedLength) {
		var _a;
		if (this.consumed <= expectedLength) {
			(_a = this.errors) === null || _a === void 0 || _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
			return 0;
		}
		if (lastCp === CharCodes.SEMI) this.consumed += 1;
		else if (this.decodeMode === DecodingMode.Strict) return 0;
		this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
		if (this.errors) {
			if (lastCp !== CharCodes.SEMI) this.errors.missingSemicolonAfterCharacterReference();
			this.errors.validateNumericCharacterReference(this.result);
		}
		return this.consumed;
	}
	/**
	* Parses a named entity.
	*
	* Equivalent to the `Named character reference state` in the HTML spec.
	*
	* @param input The string containing the entity (or a continuation of the entity).
	* @param offset The current offset.
	* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	*/
	stateNamedEntity(input, offset) {
		const { decodeTree } = this;
		let current = decodeTree[this.treeIndex];
		let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
		while (offset < input.length) {
			if (valueLength === 0 && (current & BinTrieFlags.FLAG13) !== 0) {
				const runLength = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
				if (this.runConsumed === 0) {
					const firstChar = current & BinTrieFlags.JUMP_TABLE;
					if (input.charCodeAt(offset) !== firstChar) return this.result === 0 ? 0 : this.emitNotTerminatedNamedEntity();
					offset++;
					this.excess++;
					this.runConsumed++;
				}
				while (this.runConsumed < runLength) {
					if (offset >= input.length) return -1;
					const charIndexInPacked = this.runConsumed - 1;
					const packedWord = decodeTree[this.treeIndex + 1 + (charIndexInPacked >> 1)];
					const expectedChar = charIndexInPacked % 2 === 0 ? packedWord & 255 : packedWord >> 8 & 255;
					if (input.charCodeAt(offset) !== expectedChar) {
						this.runConsumed = 0;
						return this.result === 0 ? 0 : this.emitNotTerminatedNamedEntity();
					}
					offset++;
					this.excess++;
					this.runConsumed++;
				}
				this.runConsumed = 0;
				this.treeIndex += 1 + (runLength >> 1);
				current = decodeTree[this.treeIndex];
				valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
			}
			if (offset >= input.length) break;
			const char = input.charCodeAt(offset);
			if (char === CharCodes.SEMI && valueLength !== 0 && (current & BinTrieFlags.FLAG13) !== 0) return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
			this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
			if (this.treeIndex < 0) return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
			current = decodeTree[this.treeIndex];
			valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
			if (valueLength !== 0) {
				if (char === CharCodes.SEMI) return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
				if (this.decodeMode !== DecodingMode.Strict && (current & BinTrieFlags.FLAG13) === 0) {
					this.result = this.treeIndex;
					this.consumed += this.excess;
					this.excess = 0;
				}
			}
			offset++;
			this.excess++;
		}
		return -1;
	}
	/**
	* Emit a named entity that was not terminated with a semicolon.
	*
	* @returns The number of characters consumed.
	*/
	emitNotTerminatedNamedEntity() {
		var _a;
		const { result, decodeTree } = this;
		const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
		this.emitNamedEntityData(result, valueLength, this.consumed);
		(_a = this.errors) === null || _a === void 0 || _a.missingSemicolonAfterCharacterReference();
		return this.consumed;
	}
	/**
	* Emit a named entity.
	*
	* @param result The index of the entity in the decode tree.
	* @param valueLength The number of bytes in the entity.
	* @param consumed The number of characters consumed.
	*
	* @returns The number of characters consumed.
	*/
	emitNamedEntityData(result, valueLength, consumed) {
		const { decodeTree } = this;
		this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~(BinTrieFlags.VALUE_LENGTH | BinTrieFlags.FLAG13) : decodeTree[result + 1], consumed);
		if (valueLength === 3) this.emitCodePoint(decodeTree[result + 2], consumed);
		return consumed;
	}
	/**
	* Signal to the parser that the end of the input was reached.
	*
	* Remaining data will be emitted and relevant errors will be produced.
	*
	* @returns The number of characters consumed.
	*/
	end() {
		var _a;
		switch (this.state) {
			case EntityDecoderState.NamedEntity: return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
			case EntityDecoderState.NumericDecimal: return this.emitNumericEntity(0, 2);
			case EntityDecoderState.NumericHex: return this.emitNumericEntity(0, 3);
			case EntityDecoderState.NumericStart:
				(_a = this.errors) === null || _a === void 0 || _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
				return 0;
			case EntityDecoderState.EntityStart: return 0;
		}
	}
};
/**
* Creates a function that decodes entities in a string.
*
* @param decodeTree The decode tree.
* @returns A function that decodes entities in a string.
*/
function getDecoder(decodeTree) {
	let returnValue = "";
	const decoder = new EntityDecoder(decodeTree, (data) => returnValue += fromCodePoint(data));
	return function decodeWithTrie(input, decodeMode) {
		let lastIndex = 0;
		let offset = 0;
		while ((offset = input.indexOf("&", offset)) >= 0) {
			returnValue += input.slice(lastIndex, offset);
			decoder.startEntity(decodeMode);
			const length = decoder.write(input, offset + 1);
			if (length < 0) {
				lastIndex = offset + decoder.end();
				break;
			}
			lastIndex = offset + length;
			offset = length === 0 ? lastIndex + 1 : lastIndex;
		}
		const result = returnValue + input.slice(lastIndex);
		returnValue = "";
		return result;
	};
}
/**
* Determines the branch of the current node that is taken given the current
* character. This function is used to traverse the trie.
*
* @param decodeTree The trie.
* @param current The current node.
* @param nodeIdx The index right after the current node and its value.
* @param char The current character.
* @returns The index of the next node, or -1 if no branch is taken.
*/
function determineBranch(decodeTree, current, nodeIndex, char) {
	const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
	const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
	if (branchCount === 0) return jumpOffset !== 0 && char === jumpOffset ? nodeIndex : -1;
	if (jumpOffset) {
		const value = char - jumpOffset;
		return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIndex + value] - 1;
	}
	const packedKeySlots = branchCount + 1 >> 1;
	let lo = 0;
	let hi = branchCount - 1;
	while (lo <= hi) {
		const mid = lo + hi >>> 1;
		const midKey = decodeTree[nodeIndex + (mid >> 1)] >> (mid & 1) * 8 & 255;
		if (midKey < char) lo = mid + 1;
		else if (midKey > char) hi = mid - 1;
		else return decodeTree[nodeIndex + packedKeySlots + mid];
	}
	return -1;
}
const htmlDecoder = /* @__PURE__ */ getDecoder(htmlDecodeTree);
/**
* Decodes an HTML string.
*
* @param htmlString The string to decode.
* @param mode The decoding mode.
* @returns The decoded string.
*/
function decodeHTML(htmlString, mode = DecodingMode.Legacy) {
	return htmlDecoder(htmlString, mode);
}

//#endregion
//#region packages/compiler-core/src/tokenizer.ts
/**
* Note: entities is a non-browser-build-only dependency.
* In the browser, we use an HTML element to do the decoding.
* Make sure all imports from entities are only used in non-browser branches
* so that it can be properly treeshaken.
*/
const defaultDelimitersOpen = new Uint8Array([123, 123]);
const defaultDelimitersClose = new Uint8Array([125, 125]);
/**
* HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a
* tag name.
*/
function isTagStartChar(c) {
	return c >= 97 && c <= 122 || c >= 65 && c <= 90;
}
function isWhitespace(c) {
	return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
}
function isEndOfTagSection(c) {
	return c === 47 || c === 62 || isWhitespace(c);
}
function toCharCodes(str) {
	const ret = new Uint8Array(str.length);
	for (let i = 0; i < str.length; i++) ret[i] = str.charCodeAt(i);
	return ret;
}
/**
* Sequences used to match longer strings.
*
* We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End
* sequences with an increased offset.
*/
const Sequences = {
	Cdata: new Uint8Array([
		67,
		68,
		65,
		84,
		65,
		91
	]),
	CdataEnd: new Uint8Array([
		93,
		93,
		62
	]),
	CommentEnd: new Uint8Array([
		45,
		45,
		62
	]),
	ScriptEnd: new Uint8Array([
		60,
		47,
		115,
		99,
		114,
		105,
		112,
		116
	]),
	StyleEnd: new Uint8Array([
		60,
		47,
		115,
		116,
		121,
		108,
		101
	]),
	TitleEnd: new Uint8Array([
		60,
		47,
		116,
		105,
		116,
		108,
		101
	]),
	TextareaEnd: new Uint8Array([
		60,
		47,
		116,
		101,
		120,
		116,
		97,
		114,
		101,
		97
	])
};
var Tokenizer = class {
	get inSFCRoot() {
		return this.mode === 2 && this.stack.length === 0;
	}
	constructor(stack, cbs) {
		this.stack = stack;
		this.cbs = cbs;
		this.state = 1;
		this.buffer = "";
		this.sectionStart = 0;
		this.index = 0;
		this.entityStart = 0;
		this.baseState = 1;
		this.inRCDATA = false;
		this.inXML = false;
		this.inVPre = false;
		this.newlines = [];
		this.mode = 0;
		this.delimiterOpen = defaultDelimitersOpen;
		this.delimiterClose = defaultDelimitersClose;
		this.delimiterIndex = -1;
		this.currentSequence = void 0;
		this.sequenceIndex = 0;
		this.entityDecoder = new EntityDecoder(htmlDecodeTree, (cp, consumed) => this.emitCodePoint(cp, consumed));
	}
	reset() {
		this.state = 1;
		this.mode = 0;
		this.buffer = "";
		this.sectionStart = 0;
		this.index = 0;
		this.baseState = 1;
		this.inRCDATA = false;
		this.currentSequence = void 0;
		this.newlines.length = 0;
		this.delimiterOpen = defaultDelimitersOpen;
		this.delimiterClose = defaultDelimitersClose;
	}
	/**
	* Generate Position object with line / column information using recorded
	* newline positions. We know the index is always going to be an already
	* processed index, so all the newlines up to this index should have been
	* recorded.
	*/
	getPos(index) {
		let line = 1;
		let column = index + 1;
		const length = this.newlines.length;
		let j = -1;
		if (length > 100) {
			let l = -1;
			let r = length;
			while (l + 1 < r) {
				const m = l + r >>> 1;
				this.newlines[m] < index ? l = m : r = m;
			}
			j = l;
		} else for (let i = length - 1; i >= 0; i--) if (index > this.newlines[i]) {
			j = i;
			break;
		}
		if (j >= 0) {
			line = j + 2;
			column = index - this.newlines[j];
		}
		return {
			column,
			line,
			offset: index
		};
	}
	peek() {
		return this.buffer.charCodeAt(this.index + 1);
	}
	stateText(c) {
		if (c === 60) {
			if (this.index > this.sectionStart) this.cbs.ontext(this.sectionStart, this.index);
			this.state = 5;
			this.sectionStart = this.index;
		} else if (c === 38) this.startEntity();
		else if (!this.inVPre && c === this.delimiterOpen[0]) {
			this.state = 2;
			this.delimiterIndex = 0;
			this.stateInterpolationOpen(c);
		}
	}
	stateInterpolationOpen(c) {
		if (c === this.delimiterOpen[this.delimiterIndex]) if (this.delimiterIndex === this.delimiterOpen.length - 1) {
			const start = this.index + 1 - this.delimiterOpen.length;
			if (start > this.sectionStart) this.cbs.ontext(this.sectionStart, start);
			this.state = 3;
			this.sectionStart = start;
		} else this.delimiterIndex++;
		else if (this.inRCDATA) {
			this.state = 32;
			this.stateInRCDATA(c);
		} else {
			this.state = 1;
			this.stateText(c);
		}
	}
	stateInterpolation(c) {
		if (c === this.delimiterClose[0]) {
			this.state = 4;
			this.delimiterIndex = 0;
			this.stateInterpolationClose(c);
		}
	}
	stateInterpolationClose(c) {
		if (c === this.delimiterClose[this.delimiterIndex]) if (this.delimiterIndex === this.delimiterClose.length - 1) {
			this.cbs.oninterpolation(this.sectionStart, this.index + 1);
			if (this.inRCDATA) this.state = 32;
			else this.state = 1;
			this.sectionStart = this.index + 1;
		} else this.delimiterIndex++;
		else {
			this.state = 3;
			this.stateInterpolation(c);
		}
	}
	stateSpecialStartSequence(c) {
		const isEnd = this.sequenceIndex === this.currentSequence.length;
		if (!(isEnd ? isEndOfTagSection(c) : (c | 32) === this.currentSequence[this.sequenceIndex])) this.inRCDATA = false;
		else if (!isEnd) {
			this.sequenceIndex++;
			return;
		}
		this.sequenceIndex = 0;
		this.state = 6;
		this.stateInTagName(c);
	}
	/** Look for an end tag. For <title> and <textarea>, also decode entities. */
	stateInRCDATA(c) {
		if (this.sequenceIndex === this.currentSequence.length) {
			if (c === 62 || isWhitespace(c)) {
				const endOfText = this.index - this.currentSequence.length;
				if (this.sectionStart < endOfText) {
					const actualIndex = this.index;
					this.index = endOfText;
					this.cbs.ontext(this.sectionStart, endOfText);
					this.index = actualIndex;
				}
				this.sectionStart = endOfText + 2;
				this.stateInClosingTagName(c);
				this.inRCDATA = false;
				return;
			}
			this.sequenceIndex = 0;
		}
		if ((c | 32) === this.currentSequence[this.sequenceIndex]) this.sequenceIndex += 1;
		else if (this.sequenceIndex === 0) {
			if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
				if (c === 38) this.startEntity();
				else if (!this.inVPre && c === this.delimiterOpen[0]) {
					this.state = 2;
					this.delimiterIndex = 0;
					this.stateInterpolationOpen(c);
				}
			} else if (this.fastForwardTo(60)) this.sequenceIndex = 1;
		} else this.sequenceIndex = Number(c === 60);
	}
	stateCDATASequence(c) {
		if (c === Sequences.Cdata[this.sequenceIndex]) {
			if (++this.sequenceIndex === Sequences.Cdata.length) {
				this.state = 28;
				this.currentSequence = Sequences.CdataEnd;
				this.sequenceIndex = 0;
				this.sectionStart = this.index + 1;
			}
		} else {
			this.sequenceIndex = 0;
			this.state = 23;
			this.stateInDeclaration(c);
		}
	}
	/**
	* When we wait for one specific character, we can speed things up
	* by skipping through the buffer until we find it.
	*
	* @returns Whether the character was found.
	*/
	fastForwardTo(c) {
		while (++this.index < this.buffer.length) {
			const cc = this.buffer.charCodeAt(this.index);
			if (cc === 10) this.newlines.push(this.index);
			if (cc === c) return true;
		}
		this.index = this.buffer.length - 1;
		return false;
	}
	/**
	* Comments and CDATA end with `-->` and `]]>`.
	*
	* Their common qualities are:
	* - Their end sequences have a distinct character they start with.
	* - That character is then repeated, so we have to check multiple repeats.
	* - All characters but the start character of the sequence can be skipped.
	*/
	stateInCommentLike(c) {
		if (c === this.currentSequence[this.sequenceIndex]) {
			if (++this.sequenceIndex === this.currentSequence.length) {
				if (this.currentSequence === Sequences.CdataEnd) this.cbs.oncdata(this.sectionStart, this.index - 2);
				else this.cbs.oncomment(this.sectionStart, this.index - 2);
				this.sequenceIndex = 0;
				this.sectionStart = this.index + 1;
				this.state = 1;
			}
		} else if (this.sequenceIndex === 0) {
			if (this.fastForwardTo(this.currentSequence[0])) this.sequenceIndex = 1;
		} else if (c !== this.currentSequence[this.sequenceIndex - 1]) this.sequenceIndex = 0;
	}
	startSpecial(sequence, offset) {
		this.enterRCDATA(sequence, offset);
		this.state = 31;
	}
	enterRCDATA(sequence, offset) {
		this.inRCDATA = true;
		this.currentSequence = sequence;
		this.sequenceIndex = offset;
	}
	stateBeforeTagName(c) {
		if (c === 33) {
			this.state = 22;
			this.sectionStart = this.index + 1;
		} else if (c === 63) {
			this.state = 24;
			this.sectionStart = this.index + 1;
		} else if (isTagStartChar(c)) {
			this.sectionStart = this.index;
			if (this.mode === 0) this.state = 6;
			else if (this.inSFCRoot) this.state = 34;
			else if (!this.inXML) if (c === 116) this.state = 30;
			else this.state = c === 115 ? 29 : 6;
			else this.state = 6;
		} else if (c === 47) this.state = 8;
		else {
			this.state = 1;
			this.stateText(c);
		}
	}
	stateInTagName(c) {
		if (isEndOfTagSection(c)) this.handleTagName(c);
	}
	stateInSFCRootTagName(c) {
		if (isEndOfTagSection(c)) {
			const tag = this.buffer.slice(this.sectionStart, this.index);
			if (tag !== "template") this.enterRCDATA(toCharCodes(`</` + tag), 0);
			this.handleTagName(c);
		}
	}
	handleTagName(c) {
		this.cbs.onopentagname(this.sectionStart, this.index);
		this.sectionStart = -1;
		this.state = 11;
		this.stateBeforeAttrName(c);
	}
	stateBeforeClosingTagName(c) {
		if (isWhitespace(c)) {} else if (c === 62) {
			this.cbs.onerr(14, this.index);
			this.state = 1;
			this.sectionStart = this.index + 1;
		} else {
			this.state = isTagStartChar(c) ? 9 : 27;
			this.sectionStart = this.index;
		}
	}
	stateInClosingTagName(c) {
		if (c === 62 || isWhitespace(c)) {
			this.cbs.onclosetag(this.sectionStart, this.index);
			this.sectionStart = -1;
			this.state = 10;
			this.stateAfterClosingTagName(c);
		}
	}
	stateAfterClosingTagName(c) {
		if (c === 62) {
			this.state = 1;
			this.sectionStart = this.index + 1;
		}
	}
	stateBeforeAttrName(c) {
		if (c === 62) {
			this.cbs.onopentagend(this.index);
			if (this.inRCDATA) this.state = 32;
			else this.state = 1;
			this.sectionStart = this.index + 1;
		} else if (c === 47) {
			this.state = 7;
			if (this.peek() !== 62) this.cbs.onerr(22, this.index);
		} else if (c === 60 && this.peek() === 47) {
			this.cbs.onopentagend(this.index);
			this.state = 5;
			this.sectionStart = this.index;
		} else if (!isWhitespace(c)) {
			if (c === 61) this.cbs.onerr(19, this.index);
			this.handleAttrStart(c);
		}
	}
	handleAttrStart(c) {
		if (c === 118 && this.peek() === 45) {
			this.state = 13;
			this.sectionStart = this.index;
		} else if (c === 46 || c === 58 || c === 64 || c === 35) {
			this.cbs.ondirname(this.index, this.index + 1);
			this.state = 14;
			this.sectionStart = this.index + 1;
		} else {
			this.state = 12;
			this.sectionStart = this.index;
		}
	}
	stateInSelfClosingTag(c) {
		if (c === 62) {
			this.cbs.onselfclosingtag(this.index);
			this.state = 1;
			this.sectionStart = this.index + 1;
			this.inRCDATA = false;
		} else if (!isWhitespace(c)) {
			this.state = 11;
			this.stateBeforeAttrName(c);
		}
	}
	stateInAttrName(c) {
		if (c === 61 || isEndOfTagSection(c)) {
			this.cbs.onattribname(this.sectionStart, this.index);
			this.handleAttrNameEnd(c);
		} else if (c === 34 || c === 39 || c === 60) this.cbs.onerr(17, this.index);
	}
	stateInDirName(c) {
		if (c === 61 || isEndOfTagSection(c)) {
			this.cbs.ondirname(this.sectionStart, this.index);
			this.handleAttrNameEnd(c);
		} else if (c === 58) {
			this.cbs.ondirname(this.sectionStart, this.index);
			this.state = 14;
			this.sectionStart = this.index + 1;
		} else if (c === 46) {
			this.cbs.ondirname(this.sectionStart, this.index);
			this.state = 16;
			this.sectionStart = this.index + 1;
		}
	}
	stateInDirArg(c) {
		if (c === 61 || isEndOfTagSection(c)) {
			this.cbs.ondirarg(this.sectionStart, this.index);
			this.handleAttrNameEnd(c);
		} else if (c === 91) this.state = 15;
		else if (c === 46) {
			this.cbs.ondirarg(this.sectionStart, this.index);
			this.state = 16;
			this.sectionStart = this.index + 1;
		}
	}
	stateInDynamicDirArg(c) {
		if (c === 93) this.state = 14;
		else if (c === 61 || isEndOfTagSection(c)) {
			this.cbs.ondirarg(this.sectionStart, this.index + 1);
			this.handleAttrNameEnd(c);
			this.cbs.onerr(27, this.index);
		}
	}
	stateInDirModifier(c) {
		if (c === 61 || isEndOfTagSection(c)) {
			this.cbs.ondirmodifier(this.sectionStart, this.index);
			this.handleAttrNameEnd(c);
		} else if (c === 46) {
			this.cbs.ondirmodifier(this.sectionStart, this.index);
			this.sectionStart = this.index + 1;
		}
	}
	handleAttrNameEnd(c) {
		this.sectionStart = this.index;
		this.state = 17;
		this.cbs.onattribnameend(this.index);
		this.stateAfterAttrName(c);
	}
	stateAfterAttrName(c) {
		if (c === 61) this.state = 18;
		else if (c === 47 || c === 62) {
			this.cbs.onattribend(0, this.sectionStart);
			this.sectionStart = -1;
			this.state = 11;
			this.stateBeforeAttrName(c);
		} else if (!isWhitespace(c)) {
			this.cbs.onattribend(0, this.sectionStart);
			this.handleAttrStart(c);
		}
	}
	stateBeforeAttrValue(c) {
		if (c === 34) {
			this.state = 19;
			this.sectionStart = this.index + 1;
		} else if (c === 39) {
			this.state = 20;
			this.sectionStart = this.index + 1;
		} else if (!isWhitespace(c)) {
			this.sectionStart = this.index;
			this.state = 21;
			this.stateInAttrValueNoQuotes(c);
		}
	}
	handleInAttrValue(c, quote) {
		if (c === quote || false) {
			this.cbs.onattribdata(this.sectionStart, this.index);
			this.sectionStart = -1;
			this.cbs.onattribend(quote === 34 ? 3 : 2, this.index + 1);
			this.state = 11;
		} else if (c === 38) this.startEntity();
	}
	stateInAttrValueDoubleQuotes(c) {
		this.handleInAttrValue(c, 34);
	}
	stateInAttrValueSingleQuotes(c) {
		this.handleInAttrValue(c, 39);
	}
	stateInAttrValueNoQuotes(c) {
		if (isWhitespace(c) || c === 62) {
			this.cbs.onattribdata(this.sectionStart, this.index);
			this.sectionStart = -1;
			this.cbs.onattribend(1, this.index);
			this.state = 11;
			this.stateBeforeAttrName(c);
		} else if (c === 34 || c === 39 || c === 60 || c === 61 || c === 96) this.cbs.onerr(18, this.index);
		else if (c === 38) this.startEntity();
	}
	stateBeforeDeclaration(c) {
		if (c === 91) {
			this.state = 26;
			this.sequenceIndex = 0;
		} else this.state = c === 45 ? 25 : 23;
	}
	stateInDeclaration(c) {
		if (c === 62 || this.fastForwardTo(62)) {
			this.state = 1;
			this.sectionStart = this.index + 1;
		}
	}
	stateInProcessingInstruction(c) {
		if (c === 62 || this.fastForwardTo(62)) {
			this.cbs.onprocessinginstruction(this.sectionStart, this.index);
			this.state = 1;
			this.sectionStart = this.index + 1;
		}
	}
	stateBeforeComment(c) {
		if (c === 45) {
			this.state = 28;
			this.currentSequence = Sequences.CommentEnd;
			this.sequenceIndex = 2;
			this.sectionStart = this.index + 1;
		} else this.state = 23;
	}
	stateInSpecialComment(c) {
		if (c === 62 || this.fastForwardTo(62)) {
			this.cbs.oncomment(this.sectionStart, this.index);
			this.state = 1;
			this.sectionStart = this.index + 1;
		}
	}
	stateBeforeSpecialS(c) {
		if (c === Sequences.ScriptEnd[3]) this.startSpecial(Sequences.ScriptEnd, 4);
		else if (c === Sequences.StyleEnd[3]) this.startSpecial(Sequences.StyleEnd, 4);
		else {
			this.state = 6;
			this.stateInTagName(c);
		}
	}
	stateBeforeSpecialT(c) {
		if (c === Sequences.TitleEnd[3]) this.startSpecial(Sequences.TitleEnd, 4);
		else if (c === Sequences.TextareaEnd[3]) this.startSpecial(Sequences.TextareaEnd, 4);
		else {
			this.state = 6;
			this.stateInTagName(c);
		}
	}
	startEntity() {
		this.baseState = this.state;
		this.state = 33;
		this.entityStart = this.index;
		this.entityDecoder.startEntity(this.baseState === 1 || this.baseState === 32 ? DecodingMode.Legacy : DecodingMode.Attribute);
	}
	stateInEntity() {
		{
			const length = this.entityDecoder.write(this.buffer, this.index);
			if (length >= 0) {
				this.state = this.baseState;
				if (length === 0) this.index = this.entityStart;
			} else this.index = this.buffer.length - 1;
		}
	}
	/**
	* Iterates through the buffer, calling the function corresponding to the current state.
	*
	* States that are more likely to be hit are higher up, as a performance improvement.
	*/
	parse(input) {
		this.buffer = input;
		while (this.index < this.buffer.length) {
			const c = this.buffer.charCodeAt(this.index);
			if (c === 10 && this.state !== 33) this.newlines.push(this.index);
			switch (this.state) {
				case 1:
					this.stateText(c);
					break;
				case 2:
					this.stateInterpolationOpen(c);
					break;
				case 3:
					this.stateInterpolation(c);
					break;
				case 4:
					this.stateInterpolationClose(c);
					break;
				case 31:
					this.stateSpecialStartSequence(c);
					break;
				case 32:
					this.stateInRCDATA(c);
					break;
				case 26:
					this.stateCDATASequence(c);
					break;
				case 19:
					this.stateInAttrValueDoubleQuotes(c);
					break;
				case 12:
					this.stateInAttrName(c);
					break;
				case 13:
					this.stateInDirName(c);
					break;
				case 14:
					this.stateInDirArg(c);
					break;
				case 15:
					this.stateInDynamicDirArg(c);
					break;
				case 16:
					this.stateInDirModifier(c);
					break;
				case 28:
					this.stateInCommentLike(c);
					break;
				case 27:
					this.stateInSpecialComment(c);
					break;
				case 11:
					this.stateBeforeAttrName(c);
					break;
				case 6:
					this.stateInTagName(c);
					break;
				case 34:
					this.stateInSFCRootTagName(c);
					break;
				case 9:
					this.stateInClosingTagName(c);
					break;
				case 5:
					this.stateBeforeTagName(c);
					break;
				case 17:
					this.stateAfterAttrName(c);
					break;
				case 20:
					this.stateInAttrValueSingleQuotes(c);
					break;
				case 18:
					this.stateBeforeAttrValue(c);
					break;
				case 8:
					this.stateBeforeClosingTagName(c);
					break;
				case 10:
					this.stateAfterClosingTagName(c);
					break;
				case 29:
					this.stateBeforeSpecialS(c);
					break;
				case 30:
					this.stateBeforeSpecialT(c);
					break;
				case 21:
					this.stateInAttrValueNoQuotes(c);
					break;
				case 7:
					this.stateInSelfClosingTag(c);
					break;
				case 23:
					this.stateInDeclaration(c);
					break;
				case 22:
					this.stateBeforeDeclaration(c);
					break;
				case 25:
					this.stateBeforeComment(c);
					break;
				case 24:
					this.stateInProcessingInstruction(c);
					break;
				case 33:
					this.stateInEntity();
					break;
			}
			this.index++;
		}
		this.cleanup();
		this.finish();
	}
	/**
	* Remove data that has already been consumed from the buffer.
	*/
	cleanup() {
		if (this.sectionStart !== this.index) {
			if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
				this.cbs.ontext(this.sectionStart, this.index);
				this.sectionStart = this.index;
			} else if (this.state === 19 || this.state === 20 || this.state === 21) {
				this.cbs.onattribdata(this.sectionStart, this.index);
				this.sectionStart = this.index;
			}
		}
	}
	finish() {
		if (this.state === 33) {
			this.entityDecoder.end();
			this.state = this.baseState;
		}
		this.handleTrailingData();
		this.cbs.onend();
	}
	/** Handle any trailing data. */
	handleTrailingData() {
		const endIndex = this.buffer.length;
		if (this.sectionStart >= endIndex) return;
		if (this.state === 28) if (this.currentSequence === Sequences.CdataEnd) this.cbs.oncdata(this.sectionStart, endIndex);
		else this.cbs.oncomment(this.sectionStart, endIndex);
		else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9) {} else this.cbs.ontext(this.sectionStart, endIndex);
	}
	emitCodePoint(cp, consumed) {
		if (this.baseState !== 1 && this.baseState !== 32) {
			if (this.sectionStart < this.entityStart) this.cbs.onattribdata(this.sectionStart, this.entityStart);
			this.sectionStart = this.entityStart + consumed;
			this.index = this.sectionStart - 1;
			this.cbs.onattribentity(fromCodePoint(cp), this.entityStart, this.sectionStart);
		} else {
			if (this.sectionStart < this.entityStart) this.cbs.ontext(this.sectionStart, this.entityStart);
			this.sectionStart = this.entityStart + consumed;
			this.index = this.sectionStart - 1;
			this.cbs.ontextentity(fromCodePoint(cp), this.entityStart, this.sectionStart);
		}
	}
};

//#endregion
//#region packages/compiler-core/src/compat/compatConfig.ts
const CompilerDeprecationTypes = {
	"COMPILER_IS_ON_ELEMENT": "COMPILER_IS_ON_ELEMENT",
	"COMPILER_V_BIND_SYNC": "COMPILER_V_BIND_SYNC",
	"COMPILER_V_BIND_OBJECT_ORDER": "COMPILER_V_BIND_OBJECT_ORDER",
	"COMPILER_V_ON_NATIVE": "COMPILER_V_ON_NATIVE",
	"COMPILER_V_IF_V_FOR_PRECEDENCE": "COMPILER_V_IF_V_FOR_PRECEDENCE",
	"COMPILER_NATIVE_TEMPLATE": "COMPILER_NATIVE_TEMPLATE",
	"COMPILER_INLINE_TEMPLATE": "COMPILER_INLINE_TEMPLATE",
	"COMPILER_FILTERS": "COMPILER_FILTERS"
};
const deprecationData = {
	["COMPILER_IS_ON_ELEMENT"]: {
		message: "Platform-native elements with \"is\" prop will no longer be treated as components in Vue 3 unless the \"is\" value is explicitly prefixed with \"vue:\".",
		link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
	},
	["COMPILER_V_BIND_SYNC"]: {
		message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
		link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
	},
	["COMPILER_V_BIND_OBJECT_ORDER"]: {
		message: "v-bind=\"obj\" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.",
		link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
	},
	["COMPILER_V_ON_NATIVE"]: {
		message: `.native modifier for v-on has been removed as is no longer necessary.`,
		link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
	},
	["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
		message: "v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.",
		link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
	},
	["COMPILER_NATIVE_TEMPLATE"]: { message: "<template> with no special directives will render as a native template element instead of its inner content in Vue 3." },
	["COMPILER_INLINE_TEMPLATE"]: {
		message: `"inline-template" has been removed in Vue 3.`,
		link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
	},
	["COMPILER_FILTERS"]: {
		message: "filters have been removed in Vue 3. The \"|\" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.",
		link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
	}
};
function getCompatValue(key, { compatConfig }) {
	const value = compatConfig && compatConfig[key];
	if (key === "MODE") return value || 3;
	else return value;
}
function isCompatEnabled(key, context) {
	const mode = getCompatValue("MODE", context);
	const value = getCompatValue(key, context);
	return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
	return isCompatEnabled(key, context);
}
function warnDeprecation(key, context, loc, ...args) {
	if (getCompatValue(key, context) === "suppress-warning") return;
	const { message, link } = deprecationData[key];
	const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `\n  Details: ${link}` : ``}`;
	const err = new SyntaxError(msg);
	err.code = key;
	if (loc) err.loc = loc;
	context.onWarn(err);
}

//#endregion
//#region packages/compiler-core/src/errors.ts
function defaultOnError(error) {
	throw error;
}
function defaultOnWarn(msg) {}
function createCompilerError(code, loc, messages, additionalMessage) {
	const msg = (messages || errorMessages)[code] + (additionalMessage || ``);
	const error = new SyntaxError(String(msg));
	error.code = code;
	error.loc = loc;
	return error;
}
const ErrorCodes = {
	"ABRUPT_CLOSING_OF_EMPTY_COMMENT": 0,
	"0": "ABRUPT_CLOSING_OF_EMPTY_COMMENT",
	"CDATA_IN_HTML_CONTENT": 1,
	"1": "CDATA_IN_HTML_CONTENT",
	"DUPLICATE_ATTRIBUTE": 2,
	"2": "DUPLICATE_ATTRIBUTE",
	"END_TAG_WITH_ATTRIBUTES": 3,
	"3": "END_TAG_WITH_ATTRIBUTES",
	"END_TAG_WITH_TRAILING_SOLIDUS": 4,
	"4": "END_TAG_WITH_TRAILING_SOLIDUS",
	"EOF_BEFORE_TAG_NAME": 5,
	"5": "EOF_BEFORE_TAG_NAME",
	"EOF_IN_CDATA": 6,
	"6": "EOF_IN_CDATA",
	"EOF_IN_COMMENT": 7,
	"7": "EOF_IN_COMMENT",
	"EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT": 8,
	"8": "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT",
	"EOF_IN_TAG": 9,
	"9": "EOF_IN_TAG",
	"INCORRECTLY_CLOSED_COMMENT": 10,
	"10": "INCORRECTLY_CLOSED_COMMENT",
	"INCORRECTLY_OPENED_COMMENT": 11,
	"11": "INCORRECTLY_OPENED_COMMENT",
	"INVALID_FIRST_CHARACTER_OF_TAG_NAME": 12,
	"12": "INVALID_FIRST_CHARACTER_OF_TAG_NAME",
	"MISSING_ATTRIBUTE_VALUE": 13,
	"13": "MISSING_ATTRIBUTE_VALUE",
	"MISSING_END_TAG_NAME": 14,
	"14": "MISSING_END_TAG_NAME",
	"MISSING_WHITESPACE_BETWEEN_ATTRIBUTES": 15,
	"15": "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES",
	"NESTED_COMMENT": 16,
	"16": "NESTED_COMMENT",
	"UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME": 17,
	"17": "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME",
	"UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE": 18,
	"18": "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE",
	"UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME": 19,
	"19": "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME",
	"UNEXPECTED_NULL_CHARACTER": 20,
	"20": "UNEXPECTED_NULL_CHARACTER",
	"UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME": 21,
	"21": "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME",
	"UNEXPECTED_SOLIDUS_IN_TAG": 22,
	"22": "UNEXPECTED_SOLIDUS_IN_TAG",
	"X_INVALID_END_TAG": 23,
	"23": "X_INVALID_END_TAG",
	"X_MISSING_END_TAG": 24,
	"24": "X_MISSING_END_TAG",
	"X_MISSING_INTERPOLATION_END": 25,
	"25": "X_MISSING_INTERPOLATION_END",
	"X_MISSING_DIRECTIVE_NAME": 26,
	"26": "X_MISSING_DIRECTIVE_NAME",
	"X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END": 27,
	"27": "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END",
	"X_V_IF_NO_EXPRESSION": 28,
	"28": "X_V_IF_NO_EXPRESSION",
	"X_V_IF_SAME_KEY": 29,
	"29": "X_V_IF_SAME_KEY",
	"X_V_ELSE_NO_ADJACENT_IF": 30,
	"30": "X_V_ELSE_NO_ADJACENT_IF",
	"X_V_FOR_NO_EXPRESSION": 31,
	"31": "X_V_FOR_NO_EXPRESSION",
	"X_V_FOR_MALFORMED_EXPRESSION": 32,
	"32": "X_V_FOR_MALFORMED_EXPRESSION",
	"X_V_FOR_TEMPLATE_KEY_PLACEMENT": 33,
	"33": "X_V_FOR_TEMPLATE_KEY_PLACEMENT",
	"X_V_BIND_NO_EXPRESSION": 34,
	"34": "X_V_BIND_NO_EXPRESSION",
	"X_V_ON_NO_EXPRESSION": 35,
	"35": "X_V_ON_NO_EXPRESSION",
	"X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET": 36,
	"36": "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET",
	"X_V_SLOT_MIXED_SLOT_USAGE": 37,
	"37": "X_V_SLOT_MIXED_SLOT_USAGE",
	"X_V_SLOT_DUPLICATE_SLOT_NAMES": 38,
	"38": "X_V_SLOT_DUPLICATE_SLOT_NAMES",
	"X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN": 39,
	"39": "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN",
	"X_V_SLOT_MISPLACED": 40,
	"40": "X_V_SLOT_MISPLACED",
	"X_V_MODEL_NO_EXPRESSION": 41,
	"41": "X_V_MODEL_NO_EXPRESSION",
	"X_V_MODEL_MALFORMED_EXPRESSION": 42,
	"42": "X_V_MODEL_MALFORMED_EXPRESSION",
	"X_V_MODEL_ON_SCOPE_VARIABLE": 43,
	"43": "X_V_MODEL_ON_SCOPE_VARIABLE",
	"X_V_MODEL_ON_PROPS": 44,
	"44": "X_V_MODEL_ON_PROPS",
	"X_V_MODEL_ON_CONST": 45,
	"45": "X_V_MODEL_ON_CONST",
	"X_INVALID_EXPRESSION": 46,
	"46": "X_INVALID_EXPRESSION",
	"X_KEEP_ALIVE_INVALID_CHILDREN": 47,
	"47": "X_KEEP_ALIVE_INVALID_CHILDREN",
	"X_PREFIX_ID_NOT_SUPPORTED": 48,
	"48": "X_PREFIX_ID_NOT_SUPPORTED",
	"X_MODULE_MODE_NOT_SUPPORTED": 49,
	"49": "X_MODULE_MODE_NOT_SUPPORTED",
	"X_CACHE_HANDLER_NOT_SUPPORTED": 50,
	"50": "X_CACHE_HANDLER_NOT_SUPPORTED",
	"X_SCOPE_ID_NOT_SUPPORTED": 51,
	"51": "X_SCOPE_ID_NOT_SUPPORTED",
	"X_VNODE_HOOKS": 52,
	"52": "X_VNODE_HOOKS",
	"X_V_BIND_INVALID_SAME_NAME_ARGUMENT": 53,
	"53": "X_V_BIND_INVALID_SAME_NAME_ARGUMENT",
	"__EXTEND_POINT__": 54,
	"54": "__EXTEND_POINT__"
};
const errorMessages = {
	[0]: "Illegal comment.",
	[1]: "CDATA section is allowed only in XML context.",
	[2]: "Duplicate attribute.",
	[3]: "End tag cannot have attributes.",
	[4]: "Illegal '/' in tags.",
	[5]: "Unexpected EOF in tag.",
	[6]: "Unexpected EOF in CDATA section.",
	[7]: "Unexpected EOF in comment.",
	[8]: "Unexpected EOF in script.",
	[9]: "Unexpected EOF in tag.",
	[10]: "Incorrectly closed comment.",
	[11]: "Incorrectly opened comment.",
	[12]: "Illegal tag name. Use '&lt;' to print '<'.",
	[13]: "Attribute value was expected.",
	[14]: "End tag name was expected.",
	[15]: "Whitespace was expected.",
	[16]: "Unexpected '<!--' in comment.",
	[17]: "Attribute name cannot contain U+0022 (\"), U+0027 ('), and U+003C (<).",
	[18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
	[19]: "Attribute name cannot start with '='.",
	[21]: "'<?' is allowed only in XML context.",
	[20]: `Unexpected null character.`,
	[22]: "Illegal '/' in tags.",
	[23]: "Invalid end tag.",
	[24]: "Element is missing end tag.",
	[25]: "Interpolation end sign was not found.",
	[27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
	[26]: "Legal directive name was expected.",
	[28]: `v-if/v-else-if is missing expression.`,
	[29]: `v-if/else branches must use unique keys.`,
	[30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
	[31]: `v-for is missing expression.`,
	[32]: `v-for has invalid expression.`,
	[33]: `<template v-for> key should be placed on the <template> tag.`,
	[34]: `v-bind is missing expression.`,
	[53]: `v-bind with same-name shorthand only allows static argument.`,
	[35]: `v-on is missing expression.`,
	[36]: `Unexpected custom directive on <slot> outlet.`,
	[37]: "Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.",
	[38]: `Duplicate slot names found. `,
	[39]: "Extraneous children found when component already has explicitly named default slot. These children will be ignored.",
	[40]: `v-slot can only be used on components or <template> tags.`,
	[41]: `v-model is missing expression.`,
	[42]: `v-model value must be a valid JavaScript member expression.`,
	[43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
	[44]: `v-model cannot be used on a prop, because local prop bindings are not writable.\nUse a v-bind binding combined with a v-on listener that emits update:x event instead.`,
	[45]: `v-model cannot be used on a const binding because it is not writable.`,
	[46]: `Error parsing JavaScript expression: `,
	[47]: `<KeepAlive> expects exactly one child component.`,
	[52]: `@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.`,
	[48]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
	[49]: `ES module mode is not supported in this build of compiler.`,
	[50]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
	[51]: `"scopeId" option is only supported in module mode.`,
	[54]: ``
};

//#endregion
//#region packages/compiler-core/src/babelUtils.ts
/**
* Return value indicates whether the AST walked can be a constant
*/
function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = Object.create(null)) {
	const rootExp = root.type === "Program" ? root.body[0].type === "ExpressionStatement" && root.body[0].expression : root;
	(0, estree_walker.walk)(root, {
		enter(node, parent) {
			parent && parentStack.push(parent);
			if (parent && parent.type.startsWith("TS") && !TS_NODE_TYPES.includes(parent.type)) return this.skip();
			if (node.type === "Identifier") {
				const isLocal = !!knownIds[node.name];
				const isRefed = isReferencedIdentifier(node, parent, parentStack);
				if (includeAll || isRefed && !isLocal) onIdentifier(node, parent, parentStack, isRefed, isLocal);
			} else if (node.type === "ObjectProperty" && (parent === null || parent === void 0 ? void 0 : parent.type) === "ObjectPattern") node.inPattern = true;
			else if (isFunctionType(node)) if (node.scopeIds) node.scopeIds.forEach((id) => markKnownIds(id, knownIds));
			else walkFunctionParams(node, (id) => markScopeIdentifier(node, id, knownIds));
			else if (node.type === "BlockStatement") if (node.scopeIds) node.scopeIds.forEach((id) => markKnownIds(id, knownIds));
			else walkBlockDeclarations(node, (id) => markScopeIdentifier(node, id, knownIds));
			else if (node.type === "SwitchStatement") if (node.scopeIds) node.scopeIds.forEach((id) => markKnownIds(id, knownIds));
			else walkSwitchStatement(node, false, (id) => markScopeIdentifier(node, id, knownIds));
			else if (node.type === "CatchClause" && node.param) if (node.scopeIds) node.scopeIds.forEach((id) => markKnownIds(id, knownIds));
			else for (const id of extractIdentifiers(node.param)) markScopeIdentifier(node, id, knownIds);
			else if (isForStatement(node)) if (node.scopeIds) node.scopeIds.forEach((id) => markKnownIds(id, knownIds));
			else walkForStatement(node, false, (id) => markScopeIdentifier(node, id, knownIds));
		},
		leave(node, parent) {
			parent && parentStack.pop();
			if (node !== rootExp && node.scopeIds) for (const id of node.scopeIds) {
				knownIds[id]--;
				if (knownIds[id] === 0) delete knownIds[id];
			}
		}
	});
}
function isReferencedIdentifier(id, parent, parentStack) {
	if (!parent) return true;
	if (id.name === "arguments") return false;
	if (isReferenced(id, parent, parentStack[parentStack.length - 2])) return true;
	switch (parent.type) {
		case "AssignmentExpression":
		case "AssignmentPattern": return true;
		case "ObjectProperty": return parent.key !== id && isInDestructureAssignment(parent, parentStack);
		case "ArrayPattern": return isInDestructureAssignment(parent, parentStack);
	}
	return false;
}
function isInDestructureAssignment(parent, parentStack) {
	if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
		let i = parentStack.length;
		while (i--) {
			const p = parentStack[i];
			if (p.type === "AssignmentExpression") return true;
			else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) break;
		}
	}
	return false;
}
function isInNewExpression(parentStack) {
	let i = parentStack.length;
	while (i--) {
		const p = parentStack[i];
		if (p.type === "NewExpression") return true;
		else if (p.type !== "MemberExpression") break;
	}
	return false;
}
function walkFunctionParams(node, onIdent) {
	for (const p of node.params) for (const id of extractIdentifiers(p)) onIdent(id);
}
function walkBlockDeclarations(block, onIdent) {
	const body = block.type === "SwitchCase" ? block.consequent : block.body;
	for (const stmt of body) if (stmt.type === "VariableDeclaration") {
		if (stmt.declare) continue;
		for (const decl of stmt.declarations) for (const id of extractIdentifiers(decl.id)) onIdent(id);
	} else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
		if (stmt.declare || !stmt.id) continue;
		onIdent(stmt.id);
	} else if (isForStatement(stmt)) walkForStatement(stmt, true, onIdent);
	else if (stmt.type === "SwitchStatement") walkSwitchStatement(stmt, true, onIdent);
}
function isForStatement(stmt) {
	return stmt.type === "ForOfStatement" || stmt.type === "ForInStatement" || stmt.type === "ForStatement";
}
function walkForStatement(stmt, isVar, onIdent) {
	const variable = stmt.type === "ForStatement" ? stmt.init : stmt.left;
	if (variable && variable.type === "VariableDeclaration" && (variable.kind === "var" ? isVar : !isVar)) for (const decl of variable.declarations) for (const id of extractIdentifiers(decl.id)) onIdent(id);
}
function walkSwitchStatement(stmt, isVar, onIdent) {
	for (const cs of stmt.cases) {
		for (const stmt of cs.consequent) if (stmt.type === "VariableDeclaration" && (stmt.kind === "var" ? isVar : !isVar)) for (const decl of stmt.declarations) for (const id of extractIdentifiers(decl.id)) onIdent(id);
		walkBlockDeclarations(cs, onIdent);
	}
}
function extractIdentifiers(param, nodes = []) {
	switch (param.type) {
		case "Identifier":
			nodes.push(param);
			break;
		case "MemberExpression":
			let object = param;
			while (object.type === "MemberExpression") object = object.object;
			nodes.push(object);
			break;
		case "ObjectPattern":
			for (const prop of param.properties) if (prop.type === "RestElement") extractIdentifiers(prop.argument, nodes);
			else extractIdentifiers(prop.value, nodes);
			break;
		case "ArrayPattern":
			param.elements.forEach((element) => {
				if (element) extractIdentifiers(element, nodes);
			});
			break;
		case "RestElement":
			extractIdentifiers(param.argument, nodes);
			break;
		case "AssignmentPattern":
			extractIdentifiers(param.left, nodes);
			break;
	}
	return nodes;
}
function markKnownIds(name, knownIds) {
	if (name in knownIds) knownIds[name]++;
	else knownIds[name] = 1;
}
function markScopeIdentifier(node, child, knownIds) {
	const { name } = child;
	if (node.scopeIds && node.scopeIds.has(name)) return;
	markKnownIds(name, knownIds);
	(node.scopeIds || (node.scopeIds = /* @__PURE__ */ new Set())).add(name);
}
const isFunctionType = (node) => {
	return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
};
const isStaticProperty = (node) => !!node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
const isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
/**
* Copied from https://github.com/babel/babel/blob/main/packages/babel-types/src/validators/isReferenced.ts
* To avoid runtime dependency on @babel/types (which includes process references)
* This file should not change very often in babel but we may need to keep it
* up-to-date from time to time.
*
* https://github.com/babel/babel/blob/main/LICENSE
*
*/
function isReferenced(node, parent, grandparent) {
	switch (parent.type) {
		case "MemberExpression":
		case "OptionalMemberExpression":
			if (parent.property === node) return !!parent.computed;
			return parent.object === node;
		case "JSXMemberExpression": return parent.object === node;
		case "VariableDeclarator": return parent.init === node;
		case "ArrowFunctionExpression": return parent.body === node;
		case "PrivateName": return false;
		case "ClassMethod":
		case "ClassPrivateMethod":
		case "ObjectMethod":
			if (parent.key === node) return !!parent.computed;
			return false;
		case "ObjectProperty":
			if (parent.key === node) return !!parent.computed;
			return !grandparent || grandparent.type !== "ObjectPattern";
		case "ClassProperty":
			if (parent.key === node) return !!parent.computed;
			return true;
		case "ClassPrivateProperty": return parent.key !== node;
		case "ClassDeclaration":
		case "ClassExpression": return parent.superClass === node;
		case "AssignmentExpression": return parent.right === node;
		case "AssignmentPattern": return parent.right === node;
		case "LabeledStatement": return false;
		case "CatchClause": return false;
		case "RestElement": return false;
		case "BreakStatement":
		case "ContinueStatement": return false;
		case "FunctionDeclaration":
		case "FunctionExpression": return false;
		case "ExportNamespaceSpecifier":
		case "ExportDefaultSpecifier": return false;
		case "ExportSpecifier":
			if (grandparent === null || grandparent === void 0 ? void 0 : grandparent.source) return false;
			return parent.local === node;
		case "ImportDefaultSpecifier":
		case "ImportNamespaceSpecifier":
		case "ImportSpecifier": return false;
		case "ImportAttribute": return false;
		case "JSXAttribute": return false;
		case "ObjectPattern":
		case "ArrayPattern": return false;
		case "MetaProperty": return false;
		case "ObjectTypeProperty": return parent.key !== node;
		case "TSEnumMember": return parent.id !== node;
		case "TSPropertySignature":
			if (parent.key === node) return !!parent.computed;
			return true;
	}
	return true;
}
const TS_NODE_TYPES = [
	"TSAsExpression",
	"TSTypeAssertion",
	"TSNonNullExpression",
	"TSInstantiationExpression",
	"TSSatisfiesExpression"
];
function unwrapTSNode(node) {
	if (TS_NODE_TYPES.includes(node.type)) return unwrapTSNode(node.expression);
	else return node;
}
function isStaticNode(node) {
	node = unwrapTSNode(node);
	switch (node.type) {
		case "UnaryExpression": return isStaticNode(node.argument);
		case "LogicalExpression":
		case "BinaryExpression": return isStaticNode(node.left) && isStaticNode(node.right);
		case "ConditionalExpression": return isStaticNode(node.test) && isStaticNode(node.consequent) && isStaticNode(node.alternate);
		case "SequenceExpression":
		case "TemplateLiteral": return node.expressions.every((expr) => isStaticNode(expr));
		case "ParenthesizedExpression": return isStaticNode(node.expression);
		case "StringLiteral":
		case "NumericLiteral":
		case "BooleanLiteral":
		case "NullLiteral":
		case "BigIntLiteral": return true;
	}
	return false;
}
function isConstantNode(node, bindings) {
	if (isStaticNode(node)) return true;
	node = unwrapTSNode(node);
	switch (node.type) {
		case "Identifier": return bindings[node.name] === "literal-const";
		case "RegExpLiteral": return true;
		case "ObjectExpression": return node.properties.every((prop) => {
			if (prop.type === "ObjectMethod") return false;
			if (prop.type === "SpreadElement") return isConstantNode(prop.argument, bindings);
			return (!prop.computed || isConstantNode(prop.key, bindings)) && isConstantNode(prop.value, bindings);
		});
		case "ArrayExpression": return node.elements.every((element) => {
			if (element === null) return true;
			if (element.type === "SpreadElement") return isConstantNode(element.argument, bindings);
			return isConstantNode(element, bindings);
		});
	}
	return false;
}

//#endregion
//#region packages/compiler-core/src/utils.ts
const isStaticExp = (p) => p.type === 4 && p.isStatic;
function isCoreComponent(tag) {
	switch (tag) {
		case "Teleport":
		case "teleport": return TELEPORT;
		case "Suspense":
		case "suspense": return SUSPENSE;
		case "KeepAlive":
		case "keep-alive": return KEEP_ALIVE;
		case "BaseTransition":
		case "base-transition": return BASE_TRANSITION;
	}
}
const nonIdentifierRE = /^$|^\d|[^\$\w\xA0-\uFFFF]/;
const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
const MemberExpLexState = {
	"inMemberExp": 0,
	"0": "inMemberExp",
	"inBrackets": 1,
	"1": "inBrackets",
	"inParens": 2,
	"2": "inParens",
	"inString": 3,
	"3": "inString"
};
const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
const getExpSource = (exp) => exp.type === 4 ? exp.content : exp.loc.source;
/**
* Simple lexer to check if an expression is a member expression. This is
* lax and only checks validity at the root level (i.e. does not validate exps
* inside square brackets), but it's ok since these are only used on template
* expressions and false positives are invalid expressions in the first place.
*/
const isMemberExpressionBrowser = (exp) => {
	const path = getExpSource(exp).trim().replace(whitespaceRE, (s) => s.trim());
	let state = 0;
	let stateStack = [];
	let currentOpenBracketCount = 0;
	let currentOpenParensCount = 0;
	let currentStringType = null;
	for (let i = 0; i < path.length; i++) {
		const char = path.charAt(i);
		switch (state) {
			case 0:
				if (char === "[") {
					stateStack.push(state);
					state = 1;
					currentOpenBracketCount++;
				} else if (char === "(") {
					stateStack.push(state);
					state = 2;
					currentOpenParensCount++;
				} else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) return false;
				break;
			case 1:
				if (char === `'` || char === `"` || char === "`") {
					stateStack.push(state);
					state = 3;
					currentStringType = char;
				} else if (char === `[`) currentOpenBracketCount++;
				else if (char === `]`) {
					if (!--currentOpenBracketCount) state = stateStack.pop();
				}
				break;
			case 2:
				if (char === `'` || char === `"` || char === "`") {
					stateStack.push(state);
					state = 3;
					currentStringType = char;
				} else if (char === `(`) currentOpenParensCount++;
				else if (char === `)`) {
					if (i === path.length - 1) return false;
					if (!--currentOpenParensCount) state = stateStack.pop();
				}
				break;
			case 3:
				if (char === currentStringType) {
					state = stateStack.pop();
					currentStringType = null;
				}
				break;
		}
	}
	return !currentOpenBracketCount && !currentOpenParensCount;
};
const isMemberExpressionNode = (exp, context) => {
	try {
		let ret = exp.ast || (0, _babel_parser.parseExpression)(getExpSource(exp), { plugins: context.expressionPlugins ? [...context.expressionPlugins, "typescript"] : ["typescript"] });
		ret = unwrapTSNode(ret);
		return ret.type === "MemberExpression" || ret.type === "OptionalMemberExpression" || ret.type === "Identifier" && ret.name !== "undefined";
	} catch (e) {
		return false;
	}
};
const isMemberExpression = isMemberExpressionNode;
const fnExpRE = /^\s*(?:async\s*)?(?:\([^)]*?\)|[\w$_]+)\s*(?::[^=]+)?=>|^\s*(?:async\s+)?function(?:\s+[\w$]+)?\s*\(/;
const isFnExpressionBrowser = (exp) => fnExpRE.test(getExpSource(exp));
const isFnExpressionNode = (exp, context) => {
	try {
		let ret = exp.ast || (0, _babel_parser.parseExpression)(getExpSource(exp), { plugins: context.expressionPlugins ? [...context.expressionPlugins, "typescript"] : ["typescript"] });
		if (ret.type === "Program") {
			ret = ret.body[0];
			if (ret.type === "ExpressionStatement") ret = ret.expression;
		}
		ret = unwrapTSNode(ret);
		return ret.type === "FunctionExpression" || ret.type === "ArrowFunctionExpression";
	} catch (e) {
		return false;
	}
};
const isFnExpression = isFnExpressionNode;
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
	return advancePositionWithMutation({
		offset: pos.offset,
		line: pos.line,
		column: pos.column
	}, source, numberOfCharacters);
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
	let linesCount = 0;
	let lastNewLinePos = -1;
	for (let i = 0; i < numberOfCharacters; i++) if (source.charCodeAt(i) === 10) {
		linesCount++;
		lastNewLinePos = i;
	}
	pos.offset += numberOfCharacters;
	pos.line += linesCount;
	pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
	return pos;
}
function assert(condition, msg) {
	/* v8 ignore next 3 */
	if (!condition) throw new Error(msg || `unexpected compiler condition`);
}
/** find directive */
function findDir(node, name, allowEmpty = false) {
	for (let i = 0; i < node.props.length; i++) {
		const p = node.props[i];
		if (p.type === 7 && (allowEmpty || p.exp) && ((0, _vue_shared.isString)(name) ? p.name === name : name.test(p.name))) return p;
	}
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
	for (let i = 0; i < node.props.length; i++) {
		const p = node.props[i];
		if (p.type === 6) {
			if (dynamicOnly) continue;
			if (p.name === name && (p.value || allowEmpty)) return p;
		} else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) return p;
	}
}
function isStaticArgOf(arg, name) {
	return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
	return node.props.some((p) => p.type === 7 && p.name === "bind" && (!p.arg || p.arg.type !== 4 || !p.arg.isStatic));
}
function isText(node) {
	return node.type === 5 || node.type === 2;
}
function isVPre(p) {
	return p.type === 7 && p.name === "pre";
}
function isVSlot(p) {
	return p.type === 7 && p.name === "slot";
}
function isTemplateNode(node) {
	return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
	return node.type === 1 && node.tagType === 2;
}
const propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props, callPath = []) {
	if (props && !(0, _vue_shared.isString)(props) && props.type === 14) {
		const callee = props.callee;
		if (!(0, _vue_shared.isString)(callee) && propsHelperSet.has(callee)) return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
	}
	return [props, callPath];
}
function injectProp(node, prop, context) {
	let propsWithInjection;
	/**
	* 1. mergeProps(...)
	* 2. toHandlers(...)
	* 3. normalizeProps(...)
	* 4. normalizeProps(guardReactiveProps(...))
	*
	* we need to get the real props before normalization
	*/
	let props = node.type === 13 ? node.props : node.arguments[2];
	let callPath = [];
	let parentCall;
	if (props && !(0, _vue_shared.isString)(props) && props.type === 14) {
		const ret = getUnnormalizedProps(props);
		props = ret[0];
		callPath = ret[1];
		parentCall = callPath[callPath.length - 1];
	}
	if (props == null || (0, _vue_shared.isString)(props)) propsWithInjection = createObjectExpression([prop]);
	else if (props.type === 14) {
		const first = props.arguments[0];
		if (!(0, _vue_shared.isString)(first) && first.type === 15) {
			if (!hasProp(prop, first)) first.properties.unshift(prop);
		} else if (props.callee === TO_HANDLERS) propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [createObjectExpression([prop]), props]);
		else props.arguments.unshift(createObjectExpression([prop]));
		!propsWithInjection && (propsWithInjection = props);
	} else if (props.type === 15) {
		if (!hasProp(prop, props)) props.properties.unshift(prop);
		propsWithInjection = props;
	} else {
		propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [createObjectExpression([prop]), props]);
		if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) parentCall = callPath[callPath.length - 2];
	}
	if (node.type === 13) if (parentCall) parentCall.arguments[0] = propsWithInjection;
	else node.props = propsWithInjection;
	else if (parentCall) parentCall.arguments[0] = propsWithInjection;
	else node.arguments[2] = propsWithInjection;
}
function hasProp(prop, props) {
	let result = false;
	if (prop.key.type === 4) {
		const propKeyName = prop.key.content;
		result = props.properties.some((p) => p.key.type === 4 && p.key.content === propKeyName);
	}
	return result;
}
function toValidAssetId(name, type) {
	return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
		return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
	})}`;
}
function hasScopeRef(node, ids) {
	if (!node || Object.keys(ids).length === 0) return false;
	switch (node.type) {
		case 1:
			for (let i = 0; i < node.props.length; i++) {
				const p = node.props[i];
				if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) return true;
			}
			return node.children.some((c) => hasScopeRef(c, ids));
		case 11:
			if (hasScopeRef(node.source, ids)) return true;
			return node.children.some((c) => hasScopeRef(c, ids));
		case 9: return node.branches.some((b) => hasScopeRef(b, ids));
		case 10:
			if (hasScopeRef(node.condition, ids)) return true;
			return node.children.some((c) => hasScopeRef(c, ids));
		case 4: return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
		case 8: return node.children.some((c) => (0, _vue_shared.isObject)(c) && hasScopeRef(c, ids));
		case 5:
		case 12: return hasScopeRef(node.content, ids);
		case 2:
		case 3:
		case 20: return false;
		default: return false;
	}
}
function getMemoedVNodeCall(node) {
	if (node.type === 14 && node.callee === WITH_MEMO) return node.arguments[1].returns;
	else return node;
}
function filterNonCommentChildren(node) {
	return node.children.filter((n) => !isCommentOrWhitespace(n));
}
function hasSingleChild(node) {
	return filterNonCommentChildren(node).length === 1;
}
function isSingleIfBlock(parent) {
	let hasEncounteredIf = false;
	for (const c of filterNonCommentChildren(parent)) if (c.type === 9 || c.type === 1 && findDir(c, "if")) {
		if (hasEncounteredIf) return false;
		hasEncounteredIf = true;
	} else if (!hasEncounteredIf || !(c.type === 1 && findDir(c, /^else(-if)?$/, true))) return false;
	return true;
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;
function isAllWhitespace(str) {
	for (let i = 0; i < str.length; i++) if (!isWhitespace(str.charCodeAt(i))) return false;
	return true;
}
function isWhitespaceText(node) {
	return node.type === 2 && isAllWhitespace(node.content) || node.type === 12 && isWhitespaceText(node.content);
}
function isCommentOrWhitespace(node) {
	return node.type === 3 || isWhitespaceText(node);
}

//#endregion
//#region packages/compiler-core/src/parser.ts
const defaultParserOptions = {
	parseMode: "base",
	ns: 0,
	delimiters: [`{{`, `}}`],
	getNamespace: () => 0,
	isVoidTag: _vue_shared.NO,
	isPreTag: _vue_shared.NO,
	isIgnoreNewlineTag: _vue_shared.NO,
	isCustomElement: _vue_shared.NO,
	onError: defaultOnError,
	onWarn: defaultOnWarn,
	comments: false,
	prefixIdentifiers: false
};
let currentOptions = defaultParserOptions;
let currentRoot = null;
let currentInput = "";
let currentOpenTag = null;
let currentProp = null;
let currentAttrValue = "";
let currentAttrStartIndex = -1;
let currentAttrEndIndex = -1;
let inPre = 0;
let inVPre = false;
let currentVPreBoundary = null;
const stack = [];
const tokenizer = new Tokenizer(stack, {
	onerr: emitError,
	ontext(start, end) {
		onText(getSlice(start, end), start, end);
	},
	ontextentity(char, start, end) {
		onText(char, start, end);
	},
	oninterpolation(start, end) {
		if (inVPre) return onText(getSlice(start, end), start, end);
		let innerStart = start + tokenizer.delimiterOpen.length;
		let innerEnd = end - tokenizer.delimiterClose.length;
		while (isWhitespace(currentInput.charCodeAt(innerStart))) innerStart++;
		while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) innerEnd--;
		let exp = getSlice(innerStart, innerEnd);
		if (exp.includes("&")) exp = decodeHTML(exp);
		addNode({
			type: 5,
			content: createExp(exp, false, getLoc(innerStart, innerEnd)),
			loc: getLoc(start, end)
		});
	},
	onopentagname(start, end) {
		const name = getSlice(start, end);
		currentOpenTag = {
			type: 1,
			tag: name,
			ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),
			tagType: 0,
			props: [],
			children: [],
			loc: getLoc(start - 1, end),
			codegenNode: void 0
		};
	},
	onopentagend(end) {
		endOpenTag(end);
	},
	onclosetag(start, end) {
		const name = getSlice(start, end);
		if (!currentOptions.isVoidTag(name)) {
			let found = false;
			for (let i = 0; i < stack.length; i++) if (stack[i].tag.toLowerCase() === name.toLowerCase()) {
				found = true;
				if (i > 0) emitError(24, stack[0].loc.start.offset);
				for (let j = 0; j <= i; j++) onCloseTag(stack.shift(), end, j < i);
				break;
			}
			if (!found) emitError(23, backTrack(start, 60));
		}
	},
	onselfclosingtag(end) {
		const name = currentOpenTag.tag;
		currentOpenTag.isSelfClosing = true;
		endOpenTag(end);
		if (stack[0] && stack[0].tag === name) onCloseTag(stack.shift(), end);
	},
	onattribname(start, end) {
		currentProp = {
			type: 6,
			name: getSlice(start, end),
			nameLoc: getLoc(start, end),
			value: void 0,
			loc: getLoc(start)
		};
	},
	ondirname(start, end) {
		const raw = getSlice(start, end);
		const name = raw === "." || raw === ":" ? "bind" : raw === "@" ? "on" : raw === "#" ? "slot" : raw.slice(2);
		if (!inVPre && name === "") emitError(26, start);
		if (inVPre || name === "") currentProp = {
			type: 6,
			name: raw,
			nameLoc: getLoc(start, end),
			value: void 0,
			loc: getLoc(start)
		};
		else {
			currentProp = {
				type: 7,
				name,
				rawName: raw,
				exp: void 0,
				arg: void 0,
				modifiers: raw === "." ? [createSimpleExpression("prop")] : [],
				loc: getLoc(start)
			};
			if (name === "pre") {
				inVPre = tokenizer.inVPre = true;
				currentVPreBoundary = currentOpenTag;
				const props = currentOpenTag.props;
				for (let i = 0; i < props.length; i++) if (props[i].type === 7) props[i] = dirToAttr(props[i]);
			}
		}
	},
	ondirarg(start, end) {
		if (start === end) return;
		const arg = getSlice(start, end);
		if (inVPre && !isVPre(currentProp)) {
			currentProp.name += arg;
			setLocEnd(currentProp.nameLoc, end);
		} else {
			const isStatic = arg[0] !== `[`;
			currentProp.arg = createExp(isStatic ? arg : arg.slice(1, -1), isStatic, getLoc(start, end), isStatic ? 3 : 0);
		}
	},
	ondirmodifier(start, end) {
		const mod = getSlice(start, end);
		if (inVPre && !isVPre(currentProp)) {
			currentProp.name += "." + mod;
			setLocEnd(currentProp.nameLoc, end);
		} else if (currentProp.name === "slot") {
			const arg = currentProp.arg;
			if (arg) {
				arg.content += "." + mod;
				setLocEnd(arg.loc, end);
			}
		} else {
			const exp = createSimpleExpression(mod, true, getLoc(start, end));
			currentProp.modifiers.push(exp);
		}
	},
	onattribdata(start, end) {
		currentAttrValue += getSlice(start, end);
		if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
		currentAttrEndIndex = end;
	},
	onattribentity(char, start, end) {
		currentAttrValue += char;
		if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
		currentAttrEndIndex = end;
	},
	onattribnameend(end) {
		const start = currentProp.loc.start.offset;
		const name = getSlice(start, end);
		if (currentProp.type === 7) currentProp.rawName = name;
		if (currentOpenTag.props.some((p) => (p.type === 7 ? p.rawName : p.name) === name)) emitError(2, start);
	},
	onattribend(quote, end) {
		if (currentOpenTag && currentProp) {
			setLocEnd(currentProp.loc, end);
			if (quote !== 0) if (currentProp.type === 6) {
				if (currentProp.name === "class") currentAttrValue = condense(currentAttrValue).trim();
				if (quote === 1 && !currentAttrValue) emitError(13, end);
				currentProp.value = {
					type: 2,
					content: currentAttrValue,
					loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
				};
				if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
			} else {
				let expParseMode = 0;
				if (currentProp.name === "for") expParseMode = 3;
				else if (currentProp.name === "slot") expParseMode = 1;
				else if (currentProp.name === "on" && currentAttrValue.includes(";")) expParseMode = 2;
				currentProp.exp = createExp(currentAttrValue, false, getLoc(currentAttrStartIndex, currentAttrEndIndex), 0, expParseMode);
				if (currentProp.name === "for") currentProp.forParseResult = parseForExpression(currentProp.exp);
				let syncIndex = -1;
				if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.findIndex((mod) => mod.content === "sync")) > -1 && checkCompatEnabled("COMPILER_V_BIND_SYNC", currentOptions, currentProp.loc, currentProp.arg.loc.source)) {
					currentProp.name = "model";
					currentProp.modifiers.splice(syncIndex, 1);
				}
			}
			if (currentProp.type !== 7 || currentProp.name !== "pre") currentOpenTag.props.push(currentProp);
		}
		currentAttrValue = "";
		currentAttrStartIndex = currentAttrEndIndex = -1;
	},
	oncomment(start, end) {
		if (currentOptions.comments) addNode({
			type: 3,
			content: getSlice(start, end),
			loc: getLoc(start - 4, end + 3)
		});
	},
	onend() {
		const end = currentInput.length;
		if (tokenizer.state !== 1) switch (tokenizer.state) {
			case 5:
			case 8:
				emitError(5, end);
				break;
			case 3:
			case 4:
				emitError(25, tokenizer.sectionStart);
				break;
			case 28:
				if (tokenizer.currentSequence === Sequences.CdataEnd) emitError(6, end);
				else emitError(7, end);
				break;
			case 6:
			case 7:
			case 9:
			case 11:
			case 12:
			case 13:
			case 14:
			case 15:
			case 16:
			case 17:
			case 18:
			case 19:
			case 20:
			case 21:
				emitError(9, end);
				break;
			default: break;
		}
		for (let index = 0; index < stack.length; index++) {
			onCloseTag(stack[index], end - 1);
			emitError(24, stack[index].loc.start.offset);
		}
	},
	oncdata(start, end) {
		if (stack[0].ns !== 0) onText(getSlice(start, end), start, end);
		else emitError(1, start - 9);
	},
	onprocessinginstruction(start) {
		if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) emitError(21, start - 1);
	}
});
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input) {
	const loc = input.loc;
	const exp = input.content;
	const inMatch = exp.match(forAliasRE);
	if (!inMatch) return;
	const [, LHS, RHS] = inMatch;
	const createAliasExpression = (content, offset, asParam = false) => {
		const start = loc.start.offset + offset;
		return createExp(content, false, getLoc(start, start + content.length), 0, asParam ? 1 : 0);
	};
	const result = {
		source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
		value: void 0,
		key: void 0,
		index: void 0,
		finalized: false
	};
	let valueContent = LHS.trim().replace(stripParensRE, "").trim();
	const trimmedOffset = LHS.indexOf(valueContent);
	const iteratorMatch = valueContent.match(forIteratorRE);
	if (iteratorMatch) {
		valueContent = valueContent.replace(forIteratorRE, "").trim();
		const keyContent = iteratorMatch[1].trim();
		let keyOffset;
		if (keyContent) {
			keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
			result.key = createAliasExpression(keyContent, keyOffset, true);
		}
		if (iteratorMatch[2]) {
			const indexContent = iteratorMatch[2].trim();
			if (indexContent) result.index = createAliasExpression(indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length), true);
		}
	}
	if (valueContent) result.value = createAliasExpression(valueContent, trimmedOffset, true);
	return result;
}
function getSlice(start, end) {
	return currentInput.slice(start, end);
}
function endOpenTag(end) {
	if (tokenizer.inSFCRoot) currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
	addNode(currentOpenTag);
	const { tag, ns } = currentOpenTag;
	if (ns === 0 && currentOptions.isPreTag(tag)) inPre++;
	if (currentOptions.isVoidTag(tag)) onCloseTag(currentOpenTag, end);
	else {
		stack.unshift(currentOpenTag);
		if (ns === 1 || ns === 2) tokenizer.inXML = true;
	}
	currentOpenTag = null;
}
function onText(content, start, end) {
	const parent = stack[0] || currentRoot;
	const lastNode = parent.children[parent.children.length - 1];
	if (lastNode && lastNode.type === 2) {
		lastNode.content += content;
		setLocEnd(lastNode.loc, end);
	} else parent.children.push({
		type: 2,
		content,
		loc: getLoc(start, end)
	});
}
function onCloseTag(el, end, isImplied = false) {
	if (isImplied) setLocEnd(el.loc, backTrack(end, 60));
	else setLocEnd(el.loc, lookAhead(end, 62) + 1);
	if (tokenizer.inSFCRoot) {
		if (el.children.length) el.innerLoc.end = (0, _vue_shared.extend)({}, el.children[el.children.length - 1].loc.end);
		else el.innerLoc.end = (0, _vue_shared.extend)({}, el.innerLoc.start);
		el.innerLoc.source = getSlice(el.innerLoc.start.offset, el.innerLoc.end.offset);
	}
	const { tag, ns, children } = el;
	if (!inVPre) {
		if (tag === "slot") el.tagType = 2;
		else if (isFragmentTemplate(el)) el.tagType = 3;
		else if (isComponent(el)) el.tagType = 1;
	}
	if (!tokenizer.inRCDATA) el.children = condenseWhitespace(children);
	if (ns === 0 && currentOptions.isIgnoreNewlineTag(tag)) {
		const first = children[0];
		if (first && first.type === 2) first.content = first.content.replace(/^\r?\n/, "");
	}
	if (ns === 0 && currentOptions.isPreTag(tag)) inPre--;
	if (currentVPreBoundary === el) {
		inVPre = tokenizer.inVPre = false;
		currentVPreBoundary = null;
	}
	if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) tokenizer.inXML = false;
	{
		const props = el.props;
		if (!tokenizer.inSFCRoot && isCompatEnabled("COMPILER_NATIVE_TEMPLATE", currentOptions) && el.tag === "template" && !isFragmentTemplate(el)) {
			const parent = stack[0] || currentRoot;
			const index = parent.children.indexOf(el);
			parent.children.splice(index, 1, ...el.children);
		}
		const inlineTemplateProp = props.find((p) => p.type === 6 && p.name === "inline-template");
		if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", currentOptions, inlineTemplateProp.loc) && el.children.length) inlineTemplateProp.value = {
			type: 2,
			content: getSlice(el.children[0].loc.start.offset, el.children[el.children.length - 1].loc.end.offset),
			loc: inlineTemplateProp.loc
		};
	}
}
function lookAhead(index, c) {
	let i = index;
	while (currentInput.charCodeAt(i) !== c && i < currentInput.length - 1) i++;
	return i;
}
function backTrack(index, c) {
	let i = index;
	while (currentInput.charCodeAt(i) !== c && i >= 0) i--;
	return i;
}
const specialTemplateDir = new Set([
	"if",
	"else",
	"else-if",
	"for",
	"slot"
]);
function isFragmentTemplate({ tag, props }) {
	if (tag === "template") {
		for (let i = 0; i < props.length; i++) if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) return true;
	}
	return false;
}
function isComponent({ tag, props }) {
	if (currentOptions.isCustomElement(tag)) return false;
	if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) return true;
	for (let i = 0; i < props.length; i++) {
		const p = props[i];
		if (p.type === 6) {
			if (p.name === "is" && p.value) {
				if (p.value.content.startsWith("vue:")) return true;
				else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", currentOptions, p.loc)) return true;
			}
		} else if (p.name === "bind" && isStaticArgOf(p.arg, "is") && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", currentOptions, p.loc)) return true;
	}
	return false;
}
function isUpperCase(c) {
	return c > 64 && c < 91;
}
const windowsNewlineRE = /\r\n/g;
function condenseWhitespace(nodes) {
	const shouldCondense = currentOptions.whitespace !== "preserve";
	let removedWhitespace = false;
	for (let i = 0; i < nodes.length; i++) {
		const node = nodes[i];
		if (node.type === 2) if (!inPre) {
			if (isAllWhitespace(node.content)) {
				const prev = nodes[i - 1] && nodes[i - 1].type;
				const next = nodes[i + 1] && nodes[i + 1].type;
				if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
					removedWhitespace = true;
					nodes[i] = null;
				} else node.content = " ";
			} else if (shouldCondense) node.content = condense(node.content);
		} else node.content = node.content.replace(windowsNewlineRE, "\n");
	}
	return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function hasNewlineChar(str) {
	for (let i = 0; i < str.length; i++) {
		const c = str.charCodeAt(i);
		if (c === 10 || c === 13) return true;
	}
	return false;
}
function condense(str) {
	let ret = "";
	let prevCharIsWhitespace = false;
	for (let i = 0; i < str.length; i++) if (isWhitespace(str.charCodeAt(i))) {
		if (!prevCharIsWhitespace) {
			ret += " ";
			prevCharIsWhitespace = true;
		}
	} else {
		ret += str[i];
		prevCharIsWhitespace = false;
	}
	return ret;
}
function addNode(node) {
	(stack[0] || currentRoot).children.push(node);
}
function getLoc(start, end) {
	return {
		start: tokenizer.getPos(start),
		end: end == null ? end : tokenizer.getPos(end),
		source: end == null ? end : getSlice(start, end)
	};
}
function cloneLoc(loc) {
	return getLoc(loc.start.offset, loc.end.offset);
}
function setLocEnd(loc, end) {
	loc.end = tokenizer.getPos(end);
	loc.source = getSlice(loc.start.offset, end);
}
function dirToAttr(dir) {
	const attr = {
		type: 6,
		name: dir.rawName,
		nameLoc: getLoc(dir.loc.start.offset, dir.loc.start.offset + dir.rawName.length),
		value: void 0,
		loc: dir.loc
	};
	if (dir.exp) {
		const loc = dir.exp.loc;
		if (loc.end.offset < dir.loc.end.offset) {
			loc.start.offset--;
			loc.start.column--;
			loc.end.offset++;
			loc.end.column++;
		}
		attr.value = {
			type: 2,
			content: dir.exp.content,
			loc
		};
	}
	return attr;
}
function createExp(content, isStatic = false, loc, constType = 0, parseMode = 0) {
	const exp = createSimpleExpression(content, isStatic, loc, constType);
	if (!isStatic && currentOptions.prefixIdentifiers && parseMode !== 3 && content.trim()) {
		if (isSimpleIdentifier(content)) {
			exp.ast = null;
			return exp;
		}
		try {
			const plugins = currentOptions.expressionPlugins;
			const options = { plugins: plugins ? [...plugins, "typescript"] : ["typescript"] };
			if (parseMode === 2) exp.ast = (0, _babel_parser.parse)(` ${content} `, options).program;
			else if (parseMode === 1) exp.ast = (0, _babel_parser.parseExpression)(`(${content})=>{}`, options);
			else exp.ast = (0, _babel_parser.parseExpression)(`(${content})`, options);
		} catch (e) {
			exp.ast = false;
			emitError(46, loc.start.offset, e.message);
		}
	}
	return exp;
}
function emitError(code, index, message) {
	currentOptions.onError(createCompilerError(code, getLoc(index, index), void 0, message));
}
function reset() {
	tokenizer.reset();
	currentOpenTag = null;
	currentProp = null;
	currentAttrValue = "";
	currentAttrStartIndex = -1;
	currentAttrEndIndex = -1;
	stack.length = 0;
}
function baseParse(input, options) {
	reset();
	currentInput = input;
	currentOptions = (0, _vue_shared.extend)({}, defaultParserOptions);
	if (options) {
		let key;
		for (key in options) if (options[key] != null) currentOptions[key] = options[key];
	}
	tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
	tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
	const delimiters = options && options.delimiters;
	if (delimiters) {
		tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
		tokenizer.delimiterClose = toCharCodes(delimiters[1]);
	}
	const root = currentRoot = createRoot([], input);
	tokenizer.parse(currentInput);
	root.loc = getLoc(0, input.length);
	root.children = condenseWhitespace(root.children);
	currentRoot = null;
	return root;
}

//#endregion
//#region packages/compiler-core/src/transforms/cacheStatic.ts
function cacheStatic(root, context) {
	walk(root, void 0, context, !!getSingleElementRoot(root));
}
function getSingleElementRoot(root) {
	const children = root.children.filter((x) => x.type !== 3);
	return children.length === 1 && children[0].type === 1 && !isSlotOutlet(children[0]) ? children[0] : null;
}
function walk(node, parent, context, doNotHoistNode = false, inFor = false) {
	const { children } = node;
	const toCache = [];
	for (let i = 0; i < children.length; i++) {
		const child = children[i];
		if (child.type === 1 && child.tagType === 0) {
			const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
			if (constantType > 0) {
				if (constantType >= 2) {
					child.codegenNode.patchFlag = -1;
					toCache.push(child);
					continue;
				}
			} else {
				const codegenNode = child.codegenNode;
				if (codegenNode.type === 13) {
					const flag = codegenNode.patchFlag;
					if ((flag === void 0 || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
						const props = getNodeProps(child);
						if (props) codegenNode.props = context.hoist(props);
					}
					if (codegenNode.dynamicProps) codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
				}
			}
		} else if (child.type === 12) {
			if ((doNotHoistNode ? 0 : getConstantType(child, context)) >= 2) {
				if (child.codegenNode.type === 14 && child.codegenNode.arguments.length > 0) child.codegenNode.arguments.push("-1");
				toCache.push(child);
				continue;
			}
		}
		if (child.type === 1) {
			const isComponent = child.tagType === 1;
			if (isComponent) context.scopes.vSlot++;
			walk(child, node, context, false, inFor);
			if (isComponent) context.scopes.vSlot--;
		} else if (child.type === 11) walk(child, node, context, child.children.length === 1, true);
		else if (child.type === 9) for (let i = 0; i < child.branches.length; i++) walk(child.branches[i], node, context, child.branches[i].children.length === 1, inFor);
	}
	let cachedAsArray = false;
	if (toCache.length === children.length && node.type === 1) {
		if (node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && (0, _vue_shared.isArray)(node.codegenNode.children)) {
			node.codegenNode.children = getCacheExpression(createArrayExpression(node.codegenNode.children));
			cachedAsArray = true;
		} else if (node.tagType === 1 && node.codegenNode && node.codegenNode.type === 13 && node.codegenNode.children && !(0, _vue_shared.isArray)(node.codegenNode.children) && node.codegenNode.children.type === 15) {
			const slot = getSlotNode(node.codegenNode, "default");
			if (slot) {
				slot.returns = getCacheExpression(createArrayExpression(slot.returns));
				cachedAsArray = true;
			}
		} else if (node.tagType === 3 && parent && parent.type === 1 && parent.tagType === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !(0, _vue_shared.isArray)(parent.codegenNode.children) && parent.codegenNode.children.type === 15) {
			const slotName = findDir(node, "slot", true);
			const slot = slotName && slotName.arg && getSlotNode(parent.codegenNode, slotName.arg);
			if (slot) {
				slot.returns = getCacheExpression(createArrayExpression(slot.returns));
				cachedAsArray = true;
			}
		}
	}
	if (!cachedAsArray) for (const child of toCache) child.codegenNode = context.cache(child.codegenNode);
	function getCacheExpression(value) {
		const exp = context.cache(value);
		exp.needArraySpread = true;
		return exp;
	}
	function getSlotNode(node, name) {
		if (node.children && !(0, _vue_shared.isArray)(node.children) && node.children.type === 15) {
			const slot = node.children.properties.find((p) => p.key === name || p.key.content === name);
			return slot && slot.value;
		}
	}
	if (toCache.length && context.transformHoist) context.transformHoist(children, context, node);
}
function getConstantType(node, context) {
	const { constantCache } = context;
	switch (node.type) {
		case 1:
			if (node.tagType !== 0) return 0;
			const cached = constantCache.get(node);
			if (cached !== void 0) return cached;
			const codegenNode = node.codegenNode;
			if (codegenNode.type !== 13) return 0;
			if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject" && node.tag !== "math") return 0;
			if (codegenNode.patchFlag === void 0) {
				let returnType = 3;
				const generatedPropsType = getGeneratedPropsConstantType(node, context);
				if (generatedPropsType === 0) {
					constantCache.set(node, 0);
					return 0;
				}
				if (generatedPropsType < returnType) returnType = generatedPropsType;
				for (let i = 0; i < node.children.length; i++) {
					const childType = getConstantType(node.children[i], context);
					if (childType === 0) {
						constantCache.set(node, 0);
						return 0;
					}
					if (childType < returnType) returnType = childType;
				}
				if (returnType > 1) for (let i = 0; i < node.props.length; i++) {
					const p = node.props[i];
					if (p.type === 7 && p.name === "bind" && p.exp) {
						const expType = getConstantType(p.exp, context);
						if (expType === 0) {
							constantCache.set(node, 0);
							return 0;
						}
						if (expType < returnType) returnType = expType;
					}
				}
				if (codegenNode.isBlock) {
					for (let i = 0; i < node.props.length; i++) if (node.props[i].type === 7) {
						constantCache.set(node, 0);
						return 0;
					}
					context.removeHelper(OPEN_BLOCK);
					context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
					codegenNode.isBlock = false;
					context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
				}
				constantCache.set(node, returnType);
				return returnType;
			} else {
				constantCache.set(node, 0);
				return 0;
			}
		case 2:
		case 3: return 3;
		case 9:
		case 11:
		case 10: return 0;
		case 5:
		case 12: return getConstantType(node.content, context);
		case 4: return node.constType;
		case 8:
			let returnType = 3;
			for (let i = 0; i < node.children.length; i++) {
				const child = node.children[i];
				if ((0, _vue_shared.isString)(child) || (0, _vue_shared.isSymbol)(child)) continue;
				const childType = getConstantType(child, context);
				if (childType === 0) return 0;
				else if (childType < returnType) returnType = childType;
			}
			return returnType;
		case 20: return 2;
		default: return 0;
	}
}
const allowHoistedHelperSet = new Set([
	NORMALIZE_CLASS,
	NORMALIZE_STYLE,
	NORMALIZE_PROPS,
	GUARD_REACTIVE_PROPS
]);
function getConstantTypeOfHelperCall(value, context) {
	if (value.type === 14 && !(0, _vue_shared.isString)(value.callee) && allowHoistedHelperSet.has(value.callee)) {
		const arg = value.arguments[0];
		if (arg.type === 4) return getConstantType(arg, context);
		else if (arg.type === 14) return getConstantTypeOfHelperCall(arg, context);
	}
	return 0;
}
function getGeneratedPropsConstantType(node, context) {
	let returnType = 3;
	const props = getNodeProps(node);
	if (props && props.type === 15) {
		const { properties } = props;
		for (let i = 0; i < properties.length; i++) {
			const { key, value } = properties[i];
			const keyType = getConstantType(key, context);
			if (keyType === 0) return keyType;
			if (keyType < returnType) returnType = keyType;
			let valueType;
			if (value.type === 4) valueType = getConstantType(value, context);
			else if (value.type === 14) valueType = getConstantTypeOfHelperCall(value, context);
			else valueType = 0;
			if (valueType === 0) return valueType;
			if (valueType < returnType) returnType = valueType;
		}
	}
	return returnType;
}
function getNodeProps(node) {
	const codegenNode = node.codegenNode;
	if (codegenNode.type === 13) return codegenNode.props;
}

//#endregion
//#region packages/compiler-core/src/transform.ts
function getSelfName(filename) {
	const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
	return nameMatch ? (0, _vue_shared.capitalize)((0, _vue_shared.camelize)(nameMatch[1])) : null;
}
function createTransformContext(root, { filename = "", prefixIdentifiers = false, hoistStatic = false, hmr = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = _vue_shared.NOOP, isCustomElement = _vue_shared.NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = _vue_shared.EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
	const context = {
		filename,
		selfName: getSelfName(filename),
		prefixIdentifiers,
		hoistStatic,
		hmr,
		cacheHandlers,
		nodeTransforms,
		directiveTransforms,
		transformHoist,
		isBuiltInComponent,
		isCustomElement,
		expressionPlugins,
		scopeId,
		slotted,
		ssr,
		inSSR,
		ssrCssVars,
		bindingMetadata,
		inline,
		isTS,
		onError,
		onWarn,
		compatConfig,
		root,
		helpers: /* @__PURE__ */ new Map(),
		components: /* @__PURE__ */ new Set(),
		directives: /* @__PURE__ */ new Set(),
		hoists: [],
		imports: [],
		cached: [],
		constantCache: /* @__PURE__ */ new WeakMap(),
		temps: 0,
		identifiers: Object.create(null),
		scopes: {
			vFor: 0,
			vSlot: 0,
			vPre: 0,
			vOnce: 0
		},
		parent: null,
		grandParent: null,
		currentNode: root,
		childIndex: 0,
		inVOnce: false,
		helper(name) {
			const count = context.helpers.get(name) || 0;
			context.helpers.set(name, count + 1);
			return name;
		},
		removeHelper(name) {
			const count = context.helpers.get(name);
			if (count) {
				const currentCount = count - 1;
				if (!currentCount) context.helpers.delete(name);
				else context.helpers.set(name, currentCount);
			}
		},
		helperString(name) {
			return `_${helperNameMap[context.helper(name)]}`;
		},
		replaceNode(node) {
			/* v8 ignore stop */
			context.parent.children[context.childIndex] = context.currentNode = node;
		},
		removeNode(node) {
			const list = context.parent.children;
			const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
			if (!node || node === context.currentNode) {
				context.currentNode = null;
				context.onNodeRemoved();
			} else if (context.childIndex > removalIndex) {
				context.childIndex--;
				context.onNodeRemoved();
			}
			context.parent.children.splice(removalIndex, 1);
		},
		onNodeRemoved: _vue_shared.NOOP,
		addIdentifiers(exp) {
			if ((0, _vue_shared.isString)(exp)) addId(exp);
			else if (exp.identifiers) exp.identifiers.forEach(addId);
			else if (exp.type === 4) addId(exp.content);
		},
		removeIdentifiers(exp) {
			if ((0, _vue_shared.isString)(exp)) removeId(exp);
			else if (exp.identifiers) exp.identifiers.forEach(removeId);
			else if (exp.type === 4) removeId(exp.content);
		},
		hoist(exp) {
			if ((0, _vue_shared.isString)(exp)) exp = createSimpleExpression(exp);
			context.hoists.push(exp);
			const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2);
			identifier.hoisted = exp;
			return identifier;
		},
		cache(exp, isVNode = false, inVOnce = false) {
			const cacheExp = createCacheExpression(context.cached.length, exp, isVNode, inVOnce);
			context.cached.push(cacheExp);
			return cacheExp;
		}
	};
	context.filters = /* @__PURE__ */ new Set();
	function addId(id) {
		const { identifiers } = context;
		if (identifiers[id] === void 0) identifiers[id] = 0;
		identifiers[id]++;
	}
	function removeId(id) {
		context.identifiers[id]--;
	}
	return context;
}
function transform(root, options) {
	const context = createTransformContext(root, options);
	traverseNode(root, context);
	if (options.hoistStatic) cacheStatic(root, context);
	if (!options.ssr) createRootCodegen(root, context);
	root.helpers = new Set([...context.helpers.keys()]);
	root.components = [...context.components];
	root.directives = [...context.directives];
	root.imports = context.imports;
	root.hoists = context.hoists;
	root.temps = context.temps;
	root.cached = context.cached;
	root.transformed = true;
	root.filters = [...context.filters];
}
function createRootCodegen(root, context) {
	const { helper } = context;
	const { children } = root;
	if (children.length === 1) {
		const singleElementRootChild = getSingleElementRoot(root);
		if (singleElementRootChild && singleElementRootChild.codegenNode) {
			const codegenNode = singleElementRootChild.codegenNode;
			if (codegenNode.type === 13) convertToBlock(codegenNode, context);
			root.codegenNode = codegenNode;
		} else root.codegenNode = children[0];
	} else if (children.length > 1) root.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, root.children, 64, void 0, void 0, true, void 0, false);
}
function traverseChildren(parent, context) {
	let i = 0;
	const nodeRemoved = () => {
		i--;
	};
	for (; i < parent.children.length; i++) {
		const child = parent.children[i];
		if ((0, _vue_shared.isString)(child)) continue;
		context.grandParent = context.parent;
		context.parent = parent;
		context.childIndex = i;
		context.onNodeRemoved = nodeRemoved;
		traverseNode(child, context);
	}
}
function traverseNode(node, context) {
	context.currentNode = node;
	const { nodeTransforms } = context;
	const exitFns = [];
	for (let i = 0; i < nodeTransforms.length; i++) {
		const onExit = nodeTransforms[i](node, context);
		if (onExit) if ((0, _vue_shared.isArray)(onExit)) exitFns.push(...onExit);
		else exitFns.push(onExit);
		if (!context.currentNode) return;
		else node = context.currentNode;
	}
	switch (node.type) {
		case 3:
			if (!context.ssr) context.helper(CREATE_COMMENT);
			break;
		case 5:
			if (!context.ssr) context.helper(TO_DISPLAY_STRING);
			break;
		case 9:
			for (let i = 0; i < node.branches.length; i++) traverseNode(node.branches[i], context);
			break;
		case 10:
		case 11:
		case 1:
		case 0:
			traverseChildren(node, context);
			break;
	}
	context.currentNode = node;
	let i = exitFns.length;
	while (i--) exitFns[i]();
}
function createStructuralDirectiveTransform(name, fn) {
	const matches = (0, _vue_shared.isString)(name) ? (n) => n === name : (n) => name.test(n);
	return (node, context) => {
		if (node.type === 1) {
			const { props } = node;
			if (node.tagType === 3 && props.some(isVSlot)) return;
			const exitFns = [];
			for (let i = 0; i < props.length; i++) {
				const prop = props[i];
				if (prop.type === 7 && matches(prop.name)) {
					props.splice(i, 1);
					i--;
					const onExit = fn(node, prop, context);
					if (onExit) exitFns.push(onExit);
				}
			}
			return exitFns;
		}
	};
}

//#endregion
//#region packages/compiler-core/src/codegen.ts
const PURE_ANNOTATION = `/*@__PURE__*/`;
const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
const NewlineType = {
	"Start": 0,
	"0": "Start",
	"End": -1,
	"-1": "End",
	"None": -2,
	"-2": "None",
	"Unknown": -3,
	"-3": "Unknown"
};
function createCodegenContext(ast, { mode = "function", prefixIdentifiers = mode === "module", sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = "vue/server-renderer", ssr = false, isTS = false, inSSR = false }) {
	const context = {
		mode,
		prefixIdentifiers,
		sourceMap,
		filename,
		scopeId,
		optimizeImports,
		runtimeGlobalName,
		runtimeModuleName,
		ssrRuntimeModuleName,
		ssr,
		isTS,
		inSSR,
		source: ast.source,
		code: ``,
		column: 1,
		line: 1,
		offset: 0,
		indentLevel: 0,
		pure: false,
		map: void 0,
		helper(key) {
			return `_${helperNameMap[key]}`;
		},
		push(code, newlineIndex = -2, node) {
			context.code += code;
			if (context.map) {
				if (node) {
					let name;
					if (node.type === 4 && !node.isStatic) {
						const content = node.content.replace(/^_ctx\./, "");
						if (content !== node.content && isSimpleIdentifier(content)) name = content;
					}
					if (node.loc.source) addMapping(node.loc.start, name);
				}
				if (newlineIndex === -3) advancePositionWithMutation(context, code);
				else {
					context.offset += code.length;
					if (newlineIndex === -2) context.column += code.length;
					else {
						if (newlineIndex === -1) newlineIndex = code.length - 1;
						context.line++;
						context.column = code.length - newlineIndex;
					}
				}
				if (node && node.loc !== locStub && node.loc.source) addMapping(node.loc.end);
			}
		},
		indent() {
			newline(++context.indentLevel);
		},
		deindent(withoutNewLine = false) {
			if (withoutNewLine) --context.indentLevel;
			else newline(--context.indentLevel);
		},
		newline() {
			newline(context.indentLevel);
		}
	};
	function newline(n) {
		context.push("\n" + `  `.repeat(n), 0);
	}
	function addMapping(loc, name = null) {
		const { _names, _mappings } = context.map;
		if (name !== null && !_names.has(name)) _names.add(name);
		_mappings.add({
			originalLine: loc.line,
			originalColumn: loc.column - 1,
			generatedLine: context.line,
			generatedColumn: context.column - 1,
			source: filename,
			name
		});
	}
	if (sourceMap) {
		context.map = new source_map_js.SourceMapGenerator();
		context.map.setSourceContent(filename, context.source);
		context.map._sources.add(filename);
	}
	return context;
}
function generate(ast, options = {}) {
	const context = createCodegenContext(ast, options);
	if (options.onContextCreated) options.onContextCreated(context);
	const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
	const helpers = Array.from(ast.helpers);
	const hasHelpers = helpers.length > 0;
	const useWithBlock = !prefixIdentifiers && mode !== "module";
	const genScopeId = scopeId != null && mode === "module";
	const isSetupInlined = !!options.inline;
	const preambleContext = isSetupInlined ? createCodegenContext(ast, options) : context;
	if (mode === "module") genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined);
	else genFunctionPreamble(ast, preambleContext);
	const functionName = ssr ? `ssrRender` : `render`;
	const args = ssr ? [
		"_ctx",
		"_push",
		"_parent",
		"_attrs"
	] : ["_ctx", "_cache"];
	if (options.bindingMetadata && !options.inline) args.push("$props", "$setup", "$data", "$options");
	const signature = options.isTS ? args.map((arg) => `${arg}: any`).join(",") : args.join(", ");
	if (isSetupInlined) push(`(${signature}) => {`);
	else push(`function ${functionName}(${signature}) {`);
	indent();
	if (useWithBlock) {
		push(`with (_ctx) {`);
		indent();
		if (hasHelpers) {
			push(`const { ${helpers.map(aliasHelper).join(", ")} } = _Vue\n`, -1);
			newline();
		}
	}
	if (ast.components.length) {
		genAssets(ast.components, "component", context);
		if (ast.directives.length || ast.temps > 0) newline();
	}
	if (ast.directives.length) {
		genAssets(ast.directives, "directive", context);
		if (ast.temps > 0) newline();
	}
	if (ast.filters && ast.filters.length) {
		newline();
		genAssets(ast.filters, "filter", context);
		newline();
	}
	if (ast.temps > 0) {
		push(`let `);
		for (let i = 0; i < ast.temps; i++) push(`${i > 0 ? `, ` : ``}_temp${i}`);
	}
	if (ast.components.length || ast.directives.length || ast.temps) {
		push(`\n`, 0);
		newline();
	}
	if (!ssr) push(`return `);
	if (ast.codegenNode) genNode(ast.codegenNode, context);
	else push(`null`);
	if (useWithBlock) {
		deindent();
		push(`}`);
	}
	deindent();
	push(`}`);
	return {
		ast,
		code: context.code,
		preamble: isSetupInlined ? preambleContext.code : ``,
		map: context.map ? context.map.toJSON() : void 0,
		helpers: ast.helpers
	};
}
function genFunctionPreamble(ast, context) {
	const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context;
	const VueBinding = ssr ? `require(${JSON.stringify(runtimeModuleName)})` : runtimeGlobalName;
	const helpers = Array.from(ast.helpers);
	if (helpers.length > 0) if (prefixIdentifiers) push(`const { ${helpers.map(aliasHelper).join(", ")} } = ${VueBinding}\n`, -1);
	else {
		push(`const _Vue = ${VueBinding}\n`, -1);
		if (ast.hoists.length) push(`const { ${[
			CREATE_VNODE,
			CREATE_ELEMENT_VNODE,
			CREATE_COMMENT,
			CREATE_TEXT,
			CREATE_STATIC
		].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ")} } = _Vue\n`, -1);
	}
	if (ast.ssrHelpers && ast.ssrHelpers.length) push(`const { ${ast.ssrHelpers.map(aliasHelper).join(", ")} } = require("${ssrRuntimeModuleName}")\n`, -1);
	genHoists(ast.hoists, context);
	newline();
	push(`return `);
}
function genModulePreamble(ast, context, genScopeId, inline) {
	const { push, newline, optimizeImports, runtimeModuleName, ssrRuntimeModuleName } = context;
	if (ast.helpers.size) {
		const helpers = Array.from(ast.helpers);
		if (optimizeImports) {
			push(`import { ${helpers.map((s) => helperNameMap[s]).join(", ")} } from ${JSON.stringify(runtimeModuleName)}\n`, -1);
			push(`\n// Binding optimization for webpack code-split\nconst ${helpers.map((s) => `_${helperNameMap[s]} = ${helperNameMap[s]}`).join(", ")}\n`, -1);
		} else push(`import { ${helpers.map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`).join(", ")} } from ${JSON.stringify(runtimeModuleName)}\n`, -1);
	}
	if (ast.ssrHelpers && ast.ssrHelpers.length) push(`import { ${ast.ssrHelpers.map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`).join(", ")} } from "${ssrRuntimeModuleName}"\n`, -1);
	if (ast.imports.length) {
		genImports(ast.imports, context);
		newline();
	}
	genHoists(ast.hoists, context);
	newline();
	if (!inline) push(`export `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
	const resolver = helper(type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
	for (let i = 0; i < assets.length; i++) {
		let id = assets[i];
		const maybeSelfReference = id.endsWith("__self");
		if (maybeSelfReference) id = id.slice(0, -6);
		push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
		if (i < assets.length - 1) newline();
	}
}
function genHoists(hoists, context) {
	if (!hoists.length) return;
	context.pure = true;
	const { push, newline } = context;
	newline();
	for (let i = 0; i < hoists.length; i++) {
		const exp = hoists[i];
		if (exp) {
			push(`const _hoisted_${i + 1} = `);
			genNode(exp, context);
			newline();
		}
	}
	context.pure = false;
}
function genImports(importsOptions, context) {
	if (!importsOptions.length) return;
	importsOptions.forEach((imports) => {
		context.push(`import `);
		genNode(imports.exp, context);
		context.push(` from '${imports.path}'`);
		context.newline();
	});
}
function isText$1(n) {
	return (0, _vue_shared.isString)(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
}
function genNodeListAsArray(nodes, context) {
	const multilines = nodes.length > 3 || nodes.some((n) => (0, _vue_shared.isArray)(n) || !isText$1(n));
	context.push(`[`);
	multilines && context.indent();
	genNodeList(nodes, context, multilines);
	multilines && context.deindent();
	context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
	const { push, newline } = context;
	for (let i = 0; i < nodes.length; i++) {
		const node = nodes[i];
		if ((0, _vue_shared.isString)(node)) push(node, -3);
		else if ((0, _vue_shared.isArray)(node)) genNodeListAsArray(node, context);
		else genNode(node, context);
		if (i < nodes.length - 1) if (multilines) {
			comma && push(",");
			newline();
		} else comma && push(", ");
	}
}
function genNode(node, context) {
	if ((0, _vue_shared.isString)(node)) {
		context.push(node, -3);
		return;
	}
	if ((0, _vue_shared.isSymbol)(node)) {
		context.push(context.helper(node));
		return;
	}
	switch (node.type) {
		case 1:
		case 9:
		case 11:
			genNode(node.codegenNode, context);
			break;
		case 2:
			genText(node, context);
			break;
		case 4:
			genExpression(node, context);
			break;
		case 5:
			genInterpolation(node, context);
			break;
		case 12:
			genNode(node.codegenNode, context);
			break;
		case 8:
			genCompoundExpression(node, context);
			break;
		case 3:
			genComment(node, context);
			break;
		case 13:
			genVNodeCall(node, context);
			break;
		case 14:
			genCallExpression(node, context);
			break;
		case 15:
			genObjectExpression(node, context);
			break;
		case 17:
			genArrayExpression(node, context);
			break;
		case 18:
			genFunctionExpression(node, context);
			break;
		case 19:
			genConditionalExpression(node, context);
			break;
		case 20:
			genCacheExpression(node, context);
			break;
		case 21:
			genNodeList(node.body, context, true, false);
			break;
		case 22:
			genTemplateLiteral(node, context);
			break;
		case 23:
			genIfStatement(node, context);
			break;
		case 24:
			genAssignmentExpression(node, context);
			break;
		case 25:
			genSequenceExpression(node, context);
			break;
		case 26:
			genReturnStatement(node, context);
			break;
		case 10: break;
		default:
	}
}
function genText(node, context) {
	context.push(JSON.stringify(node.content), -3, node);
}
function genExpression(node, context) {
	const { content, isStatic } = node;
	context.push(isStatic ? JSON.stringify(content) : content, -3, node);
}
function genInterpolation(node, context) {
	const { push, helper, pure } = context;
	if (pure) push(PURE_ANNOTATION);
	push(`${helper(TO_DISPLAY_STRING)}(`);
	genNode(node.content, context);
	push(`)`);
}
function genCompoundExpression(node, context) {
	for (let i = 0; i < node.children.length; i++) {
		const child = node.children[i];
		if ((0, _vue_shared.isString)(child)) context.push(child, -3);
		else genNode(child, context);
	}
}
function genExpressionAsPropertyKey(node, context) {
	const { push } = context;
	if (node.type === 8) {
		push(`[`);
		genCompoundExpression(node, context);
		push(`]`);
	} else if (node.isStatic) push(isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content), -2, node);
	else push(`[${node.content}]`, -3, node);
}
function genComment(node, context) {
	const { push, helper, pure } = context;
	if (pure) push(PURE_ANNOTATION);
	push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, -3, node);
}
function genVNodeCall(node, context) {
	const { push, helper, pure } = context;
	const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent } = node;
	let patchFlagString;
	if (patchFlag) patchFlagString = String(patchFlag);
	if (directives) push(helper(WITH_DIRECTIVES) + `(`);
	if (isBlock) push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
	if (pure) push(PURE_ANNOTATION);
	push(helper(isBlock ? getVNodeBlockHelper(context.inSSR, isComponent) : getVNodeHelper(context.inSSR, isComponent)) + `(`, -2, node);
	genNodeList(genNullableArgs([
		tag,
		props,
		children,
		patchFlagString,
		dynamicProps
	]), context);
	push(`)`);
	if (isBlock) push(`)`);
	if (directives) {
		push(`, `);
		genNode(directives, context);
		push(`)`);
	}
}
function genNullableArgs(args) {
	let i = args.length;
	while (i--) if (args[i] != null) break;
	return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
	const { push, helper, pure } = context;
	const callee = (0, _vue_shared.isString)(node.callee) ? node.callee : helper(node.callee);
	if (pure) push(PURE_ANNOTATION);
	push(callee + `(`, -2, node);
	genNodeList(node.arguments, context);
	push(`)`);
}
function genObjectExpression(node, context) {
	const { push, indent, deindent, newline } = context;
	const { properties } = node;
	if (!properties.length) {
		push(`{}`, -2, node);
		return;
	}
	const multilines = properties.length > 1 || properties.some((p) => p.value.type !== 4);
	push(multilines ? `{` : `{ `);
	multilines && indent();
	for (let i = 0; i < properties.length; i++) {
		const { key, value } = properties[i];
		genExpressionAsPropertyKey(key, context);
		push(`: `);
		genNode(value, context);
		if (i < properties.length - 1) {
			push(`,`);
			newline();
		}
	}
	multilines && deindent();
	push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
	genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
	const { push, indent, deindent } = context;
	const { params, returns, body, newline, isSlot } = node;
	if (isSlot) push(`_${helperNameMap[WITH_CTX]}(`);
	push(`(`, -2, node);
	if ((0, _vue_shared.isArray)(params)) genNodeList(params, context);
	else if (params) genNode(params, context);
	push(`) => `);
	if (newline || body) {
		push(`{`);
		indent();
	}
	if (returns) {
		if (newline) push(`return `);
		if ((0, _vue_shared.isArray)(returns)) genNodeListAsArray(returns, context);
		else genNode(returns, context);
	} else if (body) genNode(body, context);
	if (newline || body) {
		deindent();
		push(`}`);
	}
	if (isSlot) {
		if (node.isNonScopedSlot) push(`, undefined, true`);
		push(`)`);
	}
}
function genConditionalExpression(node, context) {
	const { test, consequent, alternate, newline: needNewline } = node;
	const { push, indent, deindent, newline } = context;
	if (test.type === 4) {
		const needsParens = !isSimpleIdentifier(test.content);
		needsParens && push(`(`);
		genExpression(test, context);
		needsParens && push(`)`);
	} else {
		push(`(`);
		genNode(test, context);
		push(`)`);
	}
	needNewline && indent();
	context.indentLevel++;
	needNewline || push(` `);
	push(`? `);
	genNode(consequent, context);
	context.indentLevel--;
	needNewline && newline();
	needNewline || push(` `);
	push(`: `);
	const isNested = alternate.type === 19;
	if (!isNested) context.indentLevel++;
	genNode(alternate, context);
	if (!isNested) context.indentLevel--;
	needNewline && deindent(true);
}
function genCacheExpression(node, context) {
	const { push, helper, indent, deindent, newline } = context;
	const { needPauseTracking, needArraySpread } = node;
	if (needArraySpread) push(`[...(`);
	push(`_cache[${node.index}] || (`);
	if (needPauseTracking) {
		indent();
		push(`${helper(SET_BLOCK_TRACKING)}(-1`);
		if (node.inVOnce) push(`, true`);
		push(`),`);
		newline();
		push(`(`);
	}
	push(`_cache[${node.index}] = `);
	genNode(node.value, context);
	if (needPauseTracking) {
		push(`).cacheIndex = ${node.index},`);
		newline();
		push(`${helper(SET_BLOCK_TRACKING)}(1),`);
		newline();
		push(`_cache[${node.index}]`);
		deindent();
	}
	push(`)`);
	if (needArraySpread) push(`)]`);
}
function genTemplateLiteral(node, context) {
	const { push, indent, deindent } = context;
	push("`");
	const l = node.elements.length;
	const multilines = l > 3;
	for (let i = 0; i < l; i++) {
		const e = node.elements[i];
		if ((0, _vue_shared.isString)(e)) push(e.replace(/(`|\$|\\)/g, "\\$1"), -3);
		else {
			push("${");
			if (multilines) indent();
			genNode(e, context);
			if (multilines) deindent();
			push("}");
		}
	}
	push("`");
}
function genIfStatement(node, context) {
	const { push, indent, deindent } = context;
	const { test, consequent, alternate } = node;
	push(`if (`);
	genNode(test, context);
	push(`) {`);
	indent();
	genNode(consequent, context);
	deindent();
	push(`}`);
	if (alternate) {
		push(` else `);
		if (alternate.type === 23) genIfStatement(alternate, context);
		else {
			push(`{`);
			indent();
			genNode(alternate, context);
			deindent();
			push(`}`);
		}
	}
}
function genAssignmentExpression(node, context) {
	genNode(node.left, context);
	context.push(` = `);
	genNode(node.right, context);
}
function genSequenceExpression(node, context) {
	context.push(`(`);
	genNodeList(node.expressions, context);
	context.push(`)`);
}
function genReturnStatement({ returns }, context) {
	context.push(`return `);
	if ((0, _vue_shared.isArray)(returns)) genNodeListAsArray(returns, context);
	else genNode(returns, context);
}

//#endregion
//#region packages/compiler-core/src/transforms/transformExpression.ts
const isLiteralWhitelisted = /* @__PURE__ */ (0, _vue_shared.makeMap)("true,false,null,this");
const transformExpression = (node, context) => {
	if (node.type === 5) node.content = processExpression(node.content, context);
	else if (node.type === 1) {
		const memo = findDir(node, "memo");
		for (let i = 0; i < node.props.length; i++) {
			const dir = node.props[i];
			if (dir.type === 7 && dir.name !== "for") {
				const exp = dir.exp;
				const arg = dir.arg;
				if (exp && exp.type === 4 && !(dir.name === "on" && arg) && !(memo && arg && arg.type === 4 && arg.content === "key")) dir.exp = processExpression(exp, context, dir.name === "slot");
				if (arg && arg.type === 4 && !arg.isStatic) dir.arg = processExpression(arg, context);
			}
		}
	}
};
function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
	if (!context.prefixIdentifiers || !node.content.trim()) return node;
	const { inline, bindingMetadata } = context;
	const rewriteIdentifier = (raw, parent, id) => {
		const type = (0, _vue_shared.hasOwn)(bindingMetadata, raw) && bindingMetadata[raw];
		if (inline) {
			const isAssignmentLVal = parent && parent.type === "AssignmentExpression" && parent.left === id;
			const isUpdateArg = parent && parent.type === "UpdateExpression" && parent.argument === id;
			const isDestructureAssignment = parent && isInDestructureAssignment(parent, parentStack);
			const isNewExpression = parent && isInNewExpression(parentStack);
			const wrapWithUnref = (raw) => {
				const wrapped = `${context.helperString(UNREF)}(${raw})`;
				return isNewExpression ? `(${wrapped})` : wrapped;
			};
			if (isConst(type) || type === "setup-reactive-const" || localVars[raw]) return raw;
			else if (type === "setup-ref") return `${raw}.value`;
			else if (type === "setup-maybe-ref") return isAssignmentLVal || isUpdateArg || isDestructureAssignment ? `${raw}.value` : wrapWithUnref(raw);
			else if (type === "setup-let") if (isAssignmentLVal) {
				const { right: rVal, operator } = parent;
				const rExpString = stringifyExpression(processExpression(createSimpleExpression(rawExp.slice(rVal.start - 1, rVal.end - 1), false), context, false, false, knownIds));
				return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore\n` : ``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`;
			} else if (isUpdateArg) {
				id.start = parent.start;
				id.end = parent.end;
				const { prefix: isPrefix, operator } = parent;
				const prefix = isPrefix ? operator : ``;
				const postfix = isPrefix ? `` : operator;
				return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore\n` : ``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`;
			} else if (isDestructureAssignment) return raw;
			else return wrapWithUnref(raw);
			else if (type === "props") return (0, _vue_shared.genPropsAccessExp)(raw);
			else if (type === "props-aliased") return (0, _vue_shared.genPropsAccessExp)(bindingMetadata.__propsAliases[raw]);
		} else if (type && type.startsWith("setup") || type === "literal-const") return `$setup.${raw}`;
		else if (type === "props-aliased") return `$props['${bindingMetadata.__propsAliases[raw]}']`;
		else if (type) return `$${type}.${raw}`;
		return `_ctx.${raw}`;
	};
	const rawExp = node.content;
	let ast = node.ast;
	if (ast === false) return node;
	if (ast === null || !ast && isSimpleIdentifier(rawExp)) {
		const isScopeVarReference = context.identifiers[rawExp];
		const isAllowedGlobal = (0, _vue_shared.isGloballyAllowed)(rawExp);
		const isLiteral = isLiteralWhitelisted(rawExp);
		if (!asParams && !isScopeVarReference && !isLiteral && (!isAllowedGlobal || bindingMetadata[rawExp])) {
			if (isConst(bindingMetadata[rawExp])) node.constType = 1;
			node.content = rewriteIdentifier(rawExp);
		} else if (!isScopeVarReference) if (isLiteral) node.constType = 3;
		else node.constType = 2;
		return node;
	}
	if (!ast) {
		const source = asRawStatements ? ` ${rawExp} ` : `(${rawExp})${asParams ? `=>{}` : ``}`;
		try {
			ast = (0, _babel_parser.parseExpression)(source, {
				sourceType: "module",
				plugins: context.expressionPlugins
			});
		} catch (e) {
			context.onError(createCompilerError(46, node.loc, void 0, e.message));
			return node;
		}
	}
	const ids = [];
	const parentStack = [];
	const knownIds = Object.create(context.identifiers);
	walkIdentifiers(ast, (node, parent, _, isReferenced, isLocal) => {
		if (isStaticPropertyKey(node, parent)) return;
		if (node.name.startsWith("_filter_")) return;
		const needPrefix = isReferenced && canPrefix(node);
		if (needPrefix && !isLocal) {
			if (isStaticProperty(parent) && parent.shorthand) node.prefix = `${node.name}: `;
			node.name = rewriteIdentifier(node.name, parent, node);
			ids.push(node);
		} else {
			if (!(needPrefix && isLocal) && (!parent || parent.type !== "CallExpression" && parent.type !== "NewExpression" && parent.type !== "MemberExpression")) node.isConstant = true;
			ids.push(node);
		}
	}, true, parentStack, knownIds);
	const children = [];
	ids.sort((a, b) => a.start - b.start);
	ids.forEach((id, i) => {
		const start = id.start - 1;
		const end = id.end - 1;
		const last = ids[i - 1];
		const leadingText = rawExp.slice(last ? last.end - 1 : 0, start);
		if (leadingText.length || id.prefix) children.push(leadingText + (id.prefix || ``));
		const source = rawExp.slice(start, end);
		children.push(createSimpleExpression(id.name, false, {
			start: advancePositionWithClone(node.loc.start, source, start),
			end: advancePositionWithClone(node.loc.start, source, end),
			source
		}, id.isConstant ? 3 : 0));
		if (i === ids.length - 1 && end < rawExp.length) children.push(rawExp.slice(end));
	});
	let ret;
	if (children.length) {
		ret = createCompoundExpression(children, node.loc);
		ret.ast = ast;
	} else {
		ret = node;
		ret.constType = 3;
	}
	ret.identifiers = Object.keys(knownIds);
	return ret;
}
function canPrefix(id) {
	if ((0, _vue_shared.isGloballyAllowed)(id.name)) return false;
	if (id.name === "require") return false;
	return true;
}
function stringifyExpression(exp) {
	if ((0, _vue_shared.isString)(exp)) return exp;
	else if (exp.type === 4) return exp.content;
	else return exp.children.map(stringifyExpression).join("");
}
function isConst(type) {
	return type === "setup-const" || type === "literal-const";
}

//#endregion
//#region packages/compiler-core/src/transforms/vIf.ts
const transformIf = createStructuralDirectiveTransform(/^(?:if|else|else-if)$/, (node, dir, context) => {
	return processIf(node, dir, context, (ifNode, branch, isRoot) => {
		const siblings = context.parent.children;
		let i = siblings.indexOf(ifNode);
		let key = 0;
		while (i-- >= 0) {
			const sibling = siblings[i];
			if (sibling && sibling.type === 9) key += sibling.branches.length;
		}
		return () => {
			if (isRoot) ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
			else {
				const parentCondition = getParentCondition(ifNode.codegenNode);
				parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
			}
		};
	});
});
function processIf(node, dir, context, processCodegen) {
	if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
		const loc = dir.exp ? dir.exp.loc : node.loc;
		context.onError(createCompilerError(28, dir.loc));
		dir.exp = createSimpleExpression(`true`, false, loc);
	}
	if (context.prefixIdentifiers && dir.exp) dir.exp = processExpression(dir.exp, context);
	if (dir.name === "if") {
		const branch = createIfBranch(node, dir);
		const ifNode = {
			type: 9,
			loc: cloneLoc(node.loc),
			branches: [branch]
		};
		context.replaceNode(ifNode);
		if (processCodegen) return processCodegen(ifNode, branch, true);
	} else {
		const siblings = context.parent.children;
		let i = siblings.indexOf(node);
		while (i-- >= -1) {
			const sibling = siblings[i];
			if (sibling && isCommentOrWhitespace(sibling)) {
				context.removeNode(sibling);
				continue;
			}
			if (sibling && sibling.type === 9) {
				if ((dir.name === "else-if" || dir.name === "else") && sibling.branches[sibling.branches.length - 1].condition === void 0) context.onError(createCompilerError(30, node.loc));
				context.removeNode();
				const branch = createIfBranch(node, dir);
				{
					const key = branch.userKey;
					if (key) sibling.branches.forEach(({ userKey }) => {
						if (isSameKey(userKey, key)) context.onError(createCompilerError(29, branch.userKey.loc));
					});
				}
				sibling.branches.push(branch);
				const onExit = processCodegen && processCodegen(sibling, branch, false);
				traverseNode(branch, context);
				if (onExit) onExit();
				context.currentNode = null;
			} else context.onError(createCompilerError(30, node.loc));
			break;
		}
	}
}
function createIfBranch(node, dir) {
	const isTemplateIf = node.tagType === 3;
	return {
		type: 10,
		loc: node.loc,
		condition: dir.name === "else" ? void 0 : dir.exp,
		children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
		userKey: findProp(node, `key`),
		isTemplateIf
	};
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
	if (branch.condition) return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), createCallExpression(context.helper(CREATE_COMMENT), ["\"\"", "true"]));
	else return createChildrenCodegenNode(branch, keyIndex, context);
}
function createChildrenCodegenNode(branch, keyIndex, context) {
	const { helper } = context;
	const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2));
	const { children } = branch;
	const firstChild = children[0];
	if (children.length !== 1 || firstChild.type !== 1) if (children.length === 1 && firstChild.type === 11) {
		const vnodeCall = firstChild.codegenNode;
		injectProp(vnodeCall, keyProperty, context);
		return vnodeCall;
	} else return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, 64, void 0, void 0, true, false, false, branch.loc);
	else {
		const ret = firstChild.codegenNode;
		const vnodeCall = getMemoedVNodeCall(ret);
		if (vnodeCall.type === 13) convertToBlock(vnodeCall, context);
		injectProp(vnodeCall, keyProperty, context);
		return ret;
	}
}
function isSameKey(a, b) {
	if (!a || a.type !== b.type) return false;
	if (a.type === 6) {
		if (a.value.content !== b.value.content) return false;
	} else {
		const exp = a.exp;
		const branchExp = b.exp;
		if (exp.type !== branchExp.type) return false;
		if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) return false;
	}
	return true;
}
function getParentCondition(node) {
	while (true) if (node.type === 19) if (node.alternate.type === 19) node = node.alternate;
	else return node;
	else if (node.type === 20) node = node.value;
}

//#endregion
//#region packages/compiler-core/src/transforms/vFor.ts
const transformFor = createStructuralDirectiveTransform("for", (node, dir, context) => {
	const { helper, removeHelper } = context;
	return processFor(node, dir, context, (forNode) => {
		const renderExp = createCallExpression(helper(RENDER_LIST), [forNode.source]);
		const isTemplate = isTemplateNode(node);
		const memo = findDir(node, "memo");
		const keyProp = findProp(node, `key`, false, true);
		const isDirKey = keyProp && keyProp.type === 7;
		let keyExp = keyProp && (keyProp.type === 6 ? keyProp.value ? createSimpleExpression(keyProp.value.content, true) : void 0 : keyProp.exp);
		if (memo && keyExp && isDirKey) keyProp.exp = keyExp = processExpression(keyExp, context);
		const keyProperty = keyProp && keyExp ? createObjectProperty(`key`, keyExp) : null;
		if (isTemplate) {
			if (memo) memo.exp = processExpression(memo.exp, context);
			if (keyProperty && keyProp.type !== 6) keyProperty.value = processExpression(keyProperty.value, context);
		}
		const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
		const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
		forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, renderExp, fragmentFlag, void 0, void 0, true, !isStableFragment, false, node.loc);
		return () => {
			let childBlock;
			const { children } = forNode;
			if (isTemplate) node.children.some((c) => {
				if (c.type === 1) {
					const key = findProp(c, "key");
					if (key) {
						context.onError(createCompilerError(33, key.loc));
						return true;
					}
				}
			});
			const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
			const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
			if (slotOutlet) {
				childBlock = slotOutlet.codegenNode;
				if (isTemplate && keyProperty) injectProp(childBlock, keyProperty, context);
			} else if (needFragmentWrapper) childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : void 0, node.children, 64, void 0, void 0, true, void 0, false);
			else {
				childBlock = children[0].codegenNode;
				if (isTemplate && keyProperty) injectProp(childBlock, keyProperty, context);
				if (childBlock.isBlock !== !isStableFragment) if (childBlock.isBlock) {
					removeHelper(OPEN_BLOCK);
					removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
				} else removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
				childBlock.isBlock = !isStableFragment;
				if (childBlock.isBlock) {
					helper(OPEN_BLOCK);
					helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
				} else helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
			}
			if (memo) {
				const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [createSimpleExpression(`_cached`)]));
				loop.body = createBlockStatement([
					createCompoundExpression([
						`const _memo = (`,
						memo.exp,
						`)`
					]),
					createCompoundExpression([
						`if (_cached`,
						...keyExp ? [` && _cached.key === `, keyExp] : [],
						` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
					]),
					createCompoundExpression([`const _item = `, childBlock]),
					createSimpleExpression(`_item.memo = _memo`),
					createSimpleExpression(`return _item`)
				]);
				renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached.length)));
				context.cached.push(null);
			} else renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true));
		};
	});
});
function processFor(node, dir, context, processCodegen) {
	if (!dir.exp) {
		context.onError(createCompilerError(31, dir.loc));
		return;
	}
	const parseResult = dir.forParseResult;
	if (!parseResult) {
		context.onError(createCompilerError(32, dir.loc));
		return;
	}
	finalizeForParseResult(parseResult, context);
	const { addIdentifiers, removeIdentifiers, scopes } = context;
	const { source, value, key, index } = parseResult;
	const forNode = {
		type: 11,
		loc: dir.loc,
		source,
		valueAlias: value,
		keyAlias: key,
		objectIndexAlias: index,
		parseResult,
		children: isTemplateNode(node) ? node.children : [node]
	};
	context.replaceNode(forNode);
	scopes.vFor++;
	if (context.prefixIdentifiers) {
		value && addIdentifiers(value);
		key && addIdentifiers(key);
		index && addIdentifiers(index);
	}
	const onExit = processCodegen && processCodegen(forNode);
	return () => {
		scopes.vFor--;
		if (context.prefixIdentifiers) {
			value && removeIdentifiers(value);
			key && removeIdentifiers(key);
			index && removeIdentifiers(index);
		}
		if (onExit) onExit();
	};
}
function finalizeForParseResult(result, context) {
	if (result.finalized) return;
	if (context.prefixIdentifiers) {
		result.source = processExpression(result.source, context);
		if (result.key) result.key = processExpression(result.key, context, true);
		if (result.index) result.index = processExpression(result.index, context, true);
		if (result.value) result.value = processExpression(result.value, context, true);
	}
	result.finalized = true;
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
	return createParamsList([
		value,
		key,
		index,
		...memoArgs
	]);
}
function createParamsList(args) {
	let i = args.length;
	while (i--) if (args[i]) break;
	return args.slice(0, i + 1).map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false));
}

//#endregion
//#region packages/compiler-core/src/transforms/vSlot.ts
const defaultFallback = createSimpleExpression(`undefined`, false);
const trackSlotScopes = (node, context) => {
	if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
		const vSlot = findDir(node, "slot");
		if (vSlot) {
			const slotProps = vSlot.exp;
			if (context.prefixIdentifiers) slotProps && context.addIdentifiers(slotProps);
			context.scopes.vSlot++;
			return () => {
				if (context.prefixIdentifiers) slotProps && context.removeIdentifiers(slotProps);
				context.scopes.vSlot--;
			};
		}
	}
};
const trackVForSlotScopes = (node, context) => {
	let vFor;
	if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
		const result = vFor.forParseResult;
		if (result) {
			finalizeForParseResult(result, context);
			const { value, key, index } = result;
			const { addIdentifiers, removeIdentifiers } = context;
			value && addIdentifiers(value);
			key && addIdentifiers(key);
			index && addIdentifiers(index);
			return () => {
				value && removeIdentifiers(value);
				key && removeIdentifiers(key);
				index && removeIdentifiers(index);
			};
		}
	}
};
const buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(props, children, false, true, children.length ? children[0].loc : loc);
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
	context.helper(WITH_CTX);
	const { children, loc } = node;
	const slotsProperties = [];
	const dynamicSlots = [];
	let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
	if (!context.ssr && context.prefixIdentifiers) hasDynamicSlots = node.props.some((prop) => isVSlot(prop) && (hasScopeRef(prop.arg, context.identifiers) || hasScopeRef(prop.exp, context.identifiers))) || children.some((child) => hasScopeRef(child, context.identifiers));
	const onComponentSlot = findDir(node, "slot", true);
	if (onComponentSlot) {
		const { arg, exp } = onComponentSlot;
		if (arg && !isStaticExp(arg)) hasDynamicSlots = true;
		slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, void 0, children, loc)));
	}
	let hasTemplateSlots = false;
	let hasNamedDefaultSlot = false;
	const implicitDefaultChildren = [];
	const seenSlotNames = /* @__PURE__ */ new Set();
	let conditionalBranchIndex = 0;
	for (let i = 0; i < children.length; i++) {
		const slotElement = children[i];
		let slotDir;
		if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
			if (slotElement.type !== 3) implicitDefaultChildren.push(slotElement);
			continue;
		}
		if (onComponentSlot) {
			context.onError(createCompilerError(37, slotDir.loc));
			break;
		}
		hasTemplateSlots = true;
		const { children: slotChildren, loc: slotLoc } = slotElement;
		const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
		let staticSlotName;
		if (isStaticExp(slotName)) staticSlotName = slotName ? slotName.content : `default`;
		else hasDynamicSlots = true;
		const vFor = findDir(slotElement, "for");
		const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
		let vIf;
		let vElse;
		if (vIf = findDir(slotElement, "if")) {
			hasDynamicSlots = true;
			dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback));
		} else if (vElse = findDir(slotElement, /^else(?:-if)?$/, true)) {
			let j = i;
			let prev;
			while (j--) {
				prev = children[j];
				if (!isCommentOrWhitespace(prev)) break;
			}
			if (prev && isTemplateNode(prev) && findDir(prev, /^(?:else-)?if$/)) {
				let conditional = dynamicSlots[dynamicSlots.length - 1];
				while (conditional.alternate.type === 19) conditional = conditional.alternate;
				conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
			} else context.onError(createCompilerError(30, vElse.loc));
		} else if (vFor) {
			hasDynamicSlots = true;
			const parseResult = vFor.forParseResult;
			if (parseResult) {
				finalizeForParseResult(parseResult, context);
				dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [parseResult.source, createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true)]));
			} else context.onError(createCompilerError(32, vFor.loc));
		} else {
			if (staticSlotName) {
				if (seenSlotNames.has(staticSlotName)) {
					context.onError(createCompilerError(38, dirLoc));
					continue;
				}
				seenSlotNames.add(staticSlotName);
				if (staticSlotName === "default") hasNamedDefaultSlot = true;
			}
			slotsProperties.push(createObjectProperty(slotName, slotFunction));
		}
	}
	if (!onComponentSlot) {
		const buildDefaultSlotProperty = (props, children) => {
			const fn = buildSlotFn(props, void 0, children, loc);
			if (context.compatConfig) fn.isNonScopedSlot = true;
			return createObjectProperty(`default`, fn);
		};
		if (!hasTemplateSlots) slotsProperties.push(buildDefaultSlotProperty(void 0, children));
		else if (implicitDefaultChildren.length && !implicitDefaultChildren.every(isWhitespaceText)) if (hasNamedDefaultSlot) context.onError(createCompilerError(39, implicitDefaultChildren[0].loc));
		else slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
	}
	const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
	let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, createSimpleExpression(slotFlag + ``, false))), loc);
	if (dynamicSlots.length) slots = createCallExpression(context.helper(CREATE_SLOTS), [slots, createArrayExpression(dynamicSlots)]);
	return {
		slots,
		hasDynamicSlots
	};
}
function buildDynamicSlot(name, fn, index) {
	const props = [createObjectProperty(`name`, name), createObjectProperty(`fn`, fn)];
	if (index != null) props.push(createObjectProperty(`key`, createSimpleExpression(String(index), true)));
	return createObjectExpression(props);
}
function hasForwardedSlots(children) {
	for (let i = 0; i < children.length; i++) {
		const child = children[i];
		switch (child.type) {
			case 1:
				if (child.tagType === 2 || hasForwardedSlots(child.children)) return true;
				break;
			case 9:
				if (hasForwardedSlots(child.branches)) return true;
				break;
			case 10:
			case 11:
				if (hasForwardedSlots(child.children)) return true;
				break;
			default: break;
		}
	}
	return false;
}

//#endregion
//#region packages/compiler-core/src/transforms/transformElement.ts
const directiveImportMap = /* @__PURE__ */ new WeakMap();
const transformElement = (node, context) => {
	return function postTransformElement() {
		node = context.currentNode;
		if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) return;
		const { tag, props } = node;
		const isComponent = node.tagType === 1;
		let vnodeTag = isComponent ? resolveComponentType(node, context) : `"${tag}"`;
		const isDynamicComponent = (0, _vue_shared.isObject)(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
		let vnodeProps;
		let vnodeChildren;
		let patchFlag = 0;
		let vnodeDynamicProps;
		let dynamicPropNames;
		let vnodeDirectives;
		let shouldUseBlock = isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent && (tag === "svg" || tag === "foreignObject" || tag === "math");
		if (props.length > 0) {
			const propsBuildResult = buildProps(node, context, void 0, isComponent, isDynamicComponent);
			vnodeProps = propsBuildResult.props;
			patchFlag = propsBuildResult.patchFlag;
			dynamicPropNames = propsBuildResult.dynamicPropNames;
			const directives = propsBuildResult.directives;
			vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map((dir) => buildDirectiveArgs(dir, context))) : void 0;
			if (propsBuildResult.shouldUseBlock) shouldUseBlock = true;
		}
		if (node.children.length > 0) {
			if (vnodeTag === KEEP_ALIVE) {
				shouldUseBlock = true;
				patchFlag |= 1024;
			}
			if (isComponent && vnodeTag !== TELEPORT && vnodeTag !== KEEP_ALIVE) {
				const { slots, hasDynamicSlots } = buildSlots(node, context);
				vnodeChildren = slots;
				if (hasDynamicSlots) patchFlag |= 1024;
			} else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
				const child = node.children[0];
				const type = child.type;
				const hasDynamicTextChild = type === 5 || type === 8;
				if (hasDynamicTextChild && getConstantType(child, context) === 0) patchFlag |= 1;
				if (hasDynamicTextChild || type === 2) vnodeChildren = child;
				else vnodeChildren = node.children;
			} else vnodeChildren = node.children;
		}
		if (dynamicPropNames && dynamicPropNames.length) vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
		node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, patchFlag === 0 ? void 0 : patchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent, node.loc);
	};
};
function resolveComponentType(node, context, ssr = false) {
	let { tag } = node;
	const isExplicitDynamic = isComponentTag(tag);
	const isProp = findProp(node, "is", false, true);
	if (isProp) {
		if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context)) {
			let exp;
			if (isProp.type === 6) exp = isProp.value && createSimpleExpression(isProp.value.content, true);
			else {
				exp = isProp.exp;
				if (!exp) {
					exp = createSimpleExpression(`is`, false, isProp.arg.loc);
					exp = isProp.exp = processExpression(exp, context);
				}
			}
			if (exp) return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [exp]);
		} else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) tag = isProp.value.content.slice(4);
	}
	const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
	if (builtIn) {
		if (!ssr) context.helper(builtIn);
		return builtIn;
	}
	{
		const fromSetup = resolveSetupReference(tag, context);
		if (fromSetup) return fromSetup;
		const dotIndex = tag.indexOf(".");
		if (dotIndex > 0) {
			const ns = resolveSetupReference(tag.slice(0, dotIndex), context);
			if (ns) return ns + tag.slice(dotIndex);
		}
	}
	if (context.selfName && (0, _vue_shared.capitalize)((0, _vue_shared.camelize)(tag)) === context.selfName) {
		context.helper(RESOLVE_COMPONENT);
		context.components.add(tag + `__self`);
		return toValidAssetId(tag, `component`);
	}
	context.helper(RESOLVE_COMPONENT);
	context.components.add(tag);
	return toValidAssetId(tag, `component`);
}
function resolveSetupReference(name, context) {
	const bindings = context.bindingMetadata;
	if (!bindings || bindings.__isScriptSetup === false) return;
	const camelName = (0, _vue_shared.camelize)(name);
	const PascalName = (0, _vue_shared.capitalize)(camelName);
	const checkType = (type) => {
		if (bindings[name] === type) return name;
		if (bindings[camelName] === type) return camelName;
		if (bindings[PascalName] === type) return PascalName;
	};
	const fromConst = checkType("setup-const") || checkType("setup-reactive-const") || checkType("literal-const");
	if (fromConst) return context.inline ? fromConst : `$setup[${JSON.stringify(fromConst)}]`;
	const fromMaybeRef = checkType("setup-let") || checkType("setup-ref") || checkType("setup-maybe-ref");
	if (fromMaybeRef) return context.inline ? `${context.helperString(UNREF)}(${fromMaybeRef})` : `$setup[${JSON.stringify(fromMaybeRef)}]`;
	const fromProps = checkType("props");
	if (fromProps) return `${context.helperString(UNREF)}(${context.inline ? "__props" : "$props"}[${JSON.stringify(fromProps)}])`;
}
function buildProps(node, context, props = node.props, isComponent, isDynamicComponent, ssr = false) {
	const { tag, loc: elementLoc, children } = node;
	let properties = [];
	const mergeArgs = [];
	const runtimeDirectives = [];
	const hasChildren = children.length > 0;
	let shouldUseBlock = false;
	let patchFlag = 0;
	let hasRef = false;
	let hasClassBinding = false;
	let hasStyleBinding = false;
	let hasHydrationEventBinding = false;
	let hasDynamicKeys = false;
	let hasVnodeHook = false;
	const dynamicPropNames = [];
	const pushMergeArg = (arg) => {
		if (properties.length) {
			mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
			properties = [];
		}
		if (arg) mergeArgs.push(arg);
	};
	const pushRefVForMarker = () => {
		if (context.scopes.vFor > 0) properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
	};
	const analyzePatchFlag = ({ key, value }) => {
		if (isStaticExp(key)) {
			const name = key.content;
			const isEventHandler = (0, _vue_shared.isOn)(name);
			if (isEventHandler && (!isComponent || isDynamicComponent) && name.toLowerCase() !== "onclick" && name !== "onUpdate:modelValue" && !(0, _vue_shared.isReservedProp)(name)) hasHydrationEventBinding = true;
			if (isEventHandler && (0, _vue_shared.isReservedProp)(name)) hasVnodeHook = true;
			if (isEventHandler && value.type === 14) value = value.arguments[0];
			if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) return;
			if (name === "ref") hasRef = true;
			else if (name === "class") hasClassBinding = true;
			else if (name === "style") hasStyleBinding = true;
			else if (name !== "key" && !dynamicPropNames.includes(name)) dynamicPropNames.push(name);
			if (isComponent && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) dynamicPropNames.push(name);
		} else hasDynamicKeys = true;
	};
	for (let i = 0; i < props.length; i++) {
		const prop = props[i];
		if (prop.type === 6) {
			const { loc, name, nameLoc, value } = prop;
			let isStatic = true;
			if (name === "ref") {
				hasRef = true;
				pushRefVForMarker();
				if (value && context.inline) {
					const binding = context.bindingMetadata[value.content];
					if (binding === "setup-let" || binding === "setup-ref" || binding === "setup-maybe-ref") {
						isStatic = false;
						properties.push(createObjectProperty(createSimpleExpression("ref_key", true), createSimpleExpression(value.content, true, value.loc)));
					}
				}
			}
			if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) continue;
			properties.push(createObjectProperty(createSimpleExpression(name, true, nameLoc), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
		} else {
			const { name, arg, exp, loc, modifiers } = prop;
			const isVBind = name === "bind";
			const isVOn = name === "on";
			if (name === "slot") {
				if (!isComponent) context.onError(createCompilerError(40, loc));
				continue;
			}
			if (name === "once" || name === "memo") continue;
			if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) continue;
			if (isVOn && ssr) continue;
			if (isVBind && isStaticArgOf(arg, "key") || isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")) shouldUseBlock = true;
			if (isVBind && isStaticArgOf(arg, "ref")) pushRefVForMarker();
			if (!arg && (isVBind || isVOn)) {
				hasDynamicKeys = true;
				if (exp) if (isVBind) {
					pushMergeArg();
					if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context)) {
						mergeArgs.unshift(exp);
						continue;
					}
					pushRefVForMarker();
					pushMergeArg();
					mergeArgs.push(exp);
				} else pushMergeArg({
					type: 14,
					loc,
					callee: context.helper(TO_HANDLERS),
					arguments: isComponent ? [exp] : [exp, `true`]
				});
				else context.onError(createCompilerError(isVBind ? 34 : 35, loc));
				continue;
			}
			if (isVBind && modifiers.some((mod) => mod.content === "prop")) patchFlag |= 32;
			const directiveTransform = context.directiveTransforms[name];
			if (directiveTransform) {
				const { props, needRuntime } = directiveTransform(prop, node, context);
				!ssr && props.forEach(analyzePatchFlag);
				if (isVOn && arg && !isStaticExp(arg)) pushMergeArg(createObjectExpression(props, elementLoc));
				else properties.push(...props);
				if (needRuntime) {
					runtimeDirectives.push(prop);
					if ((0, _vue_shared.isSymbol)(needRuntime)) directiveImportMap.set(prop, needRuntime);
				}
			} else if (!(0, _vue_shared.isBuiltInDirective)(name)) {
				runtimeDirectives.push(prop);
				if (hasChildren) shouldUseBlock = true;
			}
		}
	}
	let propsExpression = void 0;
	if (mergeArgs.length) {
		pushMergeArg();
		if (mergeArgs.length > 1) propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
		else propsExpression = mergeArgs[0];
	} else if (properties.length) propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
	if (hasDynamicKeys) patchFlag |= 16;
	else {
		if (hasClassBinding && !isComponent) patchFlag |= 2;
		if (hasStyleBinding && !isComponent) patchFlag |= 4;
		if (dynamicPropNames.length) patchFlag |= 8;
		if (hasHydrationEventBinding) patchFlag |= 32;
	}
	if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) patchFlag |= 512;
	if (!context.inSSR && propsExpression) switch (propsExpression.type) {
		case 15:
			let classKeyIndex = -1;
			let styleKeyIndex = -1;
			let hasDynamicKey = false;
			for (let i = 0; i < propsExpression.properties.length; i++) {
				const key = propsExpression.properties[i].key;
				if (isStaticExp(key)) {
					if (key.content === "class") classKeyIndex = i;
					else if (key.content === "style") styleKeyIndex = i;
				} else if (!key.isHandlerKey) hasDynamicKey = true;
			}
			const classProp = propsExpression.properties[classKeyIndex];
			const styleProp = propsExpression.properties[styleKeyIndex];
			if (!hasDynamicKey) {
				if (classProp && !isStaticExp(classProp.value)) classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
				if (styleProp && (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || styleProp.value.type === 17)) styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
			} else propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
			break;
		case 14: break;
		default:
			propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [propsExpression])]);
			break;
	}
	return {
		props: propsExpression,
		directives: runtimeDirectives,
		patchFlag,
		dynamicPropNames,
		shouldUseBlock
	};
}
function dedupeProperties(properties) {
	const knownProps = /* @__PURE__ */ new Map();
	const deduped = [];
	for (let i = 0; i < properties.length; i++) {
		const prop = properties[i];
		if (prop.key.type === 8 || !prop.key.isStatic) {
			deduped.push(prop);
			continue;
		}
		const name = prop.key.content;
		const existing = knownProps.get(name);
		if (existing) {
			if (name === "style" || name === "class" || (0, _vue_shared.isOn)(name)) mergeAsArray(existing, prop);
		} else {
			knownProps.set(name, prop);
			deduped.push(prop);
		}
	}
	return deduped;
}
function mergeAsArray(existing, incoming) {
	if (existing.value.type === 17) existing.value.elements.push(incoming.value);
	else existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
}
function buildDirectiveArgs(dir, context) {
	const dirArgs = [];
	const runtime = directiveImportMap.get(dir);
	if (runtime) dirArgs.push(context.helperString(runtime));
	else {
		const fromSetup = resolveSetupReference("v-" + dir.name, context);
		if (fromSetup) dirArgs.push(fromSetup);
		else {
			context.helper(RESOLVE_DIRECTIVE);
			context.directives.add(dir.name);
			dirArgs.push(toValidAssetId(dir.name, `directive`));
		}
	}
	const { loc } = dir;
	if (dir.exp) dirArgs.push(dir.exp);
	if (dir.arg) {
		if (!dir.exp) dirArgs.push(`void 0`);
		dirArgs.push(dir.arg);
	}
	if (Object.keys(dir.modifiers).length) {
		if (!dir.arg) {
			if (!dir.exp) dirArgs.push(`void 0`);
			dirArgs.push(`void 0`);
		}
		const trueExpression = createSimpleExpression(`true`, false, loc);
		dirArgs.push(createObjectExpression(dir.modifiers.map((modifier) => createObjectProperty(modifier, trueExpression)), loc));
	}
	return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
	let propsNamesString = `[`;
	for (let i = 0, l = props.length; i < l; i++) {
		propsNamesString += JSON.stringify(props[i]);
		if (i < l - 1) propsNamesString += ", ";
	}
	return propsNamesString + `]`;
}
function isComponentTag(tag) {
	return tag === "component" || tag === "Component";
}

//#endregion
//#region packages/compiler-core/src/transforms/transformSlotOutlet.ts
const transformSlotOutlet = (node, context) => {
	if (isSlotOutlet(node)) {
		const { children, loc } = node;
		const { slotName, slotProps } = processSlotOutlet(node, context);
		const slotArgs = [
			context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
			slotName,
			"{}",
			"undefined",
			"true"
		];
		let expectedLen = 2;
		if (slotProps) {
			slotArgs[2] = slotProps;
			expectedLen = 3;
		}
		if (children.length) {
			slotArgs[3] = createFunctionExpression([], children, false, false, loc);
			expectedLen = 4;
		}
		if (context.scopeId && !context.slotted) expectedLen = 5;
		slotArgs.splice(expectedLen);
		node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
	}
};
function processSlotOutlet(node, context) {
	let slotName = `"default"`;
	let slotProps = void 0;
	const nonNameProps = [];
	for (let i = 0; i < node.props.length; i++) {
		const p = node.props[i];
		if (p.type === 6) {
			if (p.value) if (p.name === "name") slotName = JSON.stringify(p.value.content);
			else {
				p.name = (0, _vue_shared.camelize)(p.name);
				nonNameProps.push(p);
			}
		} else if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
			if (p.exp) slotName = p.exp;
			else if (p.arg && p.arg.type === 4) {
				slotName = p.exp = createSimpleExpression((0, _vue_shared.camelize)(p.arg.content), false, p.arg.loc);
				slotName = p.exp = processExpression(p.exp, context);
			}
		} else {
			if (p.name === "bind" && p.arg && isStaticExp(p.arg)) p.arg.content = (0, _vue_shared.camelize)(p.arg.content);
			nonNameProps.push(p);
		}
	}
	if (nonNameProps.length > 0) {
		const { props, directives } = buildProps(node, context, nonNameProps, false, false);
		slotProps = props;
		if (directives.length) context.onError(createCompilerError(36, directives[0].loc));
	}
	return {
		slotName,
		slotProps
	};
}

//#endregion
//#region packages/compiler-core/src/transforms/vOn.ts
const transformOn = (dir, node, context, augmentor) => {
	const { loc, modifiers, arg } = dir;
	if (!dir.exp && !modifiers.length) context.onError(createCompilerError(35, loc));
	let eventName;
	if (arg.type === 4) if (arg.isStatic) {
		let rawName = arg.content;
		if (rawName.startsWith("vue:")) rawName = `vnode-${rawName.slice(4)}`;
		eventName = createSimpleExpression(node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (0, _vue_shared.toHandlerKey)((0, _vue_shared.camelize)(rawName)) : `on:${rawName}`, true, arg.loc);
	} else eventName = createCompoundExpression([
		`${context.helperString(TO_HANDLER_KEY)}(`,
		arg,
		`)`
	]);
	else {
		eventName = arg;
		eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
		eventName.children.push(`)`);
	}
	let exp = dir.exp;
	if (exp && !exp.content.trim()) exp = void 0;
	let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
	if (exp) {
		const isMemberExp = isMemberExpression(exp, context);
		const isInlineStatement = !(isMemberExp || isFnExpression(exp, context));
		const hasMultipleStatements = exp.content.includes(`;`);
		if (context.prefixIdentifiers) {
			isInlineStatement && context.addIdentifiers(`$event`);
			exp = dir.exp = processExpression(exp, context, false, hasMultipleStatements);
			isInlineStatement && context.removeIdentifiers(`$event`);
			shouldCache = context.cacheHandlers && !context.inVOnce && !(exp.type === 4 && exp.constType > 0) && !(isMemberExp && node.tagType === 1) && !hasScopeRef(exp, context.identifiers);
			if (shouldCache && isMemberExp) if (exp.type === 4) exp.content = `${exp.content} && ${exp.content}(...args)`;
			else exp.children = [
				...exp.children,
				` && `,
				...exp.children,
				`(...args)`
			];
		}
		if (isInlineStatement || shouldCache && isMemberExp) exp = createCompoundExpression([
			`${isInlineStatement ? context.isTS ? `($event: any)` : `$event` : `${context.isTS ? `\n//@ts-ignore\n` : ``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
			exp,
			hasMultipleStatements ? `}` : `)`
		]);
	}
	let ret = { props: [createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))] };
	if (augmentor) ret = augmentor(ret);
	if (shouldCache) ret.props[0].value = context.cache(ret.props[0].value);
	ret.props.forEach((p) => p.key.isHandlerKey = true);
	return ret;
};

//#endregion
//#region packages/compiler-core/src/transforms/vBind.ts
const transformBind = (dir, _node, context) => {
	const { modifiers, loc } = dir;
	const arg = dir.arg;
	let { exp } = dir;
	if (exp && exp.type === 4 && !exp.content.trim()) {
		context.onError(createCompilerError(34, loc));
		return { props: [createObjectProperty(arg, createSimpleExpression("", true, loc))] };
	}
	if (arg.type !== 4) {
		arg.children.unshift(`(`);
		arg.children.push(`) || ""`);
	} else if (!arg.isStatic) arg.content = arg.content ? `${arg.content} || ""` : `""`;
	if (modifiers.some((mod) => mod.content === "camel")) if (arg.type === 4) if (arg.isStatic) arg.content = (0, _vue_shared.camelize)(arg.content);
	else arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
	else {
		arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
		arg.children.push(`)`);
	}
	if (!context.inSSR) {
		if (modifiers.some((mod) => mod.content === "prop")) injectPrefix(arg, ".");
		if (modifiers.some((mod) => mod.content === "attr")) injectPrefix(arg, "^");
	}
	return { props: [createObjectProperty(arg, exp)] };
};
const injectPrefix = (arg, prefix) => {
	if (arg.type === 4) if (arg.isStatic) arg.content = prefix + arg.content;
	else arg.content = `\`${prefix}\${${arg.content}}\``;
	else {
		arg.children.unshift(`'${prefix}' + (`);
		arg.children.push(`)`);
	}
};

//#endregion
//#region packages/compiler-core/src/transforms/transformText.ts
const transformText = (node, context) => {
	if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) return () => {
		const children = node.children;
		let currentContainer = void 0;
		let hasText = false;
		for (let i = 0; i < children.length; i++) {
			const child = children[i];
			if (isText(child)) {
				hasText = true;
				for (let j = i + 1; j < children.length; j++) {
					const next = children[j];
					if (isText(next)) {
						if (!currentContainer) currentContainer = children[i] = createCompoundExpression([child], child.loc);
						currentContainer.children.push(` + `, next);
						children.splice(j, 1);
						j--;
					} else {
						currentContainer = void 0;
						break;
					}
				}
			}
		}
		if (!hasText || children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && !node.props.find((p) => p.type === 7 && !context.directiveTransforms[p.name]) && !(node.tag === "template"))) return;
		for (let i = 0; i < children.length; i++) {
			const child = children[i];
			if (isText(child) || child.type === 8) {
				const callArgs = [];
				if (child.type !== 2 || child.content !== " ") callArgs.push(child);
				if (!context.ssr && getConstantType(child, context) === 0) callArgs.push("1");
				children[i] = {
					type: 12,
					content: child,
					loc: child.loc,
					codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
				};
			}
		}
	};
};

//#endregion
//#region packages/compiler-core/src/transforms/vOnce.ts
const seen$1 = /* @__PURE__ */ new WeakSet();
const transformOnce = (node, context) => {
	if (node.type === 1 && findDir(node, "once", true)) {
		if (seen$1.has(node) || context.inVOnce || context.inSSR) return;
		seen$1.add(node);
		context.inVOnce = true;
		context.helper(SET_BLOCK_TRACKING);
		return () => {
			context.inVOnce = false;
			const cur = context.currentNode;
			if (cur.codegenNode) cur.codegenNode = context.cache(cur.codegenNode, true, true);
		};
	}
};

//#endregion
//#region packages/compiler-core/src/transforms/vModel.ts
const transformModel = (dir, node, context) => {
	const { exp, arg } = dir;
	if (!exp) {
		context.onError(createCompilerError(41, dir.loc));
		return createTransformProps();
	}
	const rawExp = exp.loc.source.trim();
	const expString = exp.type === 4 ? exp.content : rawExp;
	const bindingType = context.bindingMetadata[rawExp];
	if (bindingType === "props" || bindingType === "props-aliased") {
		context.onError(createCompilerError(44, exp.loc));
		return createTransformProps();
	}
	if (bindingType === "literal-const" || bindingType === "setup-const") {
		context.onError(createCompilerError(45, exp.loc));
		return createTransformProps();
	}
	const maybeRef = context.inline && (bindingType === "setup-let" || bindingType === "setup-ref" || bindingType === "setup-maybe-ref");
	if (!expString.trim() || !isMemberExpression(exp, context) && !maybeRef) {
		context.onError(createCompilerError(42, exp.loc));
		return createTransformProps();
	}
	if (context.prefixIdentifiers && isSimpleIdentifier(expString) && context.identifiers[expString]) {
		context.onError(createCompilerError(43, exp.loc));
		return createTransformProps();
	}
	const propName = arg ? arg : createSimpleExpression("modelValue", true);
	const eventName = arg ? isStaticExp(arg) ? `onUpdate:${(0, _vue_shared.camelize)(arg.content)}` : createCompoundExpression(["\"onUpdate:\" + ", arg]) : `onUpdate:modelValue`;
	let assignmentExp;
	const eventArg = context.isTS ? `($event: any)` : `$event`;
	if (maybeRef) if (bindingType === "setup-ref") assignmentExp = createCompoundExpression([
		`${eventArg} => ((`,
		createSimpleExpression(rawExp, false, exp.loc),
		`).value = $event)`
	]);
	else {
		const altAssignment = bindingType === "setup-let" ? `${rawExp} = $event` : `null`;
		assignmentExp = createCompoundExpression([
			`${eventArg} => (${context.helperString(IS_REF)}(${rawExp}) ? (`,
			createSimpleExpression(rawExp, false, exp.loc),
			`).value = $event : ${altAssignment})`
		]);
	}
	else assignmentExp = createCompoundExpression([
		`${eventArg} => ((`,
		exp,
		`) = $event)`
	]);
	const props = [createObjectProperty(propName, dir.exp), createObjectProperty(eventName, assignmentExp)];
	if (context.prefixIdentifiers && !context.inVOnce && context.cacheHandlers && !hasScopeRef(exp, context.identifiers)) props[1].value = context.cache(props[1].value);
	if (dir.modifiers.length && node.tagType === 1) {
		const modifiers = dir.modifiers.map((m) => m.content).map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
		const modifiersKey = arg ? isStaticExp(arg) ? (0, _vue_shared.getModifierPropName)(arg.content) : createCompoundExpression([arg, " + \"Modifiers\""]) : `modelModifiers`;
		props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2)));
	}
	return createTransformProps(props);
};
function createTransformProps(props = []) {
	return { props };
}

//#endregion
//#region packages/compiler-core/src/compat/transformFilter.ts
const validDivisionCharRE = /[\w).+\-_$\]]/;
const transformFilter = (node, context) => {
	if (!isCompatEnabled("COMPILER_FILTERS", context)) return;
	if (node.type === 5) rewriteFilter(node.content, context);
	else if (node.type === 1) node.props.forEach((prop) => {
		if (prop.type === 7 && prop.name !== "for" && prop.exp) rewriteFilter(prop.exp, context);
	});
};
function rewriteFilter(node, context) {
	if (node.type === 4) parseFilter(node, context);
	else for (let i = 0; i < node.children.length; i++) {
		const child = node.children[i];
		if (typeof child !== "object") continue;
		if (child.type === 4) parseFilter(child, context);
		else if (child.type === 8) rewriteFilter(node, context);
		else if (child.type === 5) rewriteFilter(child.content, context);
	}
}
function parseFilter(node, context) {
	const exp = node.content;
	let inSingle = false;
	let inDouble = false;
	let inTemplateString = false;
	let inRegex = false;
	let curly = 0;
	let square = 0;
	let paren = 0;
	let lastFilterIndex = 0;
	let c, prev, i, expression, filters = [];
	for (i = 0; i < exp.length; i++) {
		prev = c;
		c = exp.charCodeAt(i);
		if (inSingle) {
			if (c === 39 && prev !== 92) inSingle = false;
		} else if (inDouble) {
			if (c === 34 && prev !== 92) inDouble = false;
		} else if (inTemplateString) {
			if (c === 96 && prev !== 92) inTemplateString = false;
		} else if (inRegex) {
			if (c === 47 && prev !== 92) inRegex = false;
		} else if (c === 124 && exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) if (expression === void 0) {
			lastFilterIndex = i + 1;
			expression = exp.slice(0, i).trim();
		} else pushFilter();
		else {
			switch (c) {
				case 34:
					inDouble = true;
					break;
				case 39:
					inSingle = true;
					break;
				case 96:
					inTemplateString = true;
					break;
				case 40:
					paren++;
					break;
				case 41:
					paren--;
					break;
				case 91:
					square++;
					break;
				case 93:
					square--;
					break;
				case 123:
					curly++;
					break;
				case 125:
					curly--;
					break;
			}
			if (c === 47) {
				let j = i - 1;
				let p;
				for (; j >= 0; j--) {
					p = exp.charAt(j);
					if (p !== " ") break;
				}
				if (!p || !validDivisionCharRE.test(p)) inRegex = true;
			}
		}
	}
	if (expression === void 0) expression = exp.slice(0, i).trim();
	else if (lastFilterIndex !== 0) pushFilter();
	function pushFilter() {
		filters.push(exp.slice(lastFilterIndex, i).trim());
		lastFilterIndex = i + 1;
	}
	if (filters.length) {
		for (i = 0; i < filters.length; i++) expression = wrapFilter(expression, filters[i], context);
		node.content = expression;
		node.ast = void 0;
	}
}
function wrapFilter(exp, filter, context) {
	context.helper(RESOLVE_FILTER);
	const i = filter.indexOf("(");
	if (i < 0) {
		context.filters.add(filter);
		return `${toValidAssetId(filter, "filter")}(${exp})`;
	} else {
		const name = filter.slice(0, i);
		const args = filter.slice(i + 1);
		context.filters.add(name);
		return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
	}
}

//#endregion
//#region packages/compiler-core/src/transforms/vMemo.ts
const seen = /* @__PURE__ */ new WeakSet();
const transformMemo = (node, context) => {
	if (node.type === 1) {
		const dir = findDir(node, "memo");
		if (!dir || seen.has(node) || context.inSSR) return;
		seen.add(node);
		return () => {
			const codegenNode = node.codegenNode || context.currentNode.codegenNode;
			if (codegenNode && codegenNode.type === 13) {
				if (node.tagType !== 1) convertToBlock(codegenNode, context);
				node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
					dir.exp,
					createFunctionExpression(void 0, codegenNode),
					`_cache`,
					String(context.cached.length)
				]);
				context.cached.push(null);
			}
		};
	}
};

//#endregion
//#region packages/compiler-core/src/transforms/transformVBindShorthand.ts
const transformVBindShorthand = (node, context) => {
	if (node.type === 1) {
		for (const prop of node.props) if (prop.type === 7 && prop.name === "bind" && (!prop.exp || false) && prop.arg) {
			const arg = prop.arg;
			if (arg.type !== 4 || !arg.isStatic) {
				context.onError(createCompilerError(53, arg.loc));
				prop.exp = createSimpleExpression("", true, arg.loc);
			} else {
				const propName = (0, _vue_shared.camelize)(arg.content);
				if (validFirstIdentCharRE.test(propName[0]) || propName[0] === "-") prop.exp = createSimpleExpression(propName, false, arg.loc);
			}
		}
	}
};

//#endregion
//#region packages/compiler-core/src/compile.ts
function getBaseTransformPreset(prefixIdentifiers) {
	return [[
		transformVBindShorthand,
		transformOnce,
		transformIf,
		transformMemo,
		transformFor,
		...[transformFilter],
		...prefixIdentifiers ? [trackVForSlotScopes, transformExpression] : [],
		transformSlotOutlet,
		transformElement,
		trackSlotScopes,
		transformText
	], {
		on: transformOn,
		bind: transformBind,
		model: transformModel
	}];
}
function baseCompile(source, options = {}) {
	const onError = options.onError || defaultOnError;
	const isModuleMode = options.mode === "module";
	/* v8 ignore stop */
	const prefixIdentifiers = options.prefixIdentifiers === true || isModuleMode;
	if (!prefixIdentifiers && options.cacheHandlers) onError(createCompilerError(50));
	if (options.scopeId && !isModuleMode) onError(createCompilerError(51));
	const resolvedOptions = (0, _vue_shared.extend)({}, options, { prefixIdentifiers });
	const ast = (0, _vue_shared.isString)(source) ? baseParse(source, resolvedOptions) : source;
	const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(prefixIdentifiers);
	if (options.isTS) {
		const { expressionPlugins } = options;
		if (!expressionPlugins || !expressionPlugins.includes("typescript")) options.expressionPlugins = [...expressionPlugins || [], "typescript"];
	}
	transform(ast, (0, _vue_shared.extend)({}, resolvedOptions, {
		nodeTransforms: [...nodeTransforms, ...options.nodeTransforms || []],
		directiveTransforms: (0, _vue_shared.extend)({}, directiveTransforms, options.directiveTransforms || {})
	}));
	return generate(ast, resolvedOptions);
}

//#endregion
//#region packages/compiler-core/src/options.ts
const BindingTypes = {
	"DATA": "data",
	"PROPS": "props",
	"PROPS_ALIASED": "props-aliased",
	"SETUP_LET": "setup-let",
	"SETUP_CONST": "setup-const",
	"SETUP_REACTIVE_CONST": "setup-reactive-const",
	"SETUP_MAYBE_REF": "setup-maybe-ref",
	"SETUP_REF": "setup-ref",
	"OPTIONS": "options",
	"LITERAL_CONST": "literal-const"
};

//#endregion
//#region packages/compiler-core/src/transforms/noopDirectiveTransform.ts
const noopDirectiveTransform = () => ({ props: [] });

//#endregion
exports.BASE_TRANSITION = BASE_TRANSITION;
exports.BindingTypes = BindingTypes;
exports.CAMELIZE = CAMELIZE;
exports.CAPITALIZE = CAPITALIZE;
exports.CREATE_BLOCK = CREATE_BLOCK;
exports.CREATE_COMMENT = CREATE_COMMENT;
exports.CREATE_ELEMENT_BLOCK = CREATE_ELEMENT_BLOCK;
exports.CREATE_ELEMENT_VNODE = CREATE_ELEMENT_VNODE;
exports.CREATE_SLOTS = CREATE_SLOTS;
exports.CREATE_STATIC = CREATE_STATIC;
exports.CREATE_TEXT = CREATE_TEXT;
exports.CREATE_VNODE = CREATE_VNODE;
exports.CompilerDeprecationTypes = CompilerDeprecationTypes;
exports.ConstantTypes = ConstantTypes;
exports.ElementTypes = ElementTypes;
exports.ErrorCodes = ErrorCodes;
exports.FRAGMENT = FRAGMENT;
exports.GUARD_REACTIVE_PROPS = GUARD_REACTIVE_PROPS;
exports.IS_MEMO_SAME = IS_MEMO_SAME;
exports.IS_REF = IS_REF;
exports.KEEP_ALIVE = KEEP_ALIVE;
exports.MERGE_PROPS = MERGE_PROPS;
exports.MemberExpLexState = MemberExpLexState;
exports.NORMALIZE_CLASS = NORMALIZE_CLASS;
exports.NORMALIZE_PROPS = NORMALIZE_PROPS;
exports.NORMALIZE_STYLE = NORMALIZE_STYLE;
exports.NewlineType = NewlineType;
exports.NodeTypes = NodeTypes;
exports.OPEN_BLOCK = OPEN_BLOCK;
exports.POP_SCOPE_ID = POP_SCOPE_ID;
exports.PUSH_SCOPE_ID = PUSH_SCOPE_ID;
exports.RENDER_LIST = RENDER_LIST;
exports.RENDER_SLOT = RENDER_SLOT;
exports.RESOLVE_COMPONENT = RESOLVE_COMPONENT;
exports.RESOLVE_DIRECTIVE = RESOLVE_DIRECTIVE;
exports.RESOLVE_DYNAMIC_COMPONENT = RESOLVE_DYNAMIC_COMPONENT;
exports.RESOLVE_FILTER = RESOLVE_FILTER;
exports.SET_BLOCK_TRACKING = SET_BLOCK_TRACKING;
exports.SUSPENSE = SUSPENSE;
exports.TELEPORT = TELEPORT;
exports.TO_DISPLAY_STRING = TO_DISPLAY_STRING;
exports.TO_HANDLERS = TO_HANDLERS;
exports.TO_HANDLER_KEY = TO_HANDLER_KEY;
exports.TS_NODE_TYPES = TS_NODE_TYPES;
exports.UNREF = UNREF;
exports.WITH_CTX = WITH_CTX;
exports.WITH_DIRECTIVES = WITH_DIRECTIVES;
exports.WITH_MEMO = WITH_MEMO;
exports.advancePositionWithClone = advancePositionWithClone;
exports.advancePositionWithMutation = advancePositionWithMutation;
exports.assert = assert;
exports.baseCompile = baseCompile;
exports.baseParse = baseParse;
exports.buildDirectiveArgs = buildDirectiveArgs;
exports.buildProps = buildProps;
exports.buildSlots = buildSlots;
exports.checkCompatEnabled = checkCompatEnabled;
exports.convertToBlock = convertToBlock;
exports.createArrayExpression = createArrayExpression;
exports.createAssignmentExpression = createAssignmentExpression;
exports.createBlockStatement = createBlockStatement;
exports.createCacheExpression = createCacheExpression;
exports.createCallExpression = createCallExpression;
exports.createCompilerError = createCompilerError;
exports.createCompoundExpression = createCompoundExpression;
exports.createConditionalExpression = createConditionalExpression;
exports.createForLoopParams = createForLoopParams;
exports.createFunctionExpression = createFunctionExpression;
exports.createIfStatement = createIfStatement;
exports.createInterpolation = createInterpolation;
exports.createObjectExpression = createObjectExpression;
exports.createObjectProperty = createObjectProperty;
exports.createReturnStatement = createReturnStatement;
exports.createRoot = createRoot;
exports.createSequenceExpression = createSequenceExpression;
exports.createSimpleExpression = createSimpleExpression;
exports.createStructuralDirectiveTransform = createStructuralDirectiveTransform;
exports.createTemplateLiteral = createTemplateLiteral;
exports.createTransformContext = createTransformContext;
exports.createVNodeCall = createVNodeCall;
exports.defaultOnError = defaultOnError;
exports.defaultOnWarn = defaultOnWarn;
exports.errorMessages = errorMessages;
exports.extractIdentifiers = extractIdentifiers;
exports.filterNonCommentChildren = filterNonCommentChildren;
exports.findDir = findDir;
exports.findProp = findProp;
exports.forAliasRE = forAliasRE;
exports.generate = generate;
exports.generateCodeFrame = _vue_shared.generateCodeFrame;
exports.getBaseTransformPreset = getBaseTransformPreset;
exports.getConstantType = getConstantType;
exports.getMemoedVNodeCall = getMemoedVNodeCall;
exports.getSelfName = getSelfName;
exports.getVNodeBlockHelper = getVNodeBlockHelper;
exports.getVNodeHelper = getVNodeHelper;
exports.hasDynamicKeyVBind = hasDynamicKeyVBind;
exports.hasScopeRef = hasScopeRef;
exports.hasSingleChild = hasSingleChild;
exports.helperNameMap = helperNameMap;
exports.injectProp = injectProp;
exports.isAllWhitespace = isAllWhitespace;
exports.isCommentOrWhitespace = isCommentOrWhitespace;
exports.isConstantNode = isConstantNode;
exports.isCoreComponent = isCoreComponent;
exports.isFnExpression = isFnExpression;
exports.isFnExpressionBrowser = isFnExpressionBrowser;
exports.isFnExpressionNode = isFnExpressionNode;
exports.isFunctionType = isFunctionType;
exports.isInDestructureAssignment = isInDestructureAssignment;
exports.isInNewExpression = isInNewExpression;
exports.isLiteralWhitelisted = isLiteralWhitelisted;
exports.isMemberExpression = isMemberExpression;
exports.isMemberExpressionBrowser = isMemberExpressionBrowser;
exports.isMemberExpressionNode = isMemberExpressionNode;
exports.isReferencedIdentifier = isReferencedIdentifier;
exports.isSimpleIdentifier = isSimpleIdentifier;
exports.isSingleIfBlock = isSingleIfBlock;
exports.isSlotOutlet = isSlotOutlet;
exports.isStaticArgOf = isStaticArgOf;
exports.isStaticExp = isStaticExp;
exports.isStaticNode = isStaticNode;
exports.isStaticProperty = isStaticProperty;
exports.isStaticPropertyKey = isStaticPropertyKey;
exports.isTemplateNode = isTemplateNode;
exports.isText = isText;
exports.isVPre = isVPre;
exports.isVSlot = isVSlot;
exports.isWhitespaceText = isWhitespaceText;
exports.locStub = locStub;
exports.noopDirectiveTransform = noopDirectiveTransform;
exports.processExpression = processExpression;
exports.processFor = processFor;
exports.processIf = processIf;
exports.processSlotOutlet = processSlotOutlet;
exports.registerRuntimeHelpers = registerRuntimeHelpers;
exports.resolveComponentType = resolveComponentType;
exports.stringifyExpression = stringifyExpression;
exports.toValidAssetId = toValidAssetId;
exports.trackSlotScopes = trackSlotScopes;
exports.trackVForSlotScopes = trackVForSlotScopes;
exports.transform = transform;
exports.transformBind = transformBind;
exports.transformElement = transformElement;
exports.transformExpression = transformExpression;
exports.transformModel = transformModel;
exports.transformOn = transformOn;
exports.transformVBindShorthand = transformVBindShorthand;
exports.traverseNode = traverseNode;
exports.unwrapTSNode = unwrapTSNode;
exports.validFirstIdentCharRE = validFirstIdentCharRE;
exports.walkBlockDeclarations = walkBlockDeclarations;
exports.walkFunctionParams = walkFunctionParams;
exports.walkIdentifiers = walkIdentifiers;
exports.warnDeprecation = warnDeprecation;